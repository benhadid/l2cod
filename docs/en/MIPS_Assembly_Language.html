<!DOCTYPE html>
<html>

  <head>
  
    <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-5KMKZK4Z38"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-5KMKZK4Z38');
  </script>
  

  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title> The MIPS Assembly Language - Computer Design / Fall 2024 </title>
  <meta name="description" content="IntroductionA sample program in MIPS assembly language is shown below# Title:# Author:# Date:# Description:# Input parameters:# Return data:#################...">
  
  <!--for gitlab pages -->
  

  <!-- automatic favicons -->
  

    <!--for github pages -->
  <link rel="shortcut icon" href="https://benhadid.github.io/l2ado/favicon.ico?"> 
  <!--for github-->

  <link rel="stylesheet" href="/l2ado/_css/main.css">
  <link rel="canonical" href="https://benhadid.github.io/l2ado/docs/en/MIPS_Assembly_Language">
  <link rel="alternate" type="application/rss+xml" title="Computer Design / Fall 2024 - " href="https://benhadid.github.io/l2ado/feed.xml" />

  <link rel='stylesheet' id='open-sans-css'  href='//fonts.googleapis.com/css?family=Open+Sans%3A300italic%2C400italic%2C600italic%2C300%2C400%2C600&#038;subset=latin%2Clatin-ext&#038;ver=4.2.4' type='text/css' media='all' />
  <link href='https://fonts.googleapis.com/css?family=Titillium+Web:600italic,600,400,400italic' rel='stylesheet' type='text/css'>

  

  

  <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.2.0/css/all.css" integrity="sha384-hWVjflwFxL6sNzntih27bfxkr27PmbbK/iSvJ+a4+0owXq79v+lsFkW54bOGbiDQ" crossorigin="anonymous">

  <!-- MathJax -->
  <script type="text/javascript" async
    src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML">
  </script>
</head>


  <body>

    <header class="site-header">

  <div class="wrapper" style="z-index: 100;">
      <table><tr>
          <td><img width="75" src="/l2ado/_images/logo.png" valign="middle"></td>
          <td style="padding-left:10px;"><a class="schoolname" style="font-size: 15px;" class="site-title" href=""></a>
          <br/>      
          <span style="margin-top: -2px;margin-bottom: -10px;" class="site-title"><a href="/l2ado/" title="Computer Design / Fall 2024 - "><b>Computer Design</a></b></span>
          <br/>
          <span class="coursesemeter" style="font-size: 12px;font-weight: bold;margin-top: 10px;display: block;">Fall 2024</span>
          </td>
        </tr></table>

    <nav class="site-nav">

      <a href="#" class="menu-icon menu.open">
        <svg viewBox="0 0 18 15">
          <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
          <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
          <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
        </svg>
      </a>  

    <div class="trigger"><h1>Main Navigation</h1> <ul class="menu">
    
    <li>

      
      

      <a class="page-link" href="/l2ado/">
        <i class="fa fa-home fa-lg"></i> Home
      </a>

    </li>
    
    <li>

      
      

      <a class="page-link" href="/l2ado/schedule/">
        <i class="fas fa-calendar-alt"></i> Schedule
      </a>

    </li>
    
    <li>

      
      

      <a class="page-link" href="/l2ado/lectures/">
        <i class="fas fa-book-reader"></i> Lectures
      </a>

    </li>
    
    <li>

      
      

      <a class="page-link" href="/l2ado/discussions/">
        <i class="fas fa-user-graduate"></i> Seminars
      </a>

    </li>
    
    <li>

      
      

      <a class="page-link" href="/l2ado/labs/">
        <i class="fas fa-laptop-code"></i> Labs
      </a>

    </li>
    
    <li>

      
      

      <a class="page-link" href="/l2ado/quizzes/">
        <i class="fas fa-question-circle"></i> Quizzes
      </a>

    </li>
    
    <li>

      
      

      <a class="page-link" href="/l2ado/projects/">
        <i class="fas fa-user-graduate"></i> Projects
      </a>

    </li>
    
    <li>

      
      

      <a class="page-link" href="/l2ado/materials/">
        <i class="fas fa-book"></i> Resources
      </a>

    </li>
    
</ul>
 </div>  
    
    </nav>
  </div>

  <div></div>

  <div class="header-texture" style="height:100%; z-index: 0; position: absolute; top:0; right: 0; left: 0; background-image: url( /l2ado/_images/pattern.png );" >
  </div>

</header>


    <div class="page-content">
      <div class="wrapper">
        <div class="post">

  <header class="post-header">
    <h1 class="post-title">The MIPS Assembly Language</h1>
  </header>

  <article class="post-content">
    <h1 id="introduction">Introduction</h1>

<p>A sample program in MIPS assembly language is shown below</p>

<pre><code class="language-mips"># Title:
# Author:
# Date:
# Description:
# Input parameters:
# Return data:
#################### data segment #########################
.data
. . .
#################### code segment #########################
.text
.globl main
main: # start of main function
. . .
li $v0, 10
syscall # system call to exit
</code></pre>

<p>There are three types of instructions that can be used in assembly language, where each instruction appears on a separate line:</p>

<ul>
  <li><strong>Assembler Directives</strong>: These provide information to the <em>Assembler tool</em> for translating a program into machine code. Directives are used to define segments and allocate space in memory for global program variables. An assembler directive always begins with a period (.). A typical MIPS assembly language program uses the following directives:
    <ul>
      <li><strong>.data</strong>: defines the data segment of the program, containing the global program variables.</li>
      <li><strong>.text</strong>: defines the code segment of the program, containing the instructions to be executed.</li>
      <li><strong>.globl</strong>: defines a symbol (label) as global that can be referenced from other files.</li>
    </ul>
  </li>
  <li>
    <p><strong>Executable Instructions</strong>: These generate machine code that will be executed by the processor. The instructions tell the processor what to do.</p>
  </li>
  <li><strong>Pseudo Instructions and Macros</strong>: Translated by the <em>Assembler tool</em> into actual instructions. These pseudo-instructions simplify the coding task.</li>
</ul>

<p>Additionally, comments can be inserted into the code. Comments are very important to programmers, but ignored by the <em>Assembler tool</em>. In MIPS, a comment begins with the symbol <code class="language-plaintext highlighter-rouge">#</code> and ends at the end of the line. Comments can appear at the beginning of a line or after an instruction. They explain the purpose of the program, when it was written, revised, and by whom. They explain the data and registers used in the program, the inputs, outputs, the sequence of instructions, and the algorithms implemented.</p>

<h1 id="the-edit-assemble-link-execute-cycle">The Edit-Assemble-Link-Execute Cycle</h1>

<p>Before we can run a MIPS program, we need to convert the source text written in assembly language into a form that can be executed by the processor. This is done in two steps:</p>

<ol>
  <li>
    <p><em>Assembling</em>: Translates the assembly language text into a binary object file. This is done by the <em>Assembler</em> tool. If there is more than one assembly language source file, then each of these files will be assembled separately. The <em>Assembler</em> tool detects all <strong>syntax errors</strong> and will report them to the programmer. The latter will have to amend his program accordingly and assemble it again.</p>
  </li>
  <li>
    <p><em>Linking</em>: Combines all the object files together (if there is more than one) and possibly with function libraries. This task is done by the <em>linker</em> tool. The linker checks and links the function calls in the object files with libraries or other object files. The result of this step is an <strong>executable</strong> file.</p>
  </li>
</ol>

<p>It is typical that the first executable version of your program would have some <strong>runtime errors</strong>. These errors are not detectable by the <em>Assembler tool</em>, but occur when you run your program (e.g. your program may produce wrong results). Therefore, you should <em>debug</em> your program to identify errors at runtime. In this sense, you should run your program with different input values ​​and different operating situations to make sure it runs correctly. In essence, writing a program, whether in assembly or any other language, will require going through a cycle of edit-assemble-link-execute until all errors are ironed out and the correct results are obtained. The figure below summarizes the <em>Edit-Assemble-Link-Execute</em> cycle.</p>

<p><img src="/l2ado/static_files/images/Edit-Assemble-Link-Execute_en.png" alt="EALE" class="aligncenter" /></p>

<p>In <a href="/l2ado/static_files/docs/MARS.html">MARS</a>, you can use the “slow execution” mode, the “single-step” feature, or insert “breakpoints” into your program to debug errors. “Single-step” execution mode is a standard and essential feature in any debugger. It allows you to inspect the effect of <em>each instruction</em> on the processor registers and main memory.</p>

<h1 id="mips-registers-and-instructions">MIPS Registers and Instructions</h1>

<p>The MIPS architecture defines 32 general purpose registers, numbered from <code class="language-plaintext highlighter-rouge">$0</code> to <code class="language-plaintext highlighter-rouge">$31</code>. The symbol <code class="language-plaintext highlighter-rouge">$</code> is used to denote a register. To simplify assembly programming, we can also refer to the registers by their names as shown below. The <em>Assembler tool</em> will then convert the register names to their corresponding numbers.</p>

<table class="styled-table">
<colgroup>
<col width="20%" />
<col width="15%" />
<col width="65%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align:center">Number</th>
<th style="text-align:center">Name</th>
<th style="text-align:center">Use</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">$0</td>
<td style="text-align:center">$0</td>
<td style="text-align:left">always equal to 0</td>
</tr>

<tr>
<td style="text-align:center">$1</td>
<td style="text-align:center">$at</td>
<td style="text-align:left">is used by the assembler tool for pseudo instruction expansion</td>
</tr>

<tr>
<td style="text-align:center">$2-$3</td>
<td style="text-align:center">$v0-$v1</td>
<td style="text-align:left">hold the values ​​returned by the called functions</td>
</tr>

<tr>
<td style="text-align:center">$4-$7</td>
<td style="text-align:center">$a0-$a3</td>
<td style="text-align:left">used to pass arguments to functions</td>
</tr>

<tr>
<td style="text-align:center">$8-$15 , $24-$25</td>
<td style="text-align:center">$t0-$t9</td>
<td style="text-align:left">for handling temporary data</td>
</tr>

<tr>
<td style="text-align:center">$16-$23</td>
<td style="text-align:center">$s0-$s7</td>
<td style="text-align:left">store local data to functions</td>
</tr>

<tr>
<td style="text-align:center">$26-$27</td>
<td style="text-align:center">$k0-$k1</td>
<td style="text-align:left">kernel registers – used by exception/interrupt routines</td>
</tr>

<tr>
<td style="text-align:center">$28</td>
<td style="text-align:center">$gp</td>
<td style="text-align:left">pointer to global data of the program</td>
</tr>

<tr>
<td style="text-align:center">$29</td>
<td style="text-align:center">$sp</td>
<td style="text-align:left">stack pointer</td>
</tr>

<tr>
<td style="text-align:center">$30</td>
<td style="text-align:center">$fp</td>
<td style="text-align:left">frame pointer</td>
</tr>

<tr>
<td style="text-align:center">$31</td>
<td style="text-align:center">$ra</td>
<td style="text-align:left">stores the return address (i.e. where to return to in the calling function)</td>
</tr>
</tbody>
</table>

<p>The general syntax of an instruction in MIPS is:</p>

<pre><code class="language-mips">[label:] mnemonic  [operands]  [# comment]
</code></pre>
<ul>
  <li>
    <p><code class="language-plaintext highlighter-rouge">label</code> is optional. It marks the address in memory of the instruction and must be followed by a colon (:). In addition, a <strong>label</strong> can be used to refer to the address of a variable in memory.</p>
  </li>
  <li>
    <p>The <code class="language-plaintext highlighter-rouge">mnemonic</code> indicates the operation to be performed: <code class="language-plaintext highlighter-rouge">add</code>, <code class="language-plaintext highlighter-rouge">sub</code>, <code class="language-plaintext highlighter-rouge">sll</code>, etc.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">operands</code> specify the data required by the instruction. Different instructions have different numbers of operands. Operands can be registers, labels, or constants. Most arithmetic and logic instructions require three operands.</p>
  </li>
</ul>

<p>Here is an example of a MIPS instruction</p>

<pre><code class="language-mips"> L1: addiu $t0, $t0, 1	# increment $t0
</code></pre>

<p>A program written in assembler consists of a set of instructions of this type. Depending on the operation performed, the set of MIPS instructions can be grouped into five categories::</p>
<ul>
  <li>arithmetic instructions,</li>
  <li>logic instructions,</li>
  <li>data transfer instructions,</li>
  <li>branching instructions, and</li>
  <li>system call instructions</li>
</ul>

<p><strong>N.B:</strong> The instruction categories below are described in the <a href="https://fr.wikipedia.org/wiki/Register_Transfer_Language">RTL</a> format. This is an intermediate representation close to assembly language, but which allows a general representation of instructions. Here, <code class="language-plaintext highlighter-rouge">rd</code>, <code class="language-plaintext highlighter-rouge">rs</code> and <code class="language-plaintext highlighter-rouge">rt</code> mean one of the 32 MIPS registers. For example, if <code class="language-plaintext highlighter-rouge">rd = $a0</code>, <code class="language-plaintext highlighter-rouge">rs = $s0</code> and <code class="language-plaintext highlighter-rouge">rt = $0</code> then the first instruction in the list below becomes in MIPS assembler:</p>

<pre><code class="language-mips"> add   $a0, $s0, $0	   # $a0 = $s0 + $0
</code></pre>

<h2 id="arithmetic-instructions">Arithmetic instructions</h2>

<pre><code class="language-RTL"> add    rd, rs, rt     # rd = rs + rt                 (addition)
 sub    rd, rs, rt     # rd = rs – rt                 (substruction) 
 addu   rd, rs, rt     # rd = rs + rt                 (unsigned addition)  
 subu   rd, rs, rt     # rd = rs - rt                 (unsigned substruction)  
 addi   rt, rs, Imm    # rt = rs + Imm                (Imm is a 16-bit signed constant)
 addiu  rt, rs, Imm    # rt = rs + Imm                (Imm is a 16-bit unsigned constant)

 mult   rs, rt         # [HI,LO] = rs * rt            (multiplication) 
 multu  rs, rt         # [HI,LO] = rs * rt            (unsigned multiplication)
 
 div    rs, rt         # HI = rs % rt; LO = rs / rt   (division)
 divu   rs, rt         # HI = rs % rt; LO = rs / rt   (unsigned division)  
</code></pre>

<h2 id="logic-instructions">Logic instructions</h2>

<pre><code class="language-RTL"> or    rd, rs, rt      # rd = rs | rt                 (logical OR)
 and   rd, rs, rt      # rd = rs &amp; rt                 (logical AND)
 xor   rd, rs, rt      # rd = rs ^ rt                 (logical eXclusive OR) 
 nor   rd, rs, rt      # rd = ~(rs | rt)              (logical NOT OR)
 ori   rt, rs, Imm     # rt = rs | Imm                (Imm is a 16-bit unsigned constant)
 andi  rt, rs, Imm     # rt = rs &amp; Imm                (Imm is a 16-bit unsigned constant)
 xori  rt, rs, Imm     # rt = rs ^ Imm                (Imm is a 16-bit unsigned constant) 

 sllv  rd, rt, rs      # rd = rt &lt;&lt; rs                (logical shift left with rs[4..0])
 srlv  rd, rt, rs      # rd = rt &gt;&gt;&gt; rs               (logical shift right with rs[4..0]) 
 srav  rd, rt, rs      # rd = rt &gt;&gt; rs                (arithmetic shift right with rs[4..0]) 

 sll   rd, rt, Sha     # rd = rt &lt;&lt; Sha               (logical shift left with 0 &lt;= Sha &lt;=31)
 srl   rd, rt, Sha     # rd = rt &gt;&gt;&gt; Sha              (logical shift right with 0 &lt;= Sha &lt;=31)
 sra   rd, rt, Sha     # rd = rt &gt;&gt; Sha               (Arithmetic shift right with 0 &lt;= Sha &lt;= 31)     

 slt   rd, rs, rt      # rd = rs &lt; rt ? 1 : 0         (if rs &lt; rt then rd = 1 else rd = 0)
 sltu  rd, rs, rt      # rd = rs &lt; rt ? 1 : 0         (rs and rt are unsigned operands)
 slti  rt, rs, Imm     # rt = rs &lt; Imm ? 1 : 0        (similar to slt with Imm a 16-bit signed constant)
 sltiu rt, rs, Imm     # rt = rs &lt; Imm ? 1 : 0        (similar to sltu with Imm a 16-bit unsigned constant)
</code></pre>

<h2 id="data-transfer-instructions">Data transfer instructions</h2>

<pre><code class="language-RTL"> mfhi  rd              # rd = HI                      (move HI register to rd register)
 mflo  rd              # rd = LO                      (move LO register to rd register)
 mthi  rs              # HI = rs                      (move rs register to HI register)
 mtlo  rs              # LO = rs                      (move rs register to LO register)
 lui   rt, Imm         # rt = Imm &lt;&lt; 16               (rt[31..16] = Imm, rt[15..0] = 0)

 lw    rt, Imm(rs)     # rt = MEM[rs + Imm]           (load a 'word' from memory)
 sw    rt, Imm(rs)     # MEM[rs + Imm] = rt           (store a 'word' into memory)
 lh    rt, Imm(rs)     # rt = MEM[rs + Imm]           (load a 'half-word' from memory - i.e. do sign extension)
 lhu   rt, Imm(rs)     # rt = MEM[rs + Imm]           (load an unsigned 'half-word' from memory - i.e. do zero extension)
 sh    rt, Imm(rs)     # MEM[rs + Imm] = rt           (store a'half-word' into memory)
 lb    rt, Imm(rs)     # rt = MEM[rs + Imm]           (load a byte from memory - i.e. do sign extension)
 lbu   rt, Imm(rs)     # rt = MEM[rs + Imm]           (load an unsigned byte from memory - i.e. do zero extension)
 sb    rt, Imm(rs)     # MEM[rs + Imm] = rt           (store a byte into memory)
</code></pre>

<h2 id="branching-instructions">Branching instructions</h2>

<pre><code class="language-RTL"> beq   rs, rt, label   # if (rs == rt) goto label     (take the branch if equal)
 bne   rs, rt, label   # if (rs != rt) goto label     (take the branch if not equal)
 bgez  rs, label       # if (rs &gt;= 0) goto label      (take the branch if greater than or equal to zero)
 bgtz  rs, label       # if (rs &gt;  0) goto label      (take the branch if greater than zero)
 blez  rs, label       # if (rs &lt;= 0) goto label      (take the branch if less than or equal to zero)
 bltz  rs, label       # if (rs &lt;  0) goto label      (take the branch if less than zero)
 
 j     label           # goto label                   (jump to address)
 jal   label           # $ra = $pc + 4 ; goto label   (jump to address and link in $ra the returning position)
 jr    rs              # $pc = rs                     (jump to address in register rs)
 jalr  rs              # $ra = $pc + 4 ; $pc = rs     (jump to address in register rs and link in $ra the returning position)   
 jalr  rd, rs          # rd  = $pc + 4 ; $pc = rs     (jump to address in register rs and link in rd the returning position)
</code></pre>

<h2 id="system-calls-instructions">System calls instructions</h2>

<p>A program performs inputs and outputs using specific instructions that generate system calls. On a real machine, these calls are managed by the operating system (Windows, macOS, UN*X, etc.). In the MIPS architecture, it is the special instruction (<code class="language-plaintext highlighter-rouge">syscall</code>) that allows generating “system calls”.</p>

<p>Before calling the <code class="language-plaintext highlighter-rouge">syscall</code> instruction, the <code class="language-plaintext highlighter-rouge">$v0</code> register is initialized with the required service number (i.e., the functionality requested from the operating system). In addition, the <code class="language-plaintext highlighter-rouge">$a0</code>–<code class="language-plaintext highlighter-rouge">$a3</code> registers are used to pass any additional arguments to the routine. After issuing the <code class="language-plaintext highlighter-rouge">syscall</code> instruction, any value returned by the operating system is retrieved from the <code class="language-plaintext highlighter-rouge">$v0</code> register.</p>

<p>System call handling routines are specific to the operating system. On MARS, which is a simulator and not a real system, there is no operating system involved. Hence, it is the MARS simulator that provides system services to programs by handling the initiated system calls. The following table shows a small set of services provided by MARS for basic input/output operations.</p>

<table class="styled-table">
<thead>
<tr class="header">
<th style="text-align:center">Service</th>
<th style="text-align:center">$v0</th>
<th style="text-align:center">Argument(s)</th>
<th style="text-align:center">Return</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Print an integer</td>
<td style="text-align:center">1</td>
<td style="text-align:left"><code class="language-plaintext highlighter-rouge">$a0</code> = integer to print</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">Print a string of characters</td>
<td style="text-align:center">4</td>
<td style="text-align:left"><code class="language-plaintext highlighter-rouge">$a0</code> = address of the string of characters</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">Read in integer from the terminal</td>
<td style="text-align:center">5</td>
<td style="text-align:left"></td>
<td style="text-align:left"><code class="language-plaintext highlighter-rouge">$v0</code> = returned integer</td>
</tr>
<tr>
<td style="text-align:left">Read a string of characters from the terminal</td>
<td style="text-align:center">8</td>
<td style="text-align:left"><code class="language-plaintext highlighter-rouge">$a0</code> = memory address where to store the string<br /><code class="language-plaintext highlighter-rouge">$a1</code> = maximum number of characters to read from the terminal</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">Terminate program execution</td>
<td style="text-align:center">10</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">Print a character</td>
<td style="text-align:center">11</td>
<td style="text-align:left"><code class="language-plaintext highlighter-rouge">$a0</code> = character to print</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">Read a character from the terminal</td>
<td style="text-align:center">12</td>
<td style="text-align:left"></td>
<td style="text-align:left"><code class="language-plaintext highlighter-rouge">$v0</code> = returned character</td>
</tr>
</tbody>
</table>

<p>The code example below shows a simple program that prompts the user for a value (an integer) and then displays that value on the MARS console (our simulated screen). Five system calls are used. The first system call displays the string <code class="language-plaintext highlighter-rouge">str1</code>, the second system call reads an integer as input. The third call displays the string <code class="language-plaintext highlighter-rouge">str2</code>, the fourth system call displays the value that was entered by the user, and the fifth system call exits the program.</p>

<pre><code class="language-mips">.data
str1:     .asciiz   "Enter a value: "
str2:     .asciiz   "You entered the value: "


.globl main
.text
main:
   addi $v0, $0, 4      # $v0 = service number for 'print a string of characters'
   la   $a0, str1       # $a0 = memory address of the string to print (here str1)
   syscall              # a system call for printing the string str1

   addi $v0, 5          # $v0 = service number for 'read an integer'
   syscall              # a system call for reading an integer from the console. 
                        # The value is returned in $v0

   add  $s0, $v0, $0    # $s0 = $v0  ($s0 = value entered by the user)
   addi $v0, $0, 4      # $v0 = service number for 'print a string of characters'
   la   $a0, str2       # $a0 = memory address of the string to print (here str2) 
   syscall              # a system call for printing the string str2

   addi $v0, $0, 1      # $v0 = service number for 'print an integer'
   add  $a0, $s0, $0    # $a0 = $s0 ($a0 = value to print)
   syscall              # a system call for printing the integer entered previously.

   addi $v0, $0, 10     # $v0 = service number for 'quit execution'
   syscall              # a system call for terminating the execution of the program    
</code></pre>

<h1 id="assembler-pseudo-instructions">Assembler Pseudo-instructions</h1>

<p>Pseudo-instructions are “macros” (group of basic instructions) recognised by the <em>Assembler tool</em> and behave as if they were real instructions. Pseudo-instructions are useful because they make programming in assembly language easier.</p>

<p>We saw above an example of pseudo-instructions (i.e. <code class="language-plaintext highlighter-rouge">bgez</code>–<code class="language-plaintext highlighter-rouge">bltz</code>). Another set of instructions that the MIPS ISA does not implement are the following conditional instructions:</p>

<pre><code class="language-RTL"> blt   rs, rt, label   # if (rs &lt; rt) goto label        (take the branch if less than)
 bltu  rs, rt, label   # if (rs &lt; rt) goto label        (take the branch if less than - unsigned comparison) 
 ble   rs, rt, label   # if (rs &lt;= rt) goto label       (take the branch if less than or equal) 
 bleu  rs, rt, label   # if (rs &lt;= rt) goto label       (take the branch if less than or equal - unsigned comparison) 
 bgt   rs, rt, label   # if (rs &gt; rt) goto label        (take the branch if greater than)
 bgtu  rs, rt, label   # if (rs &gt; rt) goto label        (take the branch if greater than - unsigned comparison) 
 bge   rs, rt, label   # if (rs &gt;= rt) goto label       (take the branch if greater than or equal) 
 bgeu  rs, rt, label   # if (rs &gt;= rt) goto label       (take the branch if greater than or equal - unsigned comparison) 
</code></pre>

<p>The aforementioned instructions are not hardwired in the MIPS ISA because they can be easily implemented using a reduced set of actual instructions. For example, the pseudo-instruction <code class="language-plaintext highlighter-rouge">blt $s0, $s1, etiq</code> can be replaced by the following sequence of real instructions:</p>

<pre><code class="language-mips"> slt  $at, $a0, $s1
 bne  $at, $0, etiq
</code></pre>

<p>Similarly, the pseudo-instruction <code class="language-plaintext highlighter-rouge">ble $s2, $s3, etiq</code> will be converted by the <em>Assembler tool</em> into this sequence of real instructions:</p>

<pre><code class="language-mips"> slt  $at, $s3, $s2
 beq  $at, $0, etiq
</code></pre>

<p>Note the use of register <code class="language-plaintext highlighter-rouge">$at</code> as a temporary register when converting pseudo-instructions to real instructions. <strong>This register is reserved by the <em>Assembler tool</em> for this purpose</strong>. The table below shows other examples of MIPS pseudo-instructions.</p>

<table class="styled-table">
<thead>
<tr class="header">
<th style="text-align:center">Pseudo-instruction</th>
<th style="text-align:center">Actual instruction(s)</th>
<th style="text-align:center">Operation</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><samp>move $s1, $s2</samp></td>
<td style="text-align:left"><samp>addu $s1, $2, $0</samp></td>
<td style="text-align:left"><samp>$s1 = $s2</samp></td>
</tr>
<tr>
<td style="text-align:left"><samp>not $s1, $s2</samp></td>
<td style="text-align:left"><samp>nor $s1, $s2, $0</samp></td>
<td style="text-align:left"><samp>$s1 = not($s2)</samp></td>
</tr>
<tr>
<td style="text-align:left"><samp>li $s1, 0xabcd</samp></td>
<td style="text-align:left"><samp>ori $s1, $0, 0xabcd</samp></td>
<td style="text-align:left"><samp>$s1 = 0x0000abcd</samp></td>
</tr>
<tr>
<td style="text-align:left; vertical-align:top"><samp>li $s1, 0xabcd1234</samp></td>
<td style="text-align:left"><samp>lui $at, $x0abcd</samp><br /><samp>ori $s1, $at, 0x1234</samp></td>
<td style="text-align:left; vertical-align:top"><samp>$s1 = 0xabcd1234</samp></td>
</tr>
<tr>
<td style="text-align:left"><samp>sgt $s1, $s2, $s3</samp></td>
<td style="text-align:left"><samp>slt $s1, $s3, $s2</samp></td>
<td style="text-align:left"><samp>$s1 = $s2 &gt; $s3 ? 1 : 0</samp></td>
</tr>
<tr>
<td style="text-align:left; vertical-align:top"><samp>blt $s1, $s2, label</samp></td>
<td style="text-align:left"><samp>slt $at, $s1, $s2<br /><samp>bne $at, $0, label</samp></samp></td>
<td style="text-align:left; vertical-align:top"><samp>if $s1 &lt; $s2 goto label</samp></td>
</tr>
</tbody>
</table>

<h1 id="translation-of-control-structures-in-high-level-languages-to-mips">Translation of control structures in high level languages ​​to MIPS</h1>

<p>One can translate any high-level control structure to assembler using branching instructions. Consider the following <code class="language-plaintext highlighter-rouge">if</code> test in the C language:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">if</span> <span class="p">(</span> <span class="n">a</span> <span class="o">==</span> <span class="n">b</span> <span class="p">)</span>
     <span class="n">c</span> <span class="o">=</span> <span class="n">d</span> <span class="o">+</span> <span class="n">e</span><span class="p">;</span>
  <span class="k">else</span>
     <span class="n">c</span> <span class="o">=</span> <span class="n">d</span> <span class="o">-</span> <span class="n">e</span><span class="p">;</span>
</code></pre></div></div>

<p>If we assume the C compiler has associated the registers <code class="language-plaintext highlighter-rouge">$s0</code> – <code class="language-plaintext highlighter-rouge">$s4</code> with the variables <code class="language-plaintext highlighter-rouge">a</code>,<code class="language-plaintext highlighter-rouge">b</code>,<code class="language-plaintext highlighter-rouge">c</code>,<code class="language-plaintext highlighter-rouge">d</code> and <code class="language-plaintext highlighter-rouge">e</code>. The above test can be performed in MIPS assembly with the following instructions:</p>

<pre><code class="language-mips">  bne  $s0, $s1, ELSE
  add  $s2, $s3, $s4 
  j EXIT
ELSE:	
  sub  $s2, $s3, $s4 
EXIT: 
  . . .
</code></pre>

<p>We can also implement a compound condition involving the logical operator <code class="language-plaintext highlighter-rouge">&amp;&amp;</code>:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">if</span> <span class="p">(</span> <span class="p">(</span><span class="n">b</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">c</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">)</span>
     <span class="n">d</span><span class="o">++</span><span class="p">;</span>
</code></pre></div></div>

<p>In assembler, the <code class="language-plaintext highlighter-rouge">if</code> statement above is implemented using the <em>fall through</em> algorithmic concept. The idea here is to ‘skip’ the execution of the instruction following the test if the condition is not true:</p>

<pre><code class="language-mips">  blez   $s1, next    # branch to next if b &lt;= 0
  bgez   $s2, next    # branch to next if c &gt;= 0
  addiu  $s3, $s3, 1  # d++ ; both conditions are true
next: 
  . . .
</code></pre>

<p>Similarly, we can also translate an <code class="language-plaintext highlighter-rouge">if</code> test with a compound condition involving the logical operator <code class="language-plaintext highlighter-rouge">||</code>. For example :</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="k">if</span> <span class="p">(</span> <span class="p">(</span><span class="n">b</span> <span class="o">&gt;</span> <span class="n">c</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">c</span> <span class="o">&gt;</span> <span class="n">d</span><span class="p">)</span> <span class="p">)</span> 
   <span class="n">e</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</code></pre></div></div>

<p>The assembly implementation below checks the first condition of the test if it is true and therefore skips checking the second condition:</p>

<pre><code class="language-mips">  bgt    $s1, $s2, L1    # branch to L1 if b &gt; c (i.e. go into the block of the if statement)
  ble    $s2, $s3, next  # branch to next if c &lt;= d. Implicitly one has b &lt;=c since the above instruction  did not 
                         #                           branch to L1. Therefore, if this condition (i.e. c &gt; d) is not 
                         #                           true as well, than skip the execution of the if-statement.  
L1:  
  addi   $s4, $0, 1      # e = 1
next: 
  . . .
</code></pre>

<h1 id="a-step-by-step-from-c-to-mips">A step-by-step from C to MIPS</h1>

<p>In order to better understand the ideas and rules discussed above, we will walk through the translation of a C text code to a MIPS program. The example below in C language prints the nth Fibonacci number.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">9</span><span class="p">;</span>

<span class="c1">// Function to find the nth Fibonacci number</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">curr_fib</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">next_fib</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">new_fib</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">new_fib</span> <span class="o">=</span> <span class="n">curr_fib</span> <span class="o">+</span> <span class="n">next_fib</span><span class="p">;</span>
        <span class="n">curr_fib</span> <span class="o">=</span> <span class="n">next_fib</span><span class="p">;</span>
        <span class="n">next_fib</span> <span class="o">=</span> <span class="n">new_fib</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">curr_fib</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>We are going to translate this program step by step. First, we need to rewrite the C source code into an “<a href="/l2ado/docs/en/non_structured_programming"> unstructured </a>”  program.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">9</span><span class="p">;</span>

<span class="c1">// Function to find the nth Fibonacci number</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">curr_fib</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">next_fib</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">new_fib</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>

<span class="nl">WHILE:</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">goto</span> <span class="n">ELIHW</span><span class="p">;</span>
    <span class="n">new_fib</span>  <span class="o">=</span> <span class="n">curr_fib</span> <span class="o">+</span> <span class="n">next_fib</span><span class="p">;</span>
    <span class="n">curr_fib</span> <span class="o">=</span> <span class="n">next_fib</span><span class="p">;</span>
    <span class="n">next_fib</span> <span class="o">=</span> <span class="n">new_fib</span><span class="p">;</span>
    <span class="n">i</span><span class="o">--</span><span class="p">;</span>
    <span class="k">goto</span> <span class="n">WHILE</span><span class="p">;</span>

<span class="nl">ELIHW:</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">curr_fib</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Next, we need to define the global variable <code class="language-plaintext highlighter-rouge">n</code>. In MIPS, global variables are declared under the <code class="language-plaintext highlighter-rouge">.data</code> directive which represents the data segment. the declaration under MIPS looks like this:</p>

<pre><code class="language-mips">.data
n: .word 9
</code></pre>

<ul>
  <li>The label <code class="language-plaintext highlighter-rouge">n</code> is chosen to mimic the <em>variable name</em> in C. We could choose any other name for the label as long as we keep track of the association between the variable name in C and the defined label in MIPS.</li>
  <li><code class="language-plaintext highlighter-rouge">.word</code> allocates a 32-bit space pointed to by the label we just defined (i.e. n),</li>
  <li><code class="language-plaintext highlighter-rouge">9</code> is the value stored in the allocated space (this is the value assigned to the variable <code class="language-plaintext highlighter-rouge">n</code> in C).</li>
</ul>

<p>Now, we need to declare and initialise <code class="language-plaintext highlighter-rouge">curr_fib</code> and <code class="language-plaintext highlighter-rouge">next_fib</code>. Since these are local variables in our C code, we will simply associate some registers to them. By convention, registers <code class="language-plaintext highlighter-rouge">$s0</code> – <code class="language-plaintext highlighter-rouge">$s7</code> are used for local variables in MIPS.</p>

<pre><code class="language-mips">.text
main:
    add  $s0, $0, $0    # curr_fib = 0
    addi $s1, $0,  1    # next_fib = 1
</code></pre>
<ul>
  <li>We added the <code class="language-plaintext highlighter-rouge">.text</code> directive here. Any instruction under this directive belongs to the <em>executable code</em>.</li>
  <li>Recall that register $0 is immutable. It always contains the value 0.</li>
  <li>The local variable <code class="language-plaintext highlighter-rouge">new_fib</code> is not declared (we try not to declare variables in assembly when we can associate registers to them. Can you tell why?).</li>
</ul>

<p>Let’s move on to the loop and start by initialising the iteration variable. The following code sets <code class="language-plaintext highlighter-rouge">i</code> to the value of <code class="language-plaintext highlighter-rouge">n</code>.</p>

<pre><code class="language-mips">    la $t0, n           # load in $t0 the address n (remember, n is a label, hence an address!)
    lw $t0, 0($t0)      # load in $t0 the value stored at the address defined by the label n. $t0 is now our variable i.
</code></pre>

<p>The <code class="language-plaintext highlighter-rouge">la</code> instruction loads the address associated with the label (here, <code class="language-plaintext highlighter-rouge">n</code>) into a register (here, <code class="language-plaintext highlighter-rouge">$t0</code>). The first line basically defines <code class="language-plaintext highlighter-rouge">$t0</code> to be a pointer to <code class="language-plaintext highlighter-rouge">n</code>. the second line uses <code class="language-plaintext highlighter-rouge">lw</code> to dereference <code class="language-plaintext highlighter-rouge">$t0</code> and sets this register to the value stored in <code class="language-plaintext highlighter-rouge">n</code>.</p>

<p>In C language, the MIPS instructions above look like this</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="n">t0</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">n</span><span class="p">;</span>    <span class="c1">// you may get errors and warnings when compiling this in C, but</span>
 <span class="n">t0</span> <span class="o">=</span> <span class="o">*</span><span class="n">t0</span><span class="p">;</span>   <span class="c1">// can be fixed with the right type casting and some parenthesis</span>
</code></pre></div></div>

<p>You’re probably thinking: “Why can’t we directly set <code class="language-plaintext highlighter-rouge">$t0</code> to <code class="language-plaintext highlighter-rouge">n</code>?” In the <code class="language-plaintext highlighter-rouge">.text</code> section of the code, there is no way to directly access <code class="language-plaintext highlighter-rouge">n</code> which is in the <code class="language-plaintext highlighter-rouge">.data</code> section (We cannot write <code class="language-plaintext highlighter-rouge">add $t0, n, $0 </code> because the arguments of the <code class="language-plaintext highlighter-rouge">add</code> instruction <strong>must be registers</strong> and <code class="language-plaintext highlighter-rouge">n</code> <strong>IS NOT</strong> a register). The only way to access <code class="language-plaintext highlighter-rouge">n</code> is to get its address with the <code class="language-plaintext highlighter-rouge">la</code> instruction. Once the address of <code class="language-plaintext highlighter-rouge">n</code> is known, we can get its content (with <code class="language-plaintext highlighter-rouge">lw</code> since <code class="language-plaintext highlighter-rouge">n</code> is a 32-bit value). Recall that <code class="language-plaintext highlighter-rouge">lw</code> assigns to register <code class="language-plaintext highlighter-rouge">rt</code> (<code class="language-plaintext highlighter-rouge">$t0</code>, in our case) the data content stored at memory address <code class="language-plaintext highlighter-rouge">Imm + rs</code> (i.e. <code class="language-plaintext highlighter-rouge">rt = MEM[Imm + rs]</code>).</p>

<p>Let’s move on to the loop and begin by implementing the code for the iteration:</p>

<pre><code class="language-mips">WHILE:
    beq $t0, $0, ELIHW  # exit the loop once we have completed n iterations
    ...
    ...
    addi $t0, $t0, -1   # decrement the loop counter
    j WHILE             # loop again (jump to WHILE label)
ELIHW:
</code></pre>

<ul>
  <li>
    <p>The first line (<code class="language-plaintext highlighter-rouge">WHILE:</code>) is a label that marks the start of the loop.</p>
  </li>
  <li>
    <p>The following line (<code class="language-plaintext highlighter-rouge">beq $t0, $0, ELIHW</code>) implements the exit condition. Here, the code branches to label <code class="language-plaintext highlighter-rouge">ELIHW</code> once <code class="language-plaintext highlighter-rouge">$t0</code> reaches the value <code class="language-plaintext highlighter-rouge">0</code> (remember that we set <code class="language-plaintext highlighter-rouge">$t0</code> to represent the variable <code class="language-plaintext highlighter-rouge">i</code>) .</p>
  </li>
  <li>
    <p>At the end of the loop body, the line (<code class="language-plaintext highlighter-rouge">addi $t0, $t0, -1</code>) decrements the variable <code class="language-plaintext highlighter-rouge">i</code>.</p>
  </li>
  <li>
    <p>The next statement (<code class="language-plaintext highlighter-rouge">j WHILE</code>) returns to the beginning of the loop.</p>
  </li>
</ul>

<p>Now, to the body of the loop…</p>

<pre><code class="language-mips">WHILE:
    beq $t0, $0, ELIHW  # exit the loop once we have completed n iterations
     
    add $t2, $s0, $s1   # new_fib  = curr_fib + next_fib;
    add $s0, $s1, $0    # curr_fib = next_fib;
    add $s1, $t2, $0    # next_fib = new_fib;
     
    addi $t0, $t0, -1   # decrement the loop counter
    j WHILE             # loop again (jump to WHILE label)
ELIHW:
</code></pre>

<p>Nothing special here, the corresponding C lines are indicated in the comments.</p>

<p>Let’s move on to displaying the nth Fibonacci number! Recall that displaying data on the console (i.e. <code class="language-plaintext highlighter-rouge">printf("...");</code> and the like) are system calls managed by the operating system! Therefore, we will use the special “<code class="language-plaintext highlighter-rouge">syscall</code>” instruction. And since we want to print an integer (i.e. the value of <code class="language-plaintext highlighter-rouge">curr_fib</code> stored in <code class="language-plaintext highlighter-rouge">$s0</code>), we need to set <code class="language-plaintext highlighter-rouge">$v0</code> to <code class="language-plaintext highlighter-rouge">1</code> and copy the integer value into <code class="language-plaintext highlighter-rouge">$a0</code>.</p>

<pre><code class="language-mips">ELIHW:
    addi $v0,  $0, 1    # $v0 = service number for 'print an integer' 
    addi $a0, $s0, 0    # $a0 = the value to print (i.e. curr_fib) 
    syscall             # system call for printing curr_fib
</code></pre>

<!--
In C, we are used to call functions like "`printf("%d\n", curr_fib);`". In MIPS we cannot call functions (nor pass arguments to them) this way. To pass arguments to a function, we must place them in the argument registers (i.e. `$a0`-`$a3`). When the function is called, it will retrieve any needed arguments from these registers. The first argument must be placed in `$a0`, the second in `$a1`, and so on. See [this link](/l2ado/static_files/docs/MIPS_Calling_Convention.html) for more details on calling functions in MIPS.
-->

<p>Finally, let’s terminate and exit our program! This also requires a <code class="language-plaintext highlighter-rouge">syscall</code>!</p>

<pre><code class="language-mips">    addi $v0, $0, 10    # service number for 'exit'
    syscall             # system call to terminate the execution of the program
</code></pre>

<p>And voila! Here is our complete program!</p>

<pre><code class="language-mips">.data
n: .word 9

.text
main:
    add  $s0, $0, $0    # curr_fib = 0
    addi $s1, $0,  1    # next_fib = 1

    la $t0, n           # load in $t0 the address n (remember, n is a label, hence an address!)
    lw $t0, 0($t0)      # load in $t0 the value stored at the address defined by the label n. $t0 is now our variable i.

WHILE:
    beq $t0, $0, ELIHW  # exit the loop once we have completed n iterations
     
    add $t2, $s0, $s1   # new_fib  = curr_fib + next_fib;
    add $s0, $s1, $0    # curr_fib = next_fib;
    add $s1, $t2, $0    # next_fib = new_fib;
     
    addi $t0, $t0, -1   # decrement the loop counter
    j WHILE             # loop again (jump to WHILE label)

ELIHW:
    addi $v0,  $0, 1    # $v0 = service number for 'print an integer' 
    addi $a0, $s0, 0    # $a0 = the value to print (i.e. curr_fib) 
    syscall             # system call for printing curr_fib

    addi $v0, $0, 10    # service number for 'exit'
    syscall             # system call to terminate the execution of the program
</code></pre>


  </article>

</div>

      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <!--     <h2 class="footer-heading"></h2> -->
    <div class="footer-col-wrapper">
      <div class="footer-col  footer-col-1">

        <p class="text">
          02 rue Didouche Mourad<br />
16000 Alger<br />
 
        </p>
      </div>

      <div class="footer-col  footer-col-2">
        <ul class="social-media-list">


          

          

          

          

          
          




        </ul>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
