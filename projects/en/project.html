<!DOCTYPE html>
<html>

  <head>
  
    <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-5KMKZK4Z38"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-5KMKZK4Z38');
  </script>
  

  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title> MIPS mini-Processor - Computer Design / Fall 2024 </title>
  <meta name="description" content="IntroductionIn this project, you will implement a basic version of a MIPS processor. The assignment is organized into two parts: A and B.In part A (tasks 1 t...">
  
  <!--for gitlab pages -->
  

  <!-- automatic favicons -->
  

    <!--for github pages -->
  <link rel="shortcut icon" href="https://benhadid.github.io/l2ado/favicon.ico?"> 
  <!--for github-->

  <link rel="stylesheet" href="/l2ado/_css/main.css">
  <link rel="canonical" href="https://benhadid.github.io/l2ado/projects/en/project">
  <link rel="alternate" type="application/rss+xml" title="Computer Design / Fall 2024 - " href="https://benhadid.github.io/l2ado/feed.xml" />

  <link rel='stylesheet' id='open-sans-css'  href='//fonts.googleapis.com/css?family=Open+Sans%3A300italic%2C400italic%2C600italic%2C300%2C400%2C600&#038;subset=latin%2Clatin-ext&#038;ver=4.2.4' type='text/css' media='all' />
  <link href='https://fonts.googleapis.com/css?family=Titillium+Web:600italic,600,400,400italic' rel='stylesheet' type='text/css'>

  

  

  <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.2.0/css/all.css" integrity="sha384-hWVjflwFxL6sNzntih27bfxkr27PmbbK/iSvJ+a4+0owXq79v+lsFkW54bOGbiDQ" crossorigin="anonymous">

  <!-- MathJax -->
  <script type="text/javascript" async
    src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML">
  </script>
</head>


  <body>

    <header class="site-header">

  <div class="wrapper" style="z-index: 100;">
      <table><tr>
          <td><img width="75" src="/l2ado/_images/logo.png" valign="middle"></td>
          <td style="padding-left:10px;"><a class="schoolname" style="font-size: 15px;" class="site-title" href=""></a>
          <br/>      
          <span style="margin-top: -2px;margin-bottom: -10px;" class="site-title"><a href="/l2ado/" title="Computer Design / Fall 2024 - "><b>Computer Design</a></b></span>
          <br/>
          <span class="coursesemeter" style="font-size: 12px;font-weight: bold;margin-top: 10px;display: block;">Fall 2024</span>
          </td>
        </tr></table>

    <nav class="site-nav">

      <a href="#" class="menu-icon menu.open">
        <svg viewBox="0 0 18 15">
          <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
          <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
          <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
        </svg>
      </a>  

    <div class="trigger"><h1>Main Navigation</h1> <ul class="menu">
    
    <li>

      
      

      <a class="page-link" href="/l2ado/">
        <i class="fa fa-home fa-lg"></i> Home
      </a>

    </li>
    
    <li>

      
      

      <a class="page-link" href="/l2ado/schedule/">
        <i class="fas fa-calendar-alt"></i> Schedule
      </a>

    </li>
    
    <li>

      
      

      <a class="page-link" href="/l2ado/lectures/">
        <i class="fas fa-book-reader"></i> Lectures
      </a>

    </li>
    
    <li>

      
      

      <a class="page-link" href="/l2ado/discussions/">
        <i class="fas fa-user-graduate"></i> Seminars
      </a>

    </li>
    
    <li>

      
      

      <a class="page-link" href="/l2ado/labs/">
        <i class="fas fa-laptop-code"></i> Labs
      </a>

    </li>
    
    <li>

      
      

      <a class="page-link" href="/l2ado/quizzes/">
        <i class="fas fa-question-circle"></i> Quizzes
      </a>

    </li>
    
    <li>

      
      

      <a class="page-link" href="/l2ado/projects/">
        <i class="fas fa-user-graduate"></i> Projects
      </a>

    </li>
    
    <li>

      
      

      <a class="page-link" href="/l2ado/materials/">
        <i class="fas fa-book"></i> Resources
      </a>

    </li>
    
</ul>
 </div>  
    
    </nav>
  </div>

  <div></div>

  <div class="header-texture" style="height:100%; z-index: 0; position: absolute; top:0; right: 0; left: 0; background-image: url( /l2ado/_images/pattern.png );" >
  </div>

</header>


    <div class="page-content">
      <div class="wrapper">
        <div class="post">

  <header class="post-header">
    <h1 class="post-title">MIPS mini-Processor</h1>
    <p class="post-meta">Published on  
      <!--
      Sunday 
      01/12/2024
      -->
      
      Sunday
      1
      
      December
      2024 
    </p>
  </header>

  <div>
    
    <span style="font-weight: bold"> Due on  
      <!-- 26/12/2024 -->

      
      Thursday
      26
      
      December
      2024
  
    </span>
    

    
    <p style="font-weight: bold">Download

      

      
      [<a href="/l2ado/static_files/projects/mipscpu.zip">starter</a>]
      

      

    </p>
    

  </div>

  <br />
  <article class="post-content">
    <h1 id="introduction">Introduction</h1>

<p>In this project, you will implement a basic version of a MIPS processor. The assignment is organized into two parts: A and B.</p>

<p>In part A (tasks 1 to 3), you are required to build an “Arithmetic Logic Unit (ALU)” and a “Register File” for a basic MIPS processor, as well as an implementation of a single-cycle datapath for executing <code class="language-plaintext highlighter-rouge">addi</code> instructions. In Part B (Task 4), you need to add other circuit components to your basic processor to produce an advanced version that will execute “real” MIPS instructions!</p>

<p>Start by downloading the startup file and unzipping its contents to the directory of your choice. Here is the list of files you must have:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>proj_starter
  ├── cpu
  │   ├── alu.circ
  │   ├── branch_comp.circ
  │   ├── control_logic.circ
  │   ├── cpu_pipelined.circ
  │   ├── cpu_single.circ
  │   ├── imm_gen.circ
  │   ├── mem.circ
  │   └── regfile.circ
  ├── harnesses
  │   ├── alu_harness.circ
  │   ├── regfile_harness.circ
  │   ├── run_pipelined.circ
  │   ├── run_single.circ
  │   ├── test_pipelined_harness.circ
  │   └── test_single_harness.circ
  ├── logisim-evolution.jar
  ├── tests
  │   ├── part_a
  │   │   ├── ...
  ╎   ╎   ╎
  │   │   └── ...
  │   └── part_b
  │       ├── ...
  ╎       ╎
  │       └── ...
  └── test_runner.py
</code></pre></div></div>

<div class="bs-callout bs-callout-danger">
 <b>NOTE</b>: Only files: <b>alu.circ</b>,  <b>branch_comp.circ</b>, <b>control_logic.circ</b>, <b>cpu_single.circ</b>, <b>cpu_pipelined.circ</b>, <b>imm_gen.circ</b> and <b>regfile.circ</b> should be modified and submitted for evaluation. The <b>mem.circ</b> circuit is already implemented for you.
</div>

<h1 id="part-a-initial-cpu-draft">Part A: Initial CPU draft</h1>

<h2 id="task-1-arithmetic-and-logic-unit-alu">Task 1: Arithmetic and Logic Unit (ALU)</h2>

<p>Your first task is to create an “Arithmetic and Logic Unit (ALU)” that supports all the operations required by our ISA instructions (see next section).</p>

<p>The provided skeleton file <code class="language-plaintext highlighter-rouge">alu.circ</code> shows that your ALU should have three inputs:</p>

<table class="styled-table">
<colgroup>
<col width="10%" />
<col width="10%" />
<col width="80%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align:center">Input name</th>
<th style="text-align:center">Width in bits</th>
<th style="text-align:center">Description</th>
</tr>
</thead>
<tbody>

<tr>
<td style="text-align:center"><strong>A</strong></td>
<td style="text-align:center">32</td>
<td>Data on input A for ALU operation</td>
</tr>

<tr>
<td style="text-align:center"><strong>B</strong></td>
<td style="text-align:center">32</td>
<td>Data on input B for ALU operation</td>
</tr>

<tr>
<td style="text-align:center"><strong>ALUSel</strong></td>
<td style="text-align:center">4</td>
<td>Selects which operation the ALU should perform (see below for list of operations with corresponding switch values).</td>
</tr>
</tbody>
</table>

<p>… and two outputs</p>

<table class="styled-table">
<colgroup>
<col width="10%" />
<col width="10%" />
<col width="80%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align:center">Output name</th>
<th style="text-align:center">Width in bits</th>
<th style="text-align:center">Description</th>
</tr>
</thead>
<tbody>

<tr>
<td style="text-align:center"><strong>Zero</strong></td>
<td style="text-align:center">1</td>
<td>This output is set when the difference between inputs <strong>A</strong> and <strong>B</strong> is zero</td>
</tr>

<tr>
<td style="text-align:center"><strong>Result</strong></td>
<td style="text-align:center">32</td>
<td>ALU operation result</td>
</tr>
</tbody>
</table>

<p><strong>NOTES</strong>: In the « <a href="https://adminunivalger-my.sharepoint.com/:p:/g/personal/a_benhadid_univ-alger_dz/Ec9qgFqCw19Cklw28Wz2IUwBNHpbcR6KWH64mnbx533juQ?e=nQI2Mr">RAM and CPU</a> » lecture slides, it is shown that and in order to build a multi-bit ALU (8 bits is given as an example), one needs to duplicate a 1-bit circuit and “link” these copies together to get an <em>n-bit</em> ALU. Good news! you don’t have to do that in this assignment… Logisim already does that for you! Simply choose the right bit width for your components’ inputs/outputs and your are done (see figure below).</p>

<p><img src="/l2ado/static_files/images/data_width.png" alt="data width" height="55%" width="55%" class="wp-caption aligncenter" /></p>

<p>The list below shows the operations (and the associated <strong>ALUSel</strong> values) that your ALU must be able to perform. You can use any Logisim block or integrated function to implement your circuits (<strong>There is no need to reimplement the adder, shifter or multiplier circuits! Use the circuit blocks provided by Logisim for this purpose</strong>).</p>

<table class="styled-table">
<colgroup>
<col width="10%" />
<col width="15%" />
<col width="30%" />
<col width="45%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align:center">ALUSel</th>
<th style="text-align:center">Instruction</th>
<th style="text-align:center">Description</th>
<th style="text-align:center">Note</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:left">  add</td>
<td> <code class="language-plaintext highlighter-rouge">Result = A + B</code></td>
<td></td>
</tr>

<tr>
<td style="text-align:center">1</td>
<td style="text-align:left">  and</td>
<td> <code class="language-plaintext highlighter-rouge">Result = A &amp; B</code></td>
<td></td>
</tr>

<tr>
<td style="text-align:center">2</td>
<td style="text-align:left">  or</td>
<td> <code class="language-plaintext highlighter-rouge">Result = A | B</code></td>
<td></td>
</tr>

<tr>
<td style="text-align:center">3</td>
<td style="text-align:left">  xor</td>
<td> <code class="language-plaintext highlighter-rouge">Result = A ^ B</code></td>
<td></td>
</tr>

<tr>
<td style="text-align:center">4</td>
<td style="text-align:left">  srl</td>
<td> <code class="language-plaintext highlighter-rouge">Result = A &gt;&gt; B</code></td>
<td>Unsigned right shift</td>
</tr>

<tr>
<td style="text-align:center">5</td>
<td style="text-align:left">  sra</td>
<td> <code class="language-plaintext highlighter-rouge">Result = A &gt;&gt; B</code></td>
<td>Signed right shift</td>
</tr>

<tr>
<td style="text-align:center">6</td>
<td style="text-align:left">  sll</td>
<td> <code class="language-plaintext highlighter-rouge">Result = A &lt;&lt; B</code></td>
<td></td>
</tr>

<tr>
<td style="text-align:center">7</td>
<td style="text-align:left">  —</td>
<td>    —</td>
<td>Not used</td>
</tr>

<tr>
<td style="text-align:center">8</td>
<td style="text-align:left">  slt</td>
<td> <code class="language-plaintext highlighter-rouge">Result = A &lt; B ? 1 : 0</code></td>
<td>Signed comparison</td>
</tr>

<tr>
<td style="text-align:center">9</td>
<td style="text-align:left">  sltu</td>
<td> <code class="language-plaintext highlighter-rouge">Result = A &lt; B ? 1 : 0</code></td>
<td>Unsigned comparison</td>
</tr>

<tr>
<td style="text-align:center">10</td>
<td style="text-align:left">  mul</td>
<td> <code class="language-plaintext highlighter-rouge">Result = (A * B)[31:0]</code></td>
<td>Signed mult (31..0)</td>
</tr>

<tr>
<td style="text-align:center">11</td>
<td style="text-align:left">  mulhu</td>
<td> <code class="language-plaintext highlighter-rouge">Result = (A * B)[63:32]</code></td>
<td>Unsigned mult</td>
</tr>

<tr>
<td style="text-align:center">12</td>
<td style="text-align:left">  sub</td>
<td> <code class="language-plaintext highlighter-rouge">Result = A - B</code></td>
<td></td>
</tr>

<tr>
<td style="text-align:center">13</td>
<td style="text-align:left">  —</td>
<td>    —</td>
<td>Not used</td>
</tr>

<tr>
<td style="text-align:center">14</td>
<td style="text-align:left">  mulh</td>
<td> <code class="language-plaintext highlighter-rouge">Result = (A * B)[63:32]</code></td>
<td>Signed mult (63..32)</td>
</tr>
</tbody>
</table>

<p><strong>Hints</strong> :</p>

<ul>
  <li>
    <p>The MIPS <code class="language-plaintext highlighter-rouge">add</code> operation is already implemented for you; feel free to use a similar structure to build the other functions.</p>
  </li>
  <li>
    <p>When implementing <code class="language-plaintext highlighter-rouge">mul</code> and <code class="language-plaintext highlighter-rouge">mulh</code>, note that the multiplication circuit block in Logisim has a “Carry Out” output that might be useful (the adder block also has this output, but you won’t needed it for this project).</p>
  </li>
  <li>
    <p>“Splitters” and “Bit extenders” could be very useful when implementing shift operations.</p>
  </li>
  <li>
    <p>Use tunnels extensively for the wirings! This will help you avoid crossing wires inadvertently (and causing unexpected errors).</p>
  </li>
  <li>
    <p>A multiplexer (MUX) can be useful in deciding which output of which component you want to transmit. I.e. process the inputs in all components simultaneously, then, depending on the chosen operation, select the correct output to transmit.</p>
  </li>
</ul>

<div class="bs-callout bs-callout-danger">
  <h4>CAUTION</h4>

  <p>You can make any changes you see fit to <b>alu.circ</b>, but the circuit's inputs and outputs must obey the behavior specified above. Additionally, your <b>alu.circ</b> must fit into the provided harness circuit <b>alu_harness.circ</b>. This means you should <b>AVOID</b> moving the inputs or outputs of the <b>alu.circ</b> circuit. If you need more space, use tunnels!</p>

  <p>If you create additional subcircuits, they must also be in <b>alu.circ</b> (i.e. you should not create new ".circ" files).</p>

  <p>To check that your modifications to <b>alu.circ</b> have not broken the input/output correspondences between your circuit and the harness, open the <b>alu_harness.circ</b> file in Logisim and make sure that there are no errors (i.e. no red or orange wires).</p>
</div>

<h3 id="testing-your-alu"><strong>Testing your ALU</strong></h3>

<p>A set of consistency tests for your ALU is provided in the <code class="language-plaintext highlighter-rouge">tests/part_a/alu</code> folder. Running the <code class="language-plaintext highlighter-rouge">test_runner.py</code> script (see below) will run the ALU tests and output the results to the <code class="language-plaintext highlighter-rouge">tests/part_a/alu/student_output</code> folder.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>python3 test_runner.py part_a alu
</code></pre></div></div>

<p>Also provided is a <code class="language-plaintext highlighter-rouge">binary_to_hex_alu.py</code> script that helps to convert the outputs of the ALU into a readable format. To use the script, type the following in the console:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">cd </span>tests/part_a/alu
<span class="nv">$ </span>python3 binary_to_hex_alu.py PATH_TO_OUTPUT_FILE
</code></pre></div></div>

<p>For example, to view the content of the reference output file <code class="language-plaintext highlighter-rouge">reference_output/alu-add-ref.out</code>, do the following:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">cd </span>tests/part_a/alu
<span class="nv">$ </span>python3 binary_to_hex_alu.py reference_output/alu-add-ref.out
</code></pre></div></div>

<p>To see the difference between your circuit output and the reference solution, put the readable outputs into new <code class="language-plaintext highlighter-rouge">.out</code> files and compare them with the <code class="language-plaintext highlighter-rouge">diff</code> command (cf. <code class="language-plaintext highlighter-rouge">man diff</code> in a console). For example, for the <code class="language-plaintext highlighter-rouge">alu-add</code> test, you can do:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">cd </span>tests/part_a/alu
<span class="nv">$ </span>python3 binary_to_hex_alu.py reference_output/alu-add-ref.out <span class="o">&gt;</span> reference.out
<span class="nv">$ </span>python3 binary_to_hex_alu.py student_output/alu-add-student.out <span class="o">&gt;</span> student.out
<span class="nv">$ </span>diff reference.out student.out
</code></pre></div></div>

<h2 id="task-2-registers-file">Task 2: <strong>Registers File</strong></h2>

<p>In this task, you will implement the <strong>$0 – $31</strong>  registers specified in the MIPS architecture. To ease the implementation, eight registers will be ‘exposed’ for testing and debugging purposes (see the list below). Please ensure that the values ​​of these registers are attached to the appropriate outputs in <code class="language-plaintext highlighter-rouge">regfile.circ</code>.</p>

<p>Your “<strong>Registers File</strong>” should be able to read from or write to the registers specified in a MIPS instruction without affecting other registers. There is one notable exception: your “<strong>Registers File</strong>” should <strong>NOT</strong> write to the <code class="language-plaintext highlighter-rouge">$0</code> register even if an instruction attempts to do so. As a reminder, register <code class="language-plaintext highlighter-rouge">$zero</code> should <strong>ALWAYS</strong> be set to <code class="language-plaintext highlighter-rouge">0</code>.</p>

<p>The ‘exposed’ registers and their corresponding numbers are indicated below.</p>

<table class="styled-table">
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align:center">Register's number</th>
<th style="text-align:center">Register's name</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:center">$a0</td>
</tr>
<tr>
<td style="text-align:center">8</td>
<td style="text-align:center">$t0</td>
</tr>
<tr>
<td style="text-align:center">9</td>
<td style="text-align:center">$t1</td>
</tr>
<tr>
<td style="text-align:center">10</td>
<td style="text-align:center">$t2</td>
</tr>
<tr>
<td style="text-align:center">16</td>
<td style="text-align:center">$s0</td>
</tr>
<tr>
<td style="text-align:center">17</td>
<td style="text-align:center">$s1</td>
</tr>
<tr>
<td style="text-align:center">29</td>
<td style="text-align:center">$sp</td>
</tr>
<tr>
<td style="text-align:center">31</td>
<td style="text-align:center">$ra</td>
</tr>
</tbody>
</table>

<p><br />
A skeleton circuit of the “<strong>Registers File</strong>” is provided in <code class="language-plaintext highlighter-rouge">regfile.circ</code>. The circuit has six inputs:</p>

<table class="styled-table">
<colgroup>
<col width="20%" />
<col width="15%" />
<col width="65%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align:center">Input's name</th>
<th style="text-align:center">Width (in bits)</th>
<th style="text-align:center">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"> <strong>Clock</strong></td>
<td style="text-align:center">1</td>
<td>Input providing the clock. This signal can be routed to other subcircuits or directly connected to the clock inputs of the memory units in Logisim, but must not be connected to logic gates in any way (i.e. do not invert it, do not AND it, etc.)
</td>
</tr>

<tr>
<td style="text-align:left"> <strong>RegWEn</strong></td>
<td style="text-align:center">1</td>
<td>Enables data writing on the next rising edge of the clock</td>
</tr>

<tr>
<td style="text-align:left"> <strong>rs</strong></td>
<td style="text-align:center">5</td>
<td>Selects which register value is sent to output <strong>Read_Data_1</strong> (see below)</td>
</tr>

<tr>
<td style="text-align:left"> <strong>rt</strong></td>
<td style="text-align:center">5</td>
<td>Selects which register value is sent to output <strong>Read_Data_2</strong> (see below)</td>
</tr>

<tr>
<td style="text-align:left"> <strong>rd</strong></td>
<td style="text-align:center">5</td>
<td>Selects which register will be updated with the content from <strong>Write_Data</strong> on the next rising edge of the clock (provided that <strong>RegWEn</strong> is <strong>1</strong>)</td>
</tr>

<tr>
<td style="text-align:left"> <strong>Write_Data</strong></td>
<td style="text-align:center">32</td>
<td>Data to be written to the register selected by <strong>rd</strong> on the next rising edge of the clock (provided that <strong>RegWEn</strong> is <strong>1</strong>)</td>
</tr>
</tbody>
</table>

<p><br />
The “<strong>Registers File</strong>” in <code class="language-plaintext highlighter-rouge">regfile.circ</code> also has the following outputs:</p>

<table class="styled-table">
<colgroup>
<col width="20%" />
<col width="15%" />
<col width="65%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align:center">Output's name</th>
<th style="text-align:center">Width (in bits)</th>
<th style="text-align:center">Description</th>
</tr>
</thead>

<tbody>

<tr>
<td style="text-align:left"> <strong>Read_Data_1</strong></td>
<td style="text-align:center">32</td>
<td>Returns the content of register <strong>rs</strong></td>
</tr>

<tr>
<td style="text-align:left"> <strong>Read_Data_2</strong></td>
<td style="text-align:center">32</td>
<td>Returns the content of register <strong>rt</strong></td>
</tr>

<tr>
<td style="text-align:left"> Value <strong>ra</strong></td>
<td style="text-align:center">32</td>
<td>Returns the content of register <strong>ra</strong> (output used for debugging and testing)</td>
</tr>

<tr>
<td style="text-align:left"> Value <strong>sp</strong></td>
<td style="text-align:center">32</td>
<td>Returns the content of register <strong>$sp</strong> (output used for debugging and testing)</td>
</tr>

<tr>
<td style="text-align:left"> Value <strong>t0</strong></td>
<td style="text-align:center">32</td>
<td>Returns the content of register <strong>$t0</strong> (output used for debugging and testing)</td>
</tr>

<tr>
<td style="text-align:left"> Value <strong>t1</strong></td>
<td style="text-align:center">32</td>
<td>Returns the content of register <strong>$t1</strong> (output used for debugging and testing)</td>
</tr>

<tr>
<td style="text-align:left"> Value <strong>t2</strong></td>
<td style="text-align:center">32</td>
<td>Returns the content of register <strong>$t2</strong> (output used for debugging and testing)</td>
</tr>

<tr>
<td style="text-align:left"> Value <strong>s0</strong></td>
<td style="text-align:center">32</td>
<td>Returns the content of register <strong>$s0</strong> (output used for debugging and testing)</td>
</tr>

<tr>
<td style="text-align:left"> Value <strong>s1</strong></td>
<td style="text-align:center">32</td>
<td>Returns the content of register <strong>$s1</strong> (output used for debugging and testing)</td>
</tr>

<tr>
<td style="text-align:left"> Value <strong>a0</strong></td>
<td style="text-align:center">32</td>
<td>Returns the content of register <strong>$a0</strong> (output used for debugging and testing)</td>
</tr>
</tbody>
</table>

<p>The test outputs at the top of the circuit in <code class="language-plaintext highlighter-rouge">regfile.circ</code> are there for testing and debugging purposes. A real “Registers file” does not have these outputs! Make sure they are properly connected to the indicated registers because if they are not, the autograder will not be able to evaluate your assignment correctly.</p>

<p><strong>Hints</strong> :</p>

<ul>
  <li>
    <p>To avoid repetitive (and boring) work, start by creating a fully functional register and then use it as a template to build the others.</p>
  </li>
  <li>
    <p>It is recommended not to use the “<code class="language-plaintext highlighter-rouge">enable</code>” input on your MUXes. In fact, you can even disable this feature from the Logisim panel. It is also recommended to set the “three-state?” property to “<code class="language-plaintext highlighter-rouge">off</code>”.</p>
  </li>
  <li>
    <p>See step 4 of “Design example 2” in the “<a href="/l2ado/docs/en/Logisim_tutoriel">Logisim tutorial</a>” document to see what each input/output of a Logisim register corresponds to.</p>
  </li>
  <li>
    <p>As with the ALU task, multiplexers will be very useful (demultiplexers, too).</p>
  </li>
  <li>
    <p>What happens in the “<strong>Registers File</strong>” after a machine instruction is executed. Which values change? Which values stay the same? Registers are triggered by a clock - what does this mean?</p>
  </li>
  <li>
    <p>As a reminder, registers have an “<code class="language-plaintext highlighter-rouge">enable</code>” input as well as a “<code class="language-plaintext highlighter-rouge">clock</code>” input.</p>
  </li>
  <li>
    <p>What is the value of register <code class="language-plaintext highlighter-rouge">$0</code>?</p>
  </li>
</ul>

<div class="bs-callout bs-callout-danger">
  <h4>CAUTION</h4>

  <p>You can make any changes you want to <b>regfile.circ</b>, but the inputs and outputs of the circuit must follow the specifications given above. In addition, your <b>regfile.circ</b> must fit into the provided harness circuit <b>regfile_harness.circ</b>. This means that you must be careful <b>NOT</b> to move the inputs or outputs of the <b>regfile.circ</b> circuit. If you need more space, use tunnels!</p>
  
  <p>If you create additional subcircuits, they must also be in <b>regfile.circ</b> (i.e. do not create new .circ files).</p>

  <p>To verify that your changes have not broken the input/output mappings between your circuit and the harness, open the <b>regfile_harness.circ</b> file and make sure there are no wiring errors.</p>

</div>

<h3 id="testing-your-registers-file"><strong>Testing your “</strong>Registers File<strong>“</strong></h3>

<p>A set of validity tests are provided in the <code class="language-plaintext highlighter-rouge">tests/part_a/regfile</code> folder. Running the tester (see below) will also run the ALU tests and output the results to the <code class="language-plaintext highlighter-rouge">tests/part_a/regfile/student_output</code> folder.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>python3 test_runner.py part_a regfile
</code></pre></div></div>

<p>Also provided is a <code class="language-plaintext highlighter-rouge">binary_to_hex_regfile.py</code> script which works in a similar way to the <code class="language-plaintext highlighter-rouge">binary_to_hex_alu.py</code> script introduced in task #1.</p>

<h2 id="task-3-the-addi-instruction">Task 3: The <code class="language-plaintext highlighter-rouge">addi</code> instruction</h2>

<p>In this third and final task for Part A, you need to implement a Datapath that can execute <code class="language-plaintext highlighter-rouge">addi</code> instructions! You can implement other additional instructions if you wish, but you will only be graded if the <code class="language-plaintext highlighter-rouge">addi</code> instructions execute correctly for this part of the project.</p>

<h3 id="description-of-the-subtasks"><strong>Description of the subtasks</strong></h3>

<h4 id="the-memory-unit-memcirc"><strong>The Memory Unit (<code class="language-plaintext highlighter-rouge">mem.circ</code>)</strong></h4>

<p>The Memory Unit (found in <code class="language-plaintext highlighter-rouge">mem.circ</code>) is already implemented for you! However, the <code class="language-plaintext highlighter-rouge">addi</code> instruction does <strong>NOT</strong> use the Memory Unit, so you can ignore this component for part A.</p>

<h4 id="the-branching-unit-branch_compcirc"><strong>The Branching Unit (<code class="language-plaintext highlighter-rouge">branch_comp.circ</code>)</strong></h4>

<p>The <code class="language-plaintext highlighter-rouge">branch_comp.circ</code> file provides a skeleton circuit for the “Branching Unit”, but since the <code class="language-plaintext highlighter-rouge">addi</code> instruction does <strong>NOT</strong> use this unit, you can ignore it for part A.</p>

<h4 id="the-immediate-unit-imm_gencirc"><strong>The Immediate Unit (<code class="language-plaintext highlighter-rouge">imm_gen.circ</code>)</strong></h4>

<p>The <code class="language-plaintext highlighter-rouge">imm_gen.circ</code> file provides a skeleton circuit for the “Immediate Unit”. The <code class="language-plaintext highlighter-rouge">addi</code> instruction uses this unit. However, since this is the only instruction to be designed in this part of the project, you can simply lay out the wires necessary to generate the immediate associated with an <code class="language-plaintext highlighter-rouge">addi</code> instruction without worrying about other types of immediates. See the image below to see how the immediate of the <code class="language-plaintext highlighter-rouge">addi</code> instruction should be generated:</p>

<p><img src="/l2ado/static_files/images/immediat_addi.png" alt="addi format" height="75%" width="75%" class="aligncenter" /></p>

<div class="bs-callout bs-callout-warning">
  <h4>WARNING</h4>

  <p>To implement the "<i>Immediate Unit</i>", edit the <code>imm_gen.circ</code> file and <b>not</b> the <code>imm_gen</code> virtual circuit included in <code>cpu_*.circ</code>. Note that each time you edit the <code>imm_gen.circ</code> circuit, you must close and open the <code>cpu_*.circ</code> file to apply the changes to your CPU.</p>
</div>

<p>Here is a summary of the unit’s inputs and outputs:</p>

<table class="styled-table">
<colgroup>
<col width="10%" />
<col width="10%" />
<col width="20%" />
<col width="60%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align:center">Name</th>
<th style="text-align:center">Direction</th>
<th style="text-align:center">Width (in bits)</th>
<th style="text-align:center">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">inst</td>
<td style="text-align:center">Input</td>
<td style="text-align:center">32</td>
<td>The instruction currently being executed</td>
</tr>
<tr>
<td style="text-align:center">ImmSel</td>
<td style="text-align:center">Input</td>
<td style="text-align:center">2</td>
<td>A Selector to choose between different immediate generators</td>
</tr>
<tr>
<td style="text-align:center">Imm</td>
<td style="text-align:center">Output</td>
<td style="text-align:center">32</td>
<td>Generated Immediate</td>
</tr>
</tbody>
</table>

<h4 id="the-control-unit-control_logiccirc"><strong>The Control Unit (<code class="language-plaintext highlighter-rouge">control_logic.circ</code>)</strong></h4>

<p>The <code class="language-plaintext highlighter-rouge">control_logic.circ</code> file provides a skeleton circuit for the “Control Unit”. Designing your Control Unit will probably be your biggest challenge in Part B of this assignment. For Part A, since <code class="language-plaintext highlighter-rouge">addi</code> is the only instruction you will implement, you can simply assign a constant for each control signal. However, as you progress through your implementation of <code class="language-plaintext highlighter-rouge">addi</code>, think about where you should make future modifications/additions to support other instructions besides <code class="language-plaintext highlighter-rouge">addi</code>.</p>

<div class="bs-callout bs-callout-warning">
  <h4>WARNING</h4>

  <p>To implement the "<i>Control Unit</i>", edit the <code>control_logic.circ</code> file and <b>not</b> the <code>control_logic</code> virtual circuit included in <code>cpu_*.circ</code>. Note that each time you edit the <code>control_logic.circ</code> circuit, you must close and open the <code>cpu_*.circ</code> file to apply the changes to your CPU.</p>
</div>

<div class="bs-callout bs-callout-danger">
  <h4>CAUTION</h4>

 <p>During the implementation of your "Control Unit", you can add extra input or output ports to <code>control_logic.circ</code>. You can also use the already provided ports (or a subset of them) depending on the needs of your implementation. That said, <b>do not modify or delete</b> any of the existing ports during this process.</p>
</div>

<h4 id="the-processor-cpucirc"><strong>The Processor (<code class="language-plaintext highlighter-rouge">cpu*.circ</code>)</strong></h4>

<p>The starter kit also provides skeletons for your processor in <code class="language-plaintext highlighter-rouge">cpu*.circ</code>. For Part A of the project, your processor must be able to execute the <code class="language-plaintext highlighter-rouge">addi</code> instruction using a two-stage pipeline, with “Instruction Fetch (IF)” in the first stage and ( ID – EX – MEM – WB ) in the second stage. First, using your own implementations of the ALU and “<strong>Registers File</strong>” from task 1 &amp; 2, implement a single-cycle datapath (use the skeleton file <code class="language-plaintext highlighter-rouge">cpu_single.circ</code> for this mode of execution). Once your non-pipelined processor is working properly, you can make a copy of it into <code class="language-plaintext highlighter-rouge">cpu_pipelined.circ</code> and then modify your processor to produce a pipelined version.</p>

<p>Your processor will be inserted into the <code class="language-plaintext highlighter-rouge">test_single_harness.circ</code> harness (or <code class="language-plaintext highlighter-rouge">test_pipelined_harness.circ</code>, as appropriate) that contains the memory unit. This harness is in turn inserted into the <code class="language-plaintext highlighter-rouge">run_single.circ</code> (resp. <code class="language-plaintext highlighter-rouge">run_pipelined.circ</code>) test socket which provides the instructions (i.e. machine code) to the processor.</p>

<p>As an output, your processor will emit the address of an instruction to be read (i.e. fetched) from the instruction memory (IMEM). The fetched instruction is then transmitted to the processor in the appropriate input.</p>

<p>Also as an output, the processor will emit the address of a data to read from DMEM memory and a WRITE_ENABLE signal set to 1 if a store is requested instead. If data is read from DMEM, it is transmitted to the processor in the appropriate input (i.e. READ_DATA).</p>

<p>Essentially, the <code class="language-plaintext highlighter-rouge">test_*_harness.circ</code> and <code class="language-plaintext highlighter-rouge">run_*.circ</code> harnesses simulate a data (DMEM) and instruction (IMEM) memories respectively. Take the time to familiarise yourself with how they work to get an overall idea of the simulator.</p>

<div class="bs-callout bs-callout-danger">
  <h4>CAUTION</h4>

 <p>The <code>test_*_harness.circ</code> harnesses will be used by the consistency tests provided in the starter kit, so make sure that your <code>cpu_*.circ</code> processor fits properly into these sockets before testing your circuits, and especially when submitting your work for grading</p>

 <p>As with the ALU and the "Registers File" tasks, make sure <b>NOT</b> to move the input or output ports!</p>
</div>

<p>The processor has three inputs that come from the harness:</p>

<table class="styled-table">
<colgroup>
<col width="20%" />
<col width="15%" />
<col width="65%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align:center">Input's name</th>
<th style="text-align:center">Width (in bits)</th>
<th style="text-align:center">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">READ_DATA</td>
<td style="text-align:center">32</td>
<td>Data retrieved from DMEM memory at the address given in DMEM_ADDRESS (see below).</td>
</tr>
<tr>
<td style="text-align:center">INSTRUCTION</td>
<td style="text-align:center">32</td>
<td>The instruction fetched from IMEM memory at the address indicated by IMEM_ADDRESS (see below).</td>
</tr>
<tr>
<td style="text-align:center">CLOCK</td>
<td style="text-align:center">1</td>
<td>Input providing the clock. As already mentioned in the “<strong>Registers File</strong>” task, this signal can be routed to other subcircuits or directly connected to the clock inputs of the memory units in Logisim, but must not be connected to logic gates in any way (i.e. do not invert it, do not apply the “AND” gate on it, etc.).</td>
</tr>
</tbody>
</table>

<p><br /></p>

<p>…and provides the following outputs for the harness:</p>

<table class="styled-table">
<colgroup>
<col width="20%" />
<col width="15%" />
<col width="65%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align:center">Output's name</th>
<th style="text-align:center">Width (in bits)</th>
<th style="text-align:center">Description</th>
</tr>
</thead>
<tbody>

<tr>
<td style="text-align:center">ra</td>
<td style="text-align:center">32</td>      
<td>Returns the content of register <strong>ra</strong> (output used for debugging and testing)</td>
</tr>

<tr>
<td style="text-align:center">sp</td>
<td style="text-align:center">32</td>      
<td>Returns the content of register <strong>$sp</strong> (output used for debugging and testing)</td>
</tr>

<tr>
<td style="text-align:center">t0</td>
<td style="text-align:center">32</td>      
<td>Returns the content of register <strong>$t0</strong> (output used for debugging and testing)</td>
</tr>

<tr>
<td style="text-align:center">t1</td>
<td style="text-align:center">32</td>      
<td>Returns the content of register <strong>$t1</strong> (output used for debugging and testing)</td>
</tr>

<tr>
<td style="text-align:center">t2</td>
<td style="text-align:center">32</td>      
<td>Returns the content of register <strong>$t2</strong> (output used for debugging and testing)</td>
</tr>

<tr>
<td style="text-align:center">s0</td>
<td style="text-align:center">32</td>    
<td>Returns the content of register <strong>$s0</strong> (output used for debugging and testing)</td>
</tr>

<tr>
<td style="text-align:center">s1</td>
<td style="text-align:center">32</td>      
<td>Returns the content of register <strong>$s1</strong> (output used for debugging and testing)</td>
</tr>

<tr>
<td style="text-align:center">a0</td>
<td style="text-align:center">32</td>      
<td>Returns the content of register <strong>$a0</strong> (output used for debugging and testing)</td>
</tr>

<tr>
<td style="text-align:center">DMEM_ADDRESS</td>
<td style="text-align:center">32</td>      
<td>Data Memory (DMEM) address</td>
</tr>

<tr>
<td style="text-align:center">WRITE_DATA</td>
<td style="text-align:center">32</td>      
<td>Data to store into DMEM</td>      

</tr>

<tr>
<td style="text-align:center">WRITE_ENABLE</td>
<td style="text-align:center">4</td>      
<td>Enables or disables writting into DMEM</td>      
</tr>

<tr>
<td style="text-align:center">IMEM_ADDRESS</td>
<td style="text-align:center">32</td>      
<td>
This output holds the address of the instruction to retrieve from IMEM (in <code>run_*_harness.circ</code>). The fetched instruction is fed to the INSTRUCTION input port of the CPU</td>      
</tr>  
</tbody>
</table>

<h3 id="implementation-guidelines-for-the-single-cycle-processor">Implementation Guidelines for the single-cycle processor</h3>

<p>These guidelines will help you implement the <code class="language-plaintext highlighter-rouge">addi</code> instruction in your <code class="language-plaintext highlighter-rouge">cpu_single.circ</code> processor. Each section below contains questions to think about and important hints. It is necessary to read and understand each question before moving on to the next one! You can even check the answers by clicking ▶ if you are unable to find the answers yourself.</p>

<p>Recall the five steps of executing an instruction in a MIPS processor:</p>

<ol>
  <li>Instruction Fetch (IF)</li>
  <li>Instruction Decode (ID)</li>
  <li>Instruction Execution (EX)</li>
  <li>Read from (resp. Write to) Data Memory (MEM)</li>
  <li><em>Eventually</em> Write Back to the “<strong>Registers File</strong>” (WB)</li>
</ol>

<h4 id="step-1-instruction-fetch-if"><strong>Step 1: Instruction Fetch (IF)</strong></h4>

<p>The main question that arises at this stage is “How to get the current instruction?”. We have seen in lecture <a href="https://adminunivalger-my.sharepoint.com/:p:/g/personal/a_benhadid_univ-alger_dz/EVNM4EM0WgVFpYx1qH4Ng3sB8F7fBjJpNq45UjJkQTgyUA?e=uF8TJR">Datapath</a> that instructions are stored in the Instructions Memory (IMEM), and each of these instructions is accessible via an address.</p>

<fieldset class="tips">
<legend style="color: DarkSlateGrey">Hints</legend>

<details close="">
<summary>
1. Which file in the starter kit implements the Instructions Memory? How is it connected to the processor?
</summary>
<p style="color: DarkSlateGrey">
The instructions Memory (IMEM) is the ROM module in the <code class="language-plaintext highlighter-rouge">run_*.circ</code> files. These files provide an input to your CPU named <code class="language-plaintext highlighter-rouge">INSTRUCTION</code> and recieve an output from your CPU. This output is called <code class="language-plaintext highlighter-rouge">IMEM_ADDRESS</code> in <code class="language-plaintext highlighter-rouge">cpu_*.circ</code> files and it is called <code class="language-plaintext highlighter-rouge">FETCH_ADDR</code> in <code class="language-plaintext highlighter-rouge">run_*.circ</code>.
</p>
</details>
 
<details close="">
<summary>
2. In <code class="language-plaintext highlighter-rouge">cpu*.circ</code> circuits, how would changing the address passed through <code class="language-plaintext highlighter-rouge">IMEM_ADDRESS</code> affect the <code class="language-plaintext highlighter-rouge">INSTRUCTION</code> input?
</summary>
<p style="color: DarkSlateGrey">
The instruction that <code class="language-plaintext highlighter-rouge">run_*.circ</code> passes to the processor must be the instruction found at address <code class="language-plaintext highlighter-rouge">IMEM_ADDRESS</code> in Instructions Memory (IMEM). The IMEM memory, implemented in the <code class="language-plaintext highlighter-rouge">test_*_harness.circ</code> harnesses, is connected to the <code class="language-plaintext highlighter-rouge">test_harness</code> output port IMEM_ADDRESS with a wire labeled <code class="language-plaintext highlighter-rouge">fetch_addr</code>.</p>
</details>

<details close="">
<summary>
3. How to check if <code class="language-plaintext highlighter-rouge">IMEM_ADDRESS</code> is correct?
</summary>
<p style="color: DarkSlateGrey">
<code class="language-plaintext highlighter-rouge">IMEM_ADDRESS</code> is the address of the currently executing instruction. This address is stored in the <code class="language-plaintext highlighter-rouge">PC</code> register. For this project, the <code class="language-plaintext highlighter-rouge">PC</code> register will start at the value <code class="language-plaintext highlighter-rouge">0</code> because this is the default value in a Logisim register.
</p>
</details>

<details close="">
<summary>
4. How does the <code class="language-plaintext highlighter-rouge">PC</code> register change for codes that do not have jump or branch instructions?
</summary>
<p style="color: DarkSlateGrey">
Since the <code class="language-plaintext highlighter-rouge">PC</code> register contains the address of the currently executing instruction, one must increment this register by the size of one instruction to advance to the next instruction. This means that the <code class="language-plaintext highlighter-rouge">PC</code> will typically increase by 4 (assuming the current instruction is not a jump or a branch).
</p>
</details>
</fieldset>

<p><br /></p>

<p>A simple implementation of the <code class="language-plaintext highlighter-rouge">PC</code> register is provided in <code class="language-plaintext highlighter-rouge">cpu_*.circ</code>. This implementation does not take into account the jump and branch instructions that you will need to implement in Part B of this project. But for now, only <code class="language-plaintext highlighter-rouge">addi</code> instructions need to be handled by the processor.</p>

<p>Recall however that you will eventually implement a 2-stage pipelined processor, so that the IF stage is separated from the remaining stages. What circuit separates the different stages in a pipeline? More precisely, what circuit separates IF from the next stage? Is there anything you need to add here?</p>

<p><br /></p>

<h4 id="step-2-instruction-decoder-id"><strong>Step 2: Instruction Decoder (ID)</strong></h4>

<p>Once the “IF” stage is implemented, the fetched instruction should be available at the <code class="language-plaintext highlighter-rouge">INSTRUCTION</code> input port of the processor. The second step is therefore to decompose this instruction in order to determine what to do with it in the subsequent execution steps.</p>

<fieldset class="tips">
<legend style="color: DarkSlateGrey">Hints</legend>

<details close="">
<summary>
1. What type of instruction is <code class="language-plaintext highlighter-rouge">addi</code>? What are the different bit fields associated with this type of instruction? What are their bit ranges?
</summary>
<p style="color: DarkSlateGrey">
<code class="language-plaintext highlighter-rouge">addi</code> is a “<strong>type I</strong>” instruction. The bit fields (and ranges) are: - <code class="language-plaintext highlighter-rouge">opcode [31-26]</code> - <code class="language-plaintext highlighter-rouge">rs [25-21]</code> - <code class="language-plaintext highlighter-rouge">rt [20-16]</code> - <code class="language-plaintext highlighter-rouge">imm [15-0]</code>.</p>
</details>

<details close="">
<summary>
2. In Logisim, what tool would you use to separate different groups of bits?
</summary>
<p style="color: DarkSlateGrey">
Splitters!
</p>
</details>
<p>
<br />
    3. Implement the “Instruction decoding” step of the <code class="language-plaintext highlighter-rouge">INSTRUCTION</code> input. You should use tunnels to label and group the bits.
</p>
<details close="">
<summary>
4. In an <code class="language-plaintext highlighter-rouge">addi</code> instruction, we need to read the content of a register in the “<strong>Registers File</strong>” and then add it to a constant. Which field of the Instruction code should be connected to the “<strong>Registers File</strong>”? To which input of the “<strong>Registers File</strong>” should it be connected?
</summary>
<p style="color: DarkSlateGrey">
The <code class="language-plaintext highlighter-rouge">rs</code> field must be connected to the “read register 1” input of the “<strong>Registers File</strong>”.
</p>
</details>
<!-- Le résultat de l'opération sera plus tard réinscrit dans le registre destination spécifié dans l'instruction.-->
<p>
<br />
    5. Implement the reading step from the “<strong>Registers File</strong>”. Don’t forget to integrate your “<strong>Registers File</strong>” from task #2. Don’t forget to connect the clock!
</p>
<details close="">
<summary>
6. How could the “Immediate Unit” (<code class="language-plaintext highlighter-rouge">imm_gen.circ</code>) be useful here?
</summary>
<p style="color: DarkSlateGrey">
For the <code class="language-plaintext highlighter-rouge">addi</code> instruction, the “Immediate Unit” takes 16 bits of the instruction as input and produces a 32-bit signed immediate. You need to implement this logic in the “Immediate Unit”!
</p>
</details>
</fieldset>
<p><br /></p>

<h4 id="step-3-executing-the-instruction-ex"><strong>Step 3: Executing the instruction (EX)</strong></h4>

<p>The execution stage is where the computation is done.</p>

<fieldset class="tips">
<legend style="color: DarkSlateGrey">Hints</legend>
<details close="">
<summary>
1. For the <code class="language-plaintext highlighter-rouge">addi</code> instruction, what would be the input data to your ALU?
</summary>
<p style="color: DarkSlateGrey">
Read Data 1 (rs) from the “<strong>Registers File</strong>” and the constant produced by the “Immediate Unit”.
</p>
</details>

<details close="">
<summary>
2. What is the purpose of <code class="language-plaintext highlighter-rouge">ALUSel</code>?
</summary>
<p style="color: DarkSlateGrey">
It selects what operation the ALU should perform.
</p>
</details>

<details close="">
<summary>
3. Since we are implementing the <code class="language-plaintext highlighter-rouge">addi</code>instruction only for now, you can just paste a constant for <code class="language-plaintext highlighter-rouge">ALUSel</code>. Why would this be discouraged if you take into consideration that other instructions will be implemented in the future?
</summary>
<p style="color: DarkSlateGrey">
When implementing more instructions, <code class="language-plaintext highlighter-rouge">ALUSel</code> might change depending on the requested operation. So, we need some kind of circuit that changes the value of <code class="language-plaintext highlighter-rouge">ALUSel</code> depending on the instruction being executed.
</p>
</details>
<p>
<br />
   4. Integrate the ALU developed in task #1 into your processor and connect the inputs correctly. Do you need to connect a clock? Why or why not?
</p>
</fieldset>
<p><br /></p>

<h4 id="step-4-read-fromwrite-to-data-memory-mem"><strong>Step 4: Read from/write to Data Memory (MEM)</strong></h4>

<p>The <strong>MEM</strong> step is where the Data Memory (DMEM) can be modified using data store instructions or read using data load instructions. Since the <code class="language-plaintext highlighter-rouge">addi</code> instruction does not need accesss to DMEM, we can ignore this part of the circuit for now and continue with the next step of execution.</p>

<h4 id="step-5-writing-back-to-the-registers-file-wb"><strong>Step 5: Writing back to the “</strong>Registers File<strong>” (WB)</strong></h4>

<p>The WriteBack step is required when the results of an operation are to be saved to a register in the “<strong>Registers File</strong>”.</p>

<fieldset class="tips">
<legend style="color: DarkSlateGrey">Hints</legend>
<details close="">
<summary>
1. Does the <code class="language-plaintext highlighter-rouge">addi</code> instruction require a save to a register?
</summary>
<p style="color: DarkSlateGrey">
YES! The <code class="language-plaintext highlighter-rouge">addi</code> instruction takes the output of an addition computation from the ALU and writes the result to a register in the “<strong>Registers File</strong>”.
</p>
</details>
<p>
<br />
    2. We have seen in the “<a href="https://adminunivalger-my.sharepoint.com/:p:/g/personal/a_benhadid_univ-alger_dz/EVNM4EM0WgVFpYx1qH4Ng3sB8F7fBjJpNq45UjJkQTgyUA?e=uF8TJR">Datapath</a>” lecture that the <strong>WB</strong> step is used for writing 
 the output of the <strong>ALU</strong> or <strong>DMEM</strong> to a register in the “<strong>Registers File</strong>”. So let’s create the writing phase in this perspective even if we are only interested in the <code class="language-plaintext highlighter-rouge">addi</code> instruction for now. Since only one data at a time can be written to the “<strong>Registers File</strong>”, we must use a MUX to choose which of the outputs of the ALU or <strong>DMEM</strong> (<code class="language-plaintext highlighter-rouge">READ_DATA</code>) to transmit. Later, when you implement other instructions in part B of the project, you should review the implementation of this multiplexer to handle more cases.
</p>
<details close="">
<summary>
3. What should the MUX selection input be? What does the input depend on?
</summary>
<p style="color: DarkSlateGrey">
There should be three inputs for the MUX to choose from: (1) ALU, (2) DMEM (<code class="language-plaintext highlighter-rouge">READ_DATA</code>), and (3) PC + 4 (when will we need this one?). The control signal that determines which of these inputs is transmitted to the “<strong>Registers File</strong>” is called <code class="language-plaintext highlighter-rouge">WBSel</code>. For now, <code class="language-plaintext highlighter-rouge">WBSel</code> should have only one value (i.e. a constant) - whatever you chose for <code class="language-plaintext highlighter-rouge">addi</code>.
</p>
</details>
<details close="">
<summary>
4. Now that the MUX inputs are fixed, we need to plug its output somewhere! Where should it be connected to?
</summary>
<p style="color: DarkSlateGrey">
The output of the MUX carries the data you want to write to the “<strong>Registers File</strong>”, so it must be connected to the <code class="language-plaintext highlighter-rouge">Write Data</code> input of the “<strong>Registers File</strong>”.
</p>
</details>
<p>
<br />
    5. There are two more inputs on the “<strong>Registers File</strong>” that are important for writing data: <code class="language-plaintext highlighter-rouge">RegWEn</code> and <code class="language-plaintext highlighter-rouge">Write Register</code>. One of them will need to be retrieved during the instruction decode (ID) stage and the other one is a control signal. Finish implementing the <strong>WB</strong> stage for the <code class="language-plaintext highlighter-rouge">addi</code> instruction by setting these inputs correctly.
</p>
</fieldset>

<p>If you did all the steps correctly, you should have a single-cycle processor (<code class="language-plaintext highlighter-rouge">cpu_single.circ</code>) that works for <code class="language-plaintext highlighter-rouge">addi</code> instructions 🎉. Run <code class="language-plaintext highlighter-rouge">python3 test_runner.py part_a addi_single</code> from the terminal and check if your implementation works correctly!</p>

<h3 id="guidelines-for-a-two-stage-pipelined-processor">Guidelines for a two-stage pipelined processor</h3>

<p>Now it’s time to turn your single-cycle processor into a “pipelined” version! For this project, you need to implement a two-stage pipeline, which is still conceptually similar to the five-stage pipeline introduced in the “<a href="https://adminunivalger-my.sharepoint.com/:p:/g/personal/a_benhadid_univ-alger_dz/EU2Y9AtLhfJEkVic7ZqP7XkBwH4IwsEtxaVP-rn6ipp6aw?e=mpLjak">Pipelining</a>” lecture. The two stages to implement are:</p>

<ol>
  <li>Instruction Fetch (PIF): An instruction is fetched from Instructions Memory (IMEM).</li>
  <li>Instruction Execution (PEX): The instruction is decoded, executed, and validated (i.e. result saved). This is a combination of the last four stages (ID, EX, MEM, and WB) in a single-cycle processor.</li>
</ol>

<p>Since the instruction decoding and execution steps are handled in the PEX stage, <strong>your pipelined <code class="language-plaintext highlighter-rouge">addi</code> processor will be more or less identical to its « single-cycle » version, except for the one clock cycle startup latency</strong>. We will, however, apply the pipeline design rules seen in class in order to prepare our processor for Part B of this project.</p>

<p>Some points to consider for a two-stage pipeline design:</p>

<ul>
  <li>
    <p>Will the PIF and PEX stages have the same or different <code class="language-plaintext highlighter-rouge">PC</code> values?</p>
  </li>
  <li>
    <p>Do you need to store the <code class="language-plaintext highlighter-rouge">PC</code> between pipeline stages?</p>
  </li>
</ul>

<p>On the other hand, we will get a bootstrapping problem here: during the first execution cycle, the registers introduced between the different pipeline stages are initially (empty), but the void does not exist in hardware. How will we handle this first dummy instruction? What would the void correspond to in our processor? I.e. to what value should we initialise the newly introduced registers in order to “do nothing” during the first execution cycle?</p>

<p>Sometimes Logisim automatically resets the registers to zero at startup (or on reset); which, for our bootstrapping problem, will simulate a <code class="language-plaintext highlighter-rouge">nop</code> instruction! Thanks Logisim! Don’t forget to go to « <strong>Simulate | Reset Simulation</strong> » to reset your processor.</p>

<p>After you have « pipelined » your processor, you should be able to pass the <code class="language-plaintext highlighter-rouge">python3 test_runner.py part_a addi_pipelined</code> tests. Note that the previous <code class="language-plaintext highlighter-rouge">python3 test_runner.py part_a addi_single</code> test should fail now (why? Check the benchmark outputs for each test and think about the effects of the pipeline registers on the different execution stages).</p>

<!--{:start="7"}-->

<h2 id="understanding-the-tests">Understanding the tests</h2>

<p>The cpu tests included in the startup circuits are copies of the <code class="language-plaintext highlighter-rouge">run_*.circ</code> files and contain instructions that have been previously loaded into the Instructions Memory (IMEM). When Logisim is run from the <a href="https://www.baillifard.com/logisim/en/html/guide/verify/index.html">command line</a>, your circuit is automatically started. Execution is clocked, your processor’s <code class="language-plaintext highlighter-rouge">PC</code> is updated, the fetched instruction is processed, and the values ​​of each of the test circuit’s outputs are printed to the console.</p>

<p>Consider the <code class="language-plaintext highlighter-rouge">addi-pipelined</code> test folder as an example. <code class="language-plaintext highlighter-rouge">Instruction Memory</code> in the <code class="language-plaintext highlighter-rouge">cpu-addi.circ</code> circuit contains three <code class="language-plaintext highlighter-rouge">addi</code> instructions (<code class="language-plaintext highlighter-rouge">addi $t0, $0, 5</code>, <code class="language-plaintext highlighter-rouge">addi $t1, $t0, 7</code> and <code class="language-plaintext highlighter-rouge">addi $s0, $t0, 9</code>). Open the <code class="language-plaintext highlighter-rouge">tests/part_a/addi_pipelined/cpu-addi.circ</code> file in Logisim and take a closer look at the different parts of the test circuit. At the top, you will see where the <code class="language-plaintext highlighter-rouge">test_harness</code> is connected to for the debug outputs. Initially, these outputs are all <code class="language-plaintext highlighter-rouge">UUUUU</code>, but this should not be the case once your <code class="language-plaintext highlighter-rouge">cpu_pipelined.circ</code> circuit is implemented.</p>

<p>The <code class="language-plaintext highlighter-rouge">test_harness</code> socket takes as input the clock signal <code class="language-plaintext highlighter-rouge">clk</code> and the <code class="language-plaintext highlighter-rouge">Instruction</code> provided by the <code class="language-plaintext highlighter-rouge">Instruction Memory</code> module. As output, the socket transmits (for display) the values ​​of the debug registers from your processor circuit <code class="language-plaintext highlighter-rouge">cpu_pipelined.circ</code>. The additional output <code class="language-plaintext highlighter-rouge">fetch_addr</code> holds the address of the next instruction to fetch from <code class="language-plaintext highlighter-rouge">Instruction Memory</code>.</p>

<div class="bs-callout bs-callout-danger">
  <h4>CAUTION</h4>
  <p>
  Do <b>not move</b> any of your processor's I/O and <b> do not </b> add additional I/O. This will change the shape of the processor's subcircuit in and therefore the connections with the <code>test_harness</code> module may not work properly anymore.
  </p>
</div>

<p>Under the <code class="language-plaintext highlighter-rouge">test_harness</code> module, you will see the <code class="language-plaintext highlighter-rouge">Instruction Memory</code> containing the hex machine code of the three <code class="language-plaintext highlighter-rouge">addi</code> instructions under test (0x20080005, 0x21090007, 0x21100009). The <code class="language-plaintext highlighter-rouge">Instruction Memory</code> takes an address (i.e. <code class="language-plaintext highlighter-rouge">fetch_addr</code>) and outputs the instruction stored at that address. In MIPS, <code class="language-plaintext highlighter-rouge">fetch_addr</code> is a 32-bit value, but since Logisim limits the size of ROM units to \(2^{24}\), we use a splitter to retrieve 24 bits of <code class="language-plaintext highlighter-rouge">fetch_addr</code> (i.e. the bit range <code class="language-plaintext highlighter-rouge">2..25</code>, ignoring the lowest two bits).</p>

<fieldset class="tips">
<legend style="color: DarkSlateGrey">Hint</legend>
<details close="">
<summary>
Why are the two LSB bits of the <code class="language-plaintext highlighter-rouge">fetch_addr</code> address ignored?
</summary>
<p style="color: DarkSlateGrey">
In MIPS, an instruction is 32-bit in width and occupy thus four bytes in memory stored at an address that is multiple of 4 (i.e. the 2 LSBs of <code class="language-plaintext highlighter-rouge">fetch_addr</code> are always zeros). Besides, instructions are fetched word-by-word from <code class="language-plaintext highlighter-rouge">Instruction Memory</code>. So, we need to convert <code class="language-plaintext highlighter-rouge">fetch_addr</code> which is a byte address, to a word address by removing the two lowest bits.
</p>
</details>
</fieldset>

<p>So, when the test circuit is powered on, each tick of the clock drives the execution of the <code class="language-plaintext highlighter-rouge">test_harness</code> module and increments the counter called <code class="language-plaintext highlighter-rouge">Time_Step</code> (this counter is located to the right of the <code class="language-plaintext highlighter-rouge">Instruction Memory</code>, zoom out in Logisim if it is not visible on your screen).</p>

<p>At each tick of the clock, a <a href="https://www.baillifard.com/logisim/en/html/guide/verify/index.html">command line</a> execution of Logisim will print the values ​​of each of your debug outputs to the terminal. The clock will continue to run until <code class="language-plaintext highlighter-rouge">Time_Step</code> equals the stopping constant for this test circuit (for this particular test file, the stopping constant is 4).</p>

<p>Finally, we compare the output of your circuit to the reference  (i.e. expected) output; if your circuit output is different, the test will fail.</p>

<h3 id="the-addi-tests">The <code class="language-plaintext highlighter-rouge">addi</code> tests</h3>

<p>The “test runner” provided in the starter kit can be used to run two set of tests for the <code class="language-plaintext highlighter-rouge">addi</code> instruction: a set of tests for the single-cycle processor and a set of tests for the pipelined processor. You can run the test script for the “pipelined” version with the following command (replace <code class="language-plaintext highlighter-rouge">pipelined</code> with <code class="language-plaintext highlighter-rouge">single</code> to test the “single-cycle” version):</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>python3 test_runner.py part_a addi_pipelined <span class="c"># For a pipelined CPU</span>
</code></pre></div></div>
<p>You can see the <code class="language-plaintext highlighter-rouge">.s</code> (MIPS) and <code class="language-plaintext highlighter-rouge">.hex</code> (machine code) files used for the test in <code class="language-plaintext highlighter-rouge">tests/part_a/addi_pipelined/inputs</code>.</p>

<p>To make it easier to interpret your output, a Python script (<code class="language-plaintext highlighter-rouge">binary_to_hex_cpu.py</code>) is also included. This script works like the <code class="language-plaintext highlighter-rouge">binary_to_hex_alu.py</code> and <code class="language-plaintext highlighter-rouge">binary_to_hex_regfile.py</code> scripts used in the ALU and in the “Registers File” design tasks (i.e. Tasks #1 and #2). To use the script, run:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">cd </span>tests/part_a/addi_pipelined
<span class="nv">$ </span>python3 binary_to_hex_cpu.py student_output/CPU-addi-pipelined-student.out
</code></pre></div></div>

<p>or, to view the reference output (i.e. what your circuit should print), run:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">cd </span>tests/part_a/addi_pipelined
<span class="nv">$ </span>python3 binary_to_hex_cpu.py reference_output/CPU-addi-pipelined-ref.out
</code></pre></div></div>

<h2 id="submit-part-a-of-the-assignment">Submit Part A of the assignment</h2>

<p>Make sure again that you have not moved/modified your I/O ports and that your circuits fit into the provided test harnesses without any problems.</p>

<p>For the evaluation of this part of the project, you must submit a <strong>zipped</strong> file containing all the circuits that you need to implement (i.e. the <strong>alu.circ</strong>, <strong>regfile.circ</strong>, <strong>imm_gen.circ</strong>, <strong>control_logic.circ</strong> and <strong>cpu_*.circ</strong> circuits).</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>your_zipped_file.zip
 ├── alu.circ
 ├── regfile.circ
 ├── imm_gen.circ
 ├── control_logic.circ
 ├── cpu_single.circ
 └── cpu_pipelined.circ
</code></pre></div></div>

<p>If you’re using the VM provided for this course to do this project, you can zip two files (or more) <strong>file1.circ</strong> and <strong>file2.circ</strong> into a file named <strong>your_zipped_file.zip</strong> with the following steps:</p>
<ol>
  <li>Open a terminal then, with the <code class="language-plaintext highlighter-rouge">cd</code> bash command, go to the folder containing the files <strong>file1.circ</strong> and <strong>file2.circ</strong>.</li>
  <li>Type the command:
    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>zip your_zipped_file.zip file1.circ file2.circ
</code></pre></div>    </div>
  </li>
</ol>

<p>Then submit the file <strong>your_file.zip</strong> for evaluation. For this part of the project, the Autograder uses the same test files already provided in the starter kit. I.e. there are no hidden tests !</p>

<p><br />
<br /></p>

<hr />

<p><br /></p>
<h1 id="part-b-processor-design-advanced-version">Part B: Processor design (advanced version)</h1>

<h2 id="task-4-more-instructions">Task 4: More instructions</h2>

<p>In Task #3, you implemented a basic two-stage pipeline processor capable of executing <code class="language-plaintext highlighter-rouge">addi</code> instructions. Now, you will beef up your processor by implementing more instructions!</p>

<h3 id="the-instruction-set-architecture-isa-of-the-cpu">The Instruction Set Architecture (ISA) of the CPU</h3>

<p>Below is a set of instructions your CPU must support and will be evaluated on. You are free to implement additional instructions if you wish but make sure, however, that none of your additional instructions affect the operation of the instructions specified here. Implementing additional instructions will not affect your score for this project.</p>

<table class="styled-table">
<colgroup>
<col width="15%" />
<col width="30%" />
<col width="32%" />
<col width="8%" />
<col width="15%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align:center">Instruction</th>
<th style="text-align:center">Description</th>
<th style="text-align:center">Operation</th>
<th style="text-align:center">Type</th>
<th style="text-align:center">Opcode/Func</th>

</tr>
</thead>
<tbody>

<tr>
<td style="text-align:left"><strong>add</strong> rd, rs, rt</td>
<td style="text-align:left">Addition</td>
<td style="text-align:left">R[rd] ← R[rs] + R[rt]</td>
<td style="text-align:center">R</td>
<td style="text-align:left"> 0x0 / 0x20</td>
</tr>

<tr>
<td style="text-align:left"><strong>sub</strong> rd, rs, rt</td>
<td style="text-align:left">Substraction</td>
<td style="text-align:left">R[rd] ← R[rs] - R[rt]</td>
<td style="text-align:center">R</td>
<td style="text-align:left"> 0x0 / 0x22</td>
</tr>

<tr>
<td style="text-align:left"><strong>addi</strong> rt, rs, imm</td>
<td style="text-align:left">Addition<br />(2<sup>nd</sup> param. : immediate)</td>
<td style="text-align:left">R[rt] ← R[rs] + imm<sub>±</sub></td>
<td style="text-align:center">I</td>
<td style="text-align:left"> 0x8</td>
</tr>

<tr>
<td style="text-align:left"><strong>mul</strong> rd, rs, rt</td>
<td style="text-align:left">Multiplication</td>
<td style="text-align:left">R[rd] ← (R[rs] x R[rt])[31:0]</td>
<td style="text-align:center">R</td>
<td style="text-align:left"> 0x0 / 0x18</td>
</tr>

<tr>
<td style="text-align:left"><strong>mulh</strong> rd, rs, rt</td>
<td style="text-align:left">Multiplication</td>
<td style="text-align:left">R[rd] ← (R[rs] x R[rt])[63:32]</td>
<td style="text-align:center">R</td>
<td style="text-align:left"> 0x0 / 0x10</td>
</tr>

<tr>
<td style="text-align:left"><strong>mulhu</strong> rd, rs, rt</td>
<td style="text-align:left">Multiplication;<br />(unsigned params)</td>
<td style="text-align:left">R[rd] ← (R[rs] x R[rt])[63:32]</td>
<td style="text-align:center">R</td>
<td style="text-align:left"> 0x0 / 0x19</td>
</tr>


<tr>
<td style="text-align:left"><strong>and</strong> rd, rs, rt</td>
<td style="text-align:left">logical AND</td>
<td style="text-align:left">R[rd] ← R[rs] &amp; R[rt]</td>
<td style="text-align:center">R</td>
<td style="text-align:left"> 0x0 / 0x24</td>
</tr>

<tr>
<td style="text-align:left"><strong>or</strong> rd, rs, rt</td>
<td style="text-align:left">logical OR</td>
<td style="text-align:left">R[rd] ← R[rs] | R[rt]</td>
<td style="text-align:center">R</td>
<td style="text-align:left"> 0x0 / 0x25</td>
</tr>

<tr>
<td style="text-align:left"><strong>xor</strong> rd, rs, rt</td>
<td style="text-align:left">Exclusive OR</td>
<td style="text-align:left">R[rd] ← R[rs] ^ R[rt]</td>
<td style="text-align:center">R</td>
<td style="text-align:left"> 0x0 / 0x26</td>
</tr>

<tr>
<td style="text-align:left"><strong>andi</strong> rt, rs, imm</td>
<td style="text-align:left">logical AND<br />(2<sup>nd</sup> param. : immediate)</td>
<td style="text-align:left">R[rd] ← R[rs] &amp; imm<sub>0</sub></td>
<td style="text-align:center">I</td>
<td style="text-align:left"> 0xC</td>
</tr>

<tr>
<td style="text-align:left"><strong>ori</strong> rt, rs, imm</td>
<td style="text-align:left">logical OR<br />(2<sup>nd</sup> param. : immediate)</td>
<td style="text-align:left">R[rd] ← R[rs] | imm<sub>0</sub></td>
<td style="text-align:center">I</td>
<td style="text-align:left"> 0xD</td>
</tr>

<tr>
<td style="text-align:left"><strong>xori</strong> rt, rs, imm</td>
<td style="text-align:left">Exclusive OR<br />(2<sup>nd</sup> param. : immediate)</td>
<td style="text-align:left">R[rd] ← R[rs] ^ imm<sub>0</sub></td>
<td style="text-align:center">I</td>
<td style="text-align:left"> 0xE</td>
</tr>

<tr>
<td style="text-align:left"><strong>sll</strong> rd, rt, sh</td>
<td style="text-align:left">Logical left shift</td>
<td style="text-align:left">R[rd] ← R[rt] &lt;&lt; sh</td>
<td style="text-align:center">R</td>
<td style="text-align:left"> 0x0 / 0x0</td>
</tr>

<tr>
<td style="text-align:left"><strong>srl</strong> rd, rt, sh</td>
<td style="text-align:left">Logical right shift</td>
<td style="text-align:left">R[rd] ← R[rt] &gt;&gt;&gt; sh</td>
<td style="text-align:center">R</td>
<td style="text-align:left"> 0x0 / 0x2</td>
</tr>

<tr>
<td style="text-align:left"><strong>sra</strong> rd, rt, sh</td>
<td style="text-align:left">Arithmetic shift</td>
<td style="text-align:left">R[rd] ← R[rt] &gt;&gt; sh</td>
<td style="text-align:center">R</td>
<td style="text-align:left"> 0x0 / 0x3</td>
</tr>

<tr>
<td style="text-align:left"><strong>sllv</strong> rd, rt, rs</td>
<td style="text-align:left">Logical left shift<br />with register</td>
<td style="text-align:left">R[rd] ← R[rt] &lt;&lt; rs</td>
<td style="text-align:center">R</td>
<td style="text-align:left"> 0x0 / 0x4</td>
</tr>

<tr>
<td style="text-align:left"><strong>srlv</strong> rd, rt, rs</td>
<td style="text-align:left">Logical right shift<br />with register</td>
<td style="text-align:left">R[rd] ← R[rt] &gt;&gt;&gt; rs</td>
<td style="text-align:center">R</td>
<td style="text-align:left"> 0x0 / 0x6</td>
</tr>

<tr>
<td style="text-align:left"><strong>srav</strong> rd, rt, rs</td>
<td style="text-align:left">Arithmetic shift<br />with register</td>
<td style="text-align:left">R[rd] ← R[rt] &gt;&gt; rs</td>
<td style="text-align:center">R</td>
<td style="text-align:left"> 0x0 / 0x7</td>
</tr>

<tr>
<td style="text-align:left"><strong>slt</strong> rd, rs, rt</td>
<td style="text-align:left">Set if less than</td>
<td style="text-align:left">R[rd] ← R[rs] &lt; R[rt] ? 1 : 0</td>
<td style="text-align:center">R</td>
<td style="text-align:left"> 0x0 / 0x2A</td>
</tr>

<tr>
<td style="text-align:left"><strong>sltu</strong> rd, rs, rt</td>
<td style="text-align:left">Set if less than (unsigned)</td>
<td style="text-align:left">R[rd] ← R[rs] &lt; R[rt] ? 1 : 0</td>
<td style="text-align:center">R</td>
<td style="text-align:left"> 0x0 / 0x2B</td>
</tr>

<tr>
<td style="text-align:left"><strong>slti</strong> rt, rs, imm</td>
<td style="text-align:left">Set if less than<br />(2<sup>nd</sup> param. : immediate)</td>
<td style="text-align:left">R[rt] ← R[rs] &lt; imm<sub>±</sub> ? 1 : 0</td>
<td style="text-align:center">I</td>
<td style="text-align:left"> 0xA</td>
</tr>

<tr>
<td style="text-align:left"><strong>sltiu</strong> rt, rs, imm</td>
<td style="text-align:left">Set if less than (unsigned)<br />(2<sup>nd</sup> param. : immediate)</td>
<td style="text-align:left">R[rt] ← R[rs] &lt; imm<sub>±</sub> ? 1 : 0</td>
<td style="text-align:center">I</td>
<td style="text-align:left"> 0xB</td>
</tr>

<tr>
<td style="text-align:left"><strong>j</strong> imm</td>
<td style="text-align:left">Jump to Label</td>
<td style="text-align:left">PC ← PC &amp; 0xF0000000 | (imm &lt;&lt; 2)</td>
<td style="text-align:center">J</td>
<td style="text-align:left"> 0x2</td>
</tr>

<tr>
<td style="text-align:left"><strong>jal</strong> imm</td>
<td style="text-align:left">Jump and link</td>
<td style="text-align:left">$ra ← PC + 4;<br />PC ← PC &amp; 0xF0000000 | (imm &lt;&lt; 2)</td>
<td style="text-align:center">J</td>
<td style="text-align:left"> 0x3</td>
</tr>

<tr>
<td style="text-align:left"><strong>jalr</strong> rd, rs</td>
<td style="text-align:left">Jump to register and link</td>
<td style="text-align:left">R[rd] ← PC + 4;<br />PC ← R[rs]</td>
<td style="text-align:center">R</td>
<td style="text-align:left"> 0x0 / 0x9</td>
</tr>

<tr>
<td style="text-align:left"><strong>beq</strong> rt, rs, imm</td>
<td style="text-align:left">Branch if equal</td>
<td style="text-align:left">if (R[rs] == R[rt])<br /> PC ← PC + 4 + (imm<sub>±</sub>&lt;&lt; 2)</td>
<td style="text-align:center">I</td>
<td style="text-align:left"> 0x4</td>
</tr>

<tr>
<td style="text-align:left"><strong>bne</strong> rt, rs, imm</td>
<td style="text-align:left">Branch if not equal</td>
<td style="text-align:left">if (R[rs] != R[rt])<br /> PC ← PC + 4 + (imm<sub>±</sub>&lt;&lt; 2)</td>
<td style="text-align:center">I</td>
<td style="text-align:left"> 0x5</td>
</tr>

<tr>
<td style="text-align:left"><strong>lui</strong> rt, imm</td>
<td style="text-align:left">Load upper immediate</td>
<td style="text-align:left">R[rt] ← imm &lt;&lt; 16</td>
<td style="text-align:center">I</td>
<td style="text-align:left"> 0xF</td>
</tr>

<tr>
<td style="text-align:left"><strong>lb</strong> rt, imm(rs)</td>
<td style="text-align:left">Load byte</td>
<td style="text-align:left">R[rt] ← Mem( R[rs] + imm<sub>±</sub>, octet )<sub>±</sub></td>
<td style="text-align:center">I</td>
<td style="text-align:left"> 0x20</td>
</tr>

<tr>
<td style="text-align:left"><strong>lh</strong> rt, imm(rs)</td>
<td style="text-align:left">Load half</td>
<td style="text-align:left">R[rt] ← Mem( R[rs] + imm<sub>±</sub>, demi )<sub>±</sub></td>
<td style="text-align:center">I</td>
<td style="text-align:left"> 0x21</td>
</tr>

<tr>
<td style="text-align:left"><strong>lw</strong> rt, imm(rs)</td>
<td style="text-align:left">Load word</td>
<td style="text-align:left">R[rt] ← Mem( R[rs] + imm<sub>±</sub>, mot )</td>
<td style="text-align:center">I</td>
<td style="text-align:left"> 0x23</td>
</tr>

<tr>
<td style="text-align:left"><strong>sb</strong> rt, imm(rs)</td>
<td style="text-align:left">Store byte</td>
<td style="text-align:left">Mem( R[rs] + imm<sub>±</sub> ) ← R[rt][7:0]</td>
<td style="text-align:center">I</td>
<td style="text-align:left"> 0x28</td>
</tr>

<tr>
<td style="text-align:left"><strong>sh</strong> rt, imm(rs)</td>
<td style="text-align:left">Store half</td>
<td style="text-align:left">Mem( R[rs] + imm<sub>±</sub> ) ← R[rt][15:0]</td>
<td style="text-align:center">I</td>
<td style="text-align:left"> 0x29</td>
</tr>

<tr>
<td style="text-align:left"><strong>sw</strong> rt, imm(rs)</td>
<td style="text-align:left">Store word</td>
<td style="text-align:left">Mem( R[rs] + imm<sub>±</sub> ) ← R[rt]</td>
<td style="text-align:center">I</td>
<td style="text-align:left"> 0x2b</td>
</tr>

</tbody>
</table>

<p><strong>Notes</strong> :</p>

<ol>
  <li>The writing imm<sub>±</sub> in the table above means “Apply a sign extension to the immediate imm”. The same remark applies to Mem(…)<sub>±</sub>. In this case the sign extension is applied to the byte or half-word retrieved from memory.</li>
  <li>The writing imm<sub>0</sub> means “Extend with zeros the immediate imm”.</li>
</ol>

<h4 id="data-memory-dmem-memcirc"><strong>Data Memory DMEM (<code class="language-plaintext highlighter-rouge">mem.circ</code>)</strong></h4>

<p>The DMEM memory unit (provided in <code class="language-plaintext highlighter-rouge">mem.circ</code>) is already fully implemented and connected to your processor outputs in <code class="language-plaintext highlighter-rouge">test_harness.circ</code>! I.e. there is no need to add the memory unit (<code class="language-plaintext highlighter-rouge">mem.circ</code>) again to your implementation. Doing so will actually cause the testing scripts to fail, which will not be good for your score :(.</p>

<p>Note that the provided implementation of DMEM allows writing at the <strong>byte</strong> level to memory. This means that the <code class="language-plaintext highlighter-rouge">Write_En</code> signal is 4 bits wide and acts as a write mask. For example, if <code class="language-plaintext highlighter-rouge">Write_En</code> is <code class="language-plaintext highlighter-rouge">0b1000</code>, then only the most significant byte of the addressed word in memory will be overwritten (e.g. <code class="language-plaintext highlighter-rouge">sb $a0, 3($s0)</code>).</p>

<p>On the other hand, the <code class="language-plaintext highlighter-rouge">ReadData</code> port will always return the word stored at the provided address. The memory unit ignores the two least significant bits in the address you provide and treats its input as a word address rather than a byte address. For example, if you enter the 32-bit address <code class="language-plaintext highlighter-rouge">0x00001007</code> (e.g. <code class="language-plaintext highlighter-rouge">lb $a0, 7($s0)</code>, with <code class="language-plaintext highlighter-rouge">$s0=0x0001000</code>), it will be treated as word address <code class="language-plaintext highlighter-rouge">0x00001004</code>, and you will get the 4 bytes at addresses <code class="language-plaintext highlighter-rouge">0x00001004</code>, <code class="language-plaintext highlighter-rouge">0x00001005</code>, <code class="language-plaintext highlighter-rouge">0x00001006</code> and <code class="language-plaintext highlighter-rouge">0x00001007</code> as output. So you need to implement the necessary mask logic to write only the required byte(s)  into the “<strong>Registers File</strong>” (i.e. byte #3 for the example <code class="language-plaintext highlighter-rouge">lb $a0, 7($s0)</code>).</p>

<p>Finally, remember that unaligned RAM accesses will cause exceptions in MIPS. And since we do not implement any exception handling in this project, you can assume that only aligned address accesses are used for the <code class="language-plaintext highlighter-rouge">lw</code>, <code class="language-plaintext highlighter-rouge">lh</code>, <code class="language-plaintext highlighter-rouge">sh</code> and <code class="language-plaintext highlighter-rouge">sw</code> instructions. This means that the addresses used with the <code class="language-plaintext highlighter-rouge">lw</code> and <code class="language-plaintext highlighter-rouge">sw</code> (resp. <code class="language-plaintext highlighter-rouge">lh</code> and <code class="language-plaintext highlighter-rouge">sh</code>) instructions are multiples of 4 (resp. multiples of 2).</p>

<p>Voici un résumé des entrées et sorties de la mémoire :</p>

<table class="styled-table">
<colgroup>
<col width="10%" />
<col width="10%" />
<col width="20%" />
<col width="60%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align:center">Name</th>
<th style="text-align:center">Direction</th>
<th style="text-align:center">Width (in bits)</th>
<th style="text-align:center">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">WriteAddr</td>
<td style="text-align:center">Input</td>
<td style="text-align:center">32</td>
<td>Address in memory (despite the name, it is used for read or write instructions)</td>
</tr>
<tr>
<td style="text-align:center">WriteData</td>
<td style="text-align:center">Input</td>
<td style="text-align:center">32</td>
<td>Value to write to memory</td>
</tr>
<tr>
<td style="text-align:center">Write_En</td>
<td style="text-align:center">Input</td>
<td style="text-align:center">4</td>
<td>The write mask for instructions that write to memory. Zero otherwise</td>
</tr>
<tr>
<td style="text-align:center">CLK</td>
<td style="text-align:center">Input</td>
<td style="text-align:center">1</td>
<td>Input providing the CPU clock</td>
</tr>
<tr>
<td style="text-align:center">ReadData</td>
<td style="text-align:center">Output</td>
<td style="text-align:center">32</td>
<td>Data read at the specified address</td>
</tr>
</tbody>
</table>

<h4 id="the-branching-unit-branch_compcirc-1"><strong>The Branching Unit (<code class="language-plaintext highlighter-rouge">branch_comp.circ</code>)</strong></h4>

<p>The “Branching Unit” (skeleton provided in the <code class="language-plaintext highlighter-rouge">branch_comp.circ</code> file) should calculate the new value of the Program Counter (i.e. newPC) when the currently executing instruction is a branch or an jump to an “immediate”.</p>

<div class="bs-callout bs-callout-warning">
  <h4>WARNING</h4>

  <p>To implement the "<i>Branching Unit</i>", edit the <code>branch_comp.circ</code> file and <b>not</b> the <code>branch_com</code> virtual circuit included in <code>cpu_*.circ</code>. Note that each time you modify the <code>branch_comp.circ</code> circuit, you will have to close and open <code>cpu_*.circ</code> to apply the changes to your CPU.</p>
</div>

<p>Here is a summary of the inputs and outputs of this unit:</p>

<table class="styled-table">
<colgroup>
<col width="10%" />
<col width="10%" />
<col width="20%" />
<col width="60%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align:center">Name</th>
<th style="text-align:center">Direction</th>
<th style="text-align:center">Width (in bits)</th>
<th style="text-align:center">Description</th>
</tr>
</thead>
<tbody>

<tr>
<td style="text-align:center">inst</td>
<td style="text-align:center">Input</td>
<td style="text-align:center">32</td>
<td>The current executing instruction</td>
</tr>

<tr>
<td style="text-align:center">ximm</td>
<td style="text-align:center">Input</td>
<td style="text-align:center">32</td>
<td>The immediate returned by the <strong>Imm</strong> output of the “Immediate Unit”</td>
</tr>

<tr>
<td style="text-align:center">PC</td>
<td style="text-align:center">Input</td>
<td style="text-align:center">32</td>
<td>The value of the PC register</td>
</tr>

<tr>
<td style="text-align:center">zero</td>
<td style="text-align:center">Input</td>
<td style="text-align:center">1</td>
<td>The value returned by the <strong>zero</strong> output of the UAL</td>
</tr>

<tr>
<td style="text-align:center">BrUn</td>
<td style="text-align:center">Input</td>
<td style="text-align:center">2</td>
<td>Selector to process the ‘right’ branch/jump instruction</td>
</tr>

<tr>
<td style="text-align:center">newPC</td>
<td style="text-align:center">Output</td>
<td style="text-align:center">32</td>
<td>New value to transmit to the PC</td>
</tr>

<tr>
<td style="text-align:center">BrJmp</td>
<td style="text-align:center">Output</td>
<td style="text-align:center">1</td>
<td>Indicates whether the instruction being processed is a branch/jump in the code</td>
</tr>
</tbody>
</table>

<h4 id="the-immediate-unit-imm_gencirc-1"><strong>The Immediate Unit (<code class="language-plaintext highlighter-rouge">imm_gen.circ</code>)</strong></h4>

<p>The <code class="language-plaintext highlighter-rouge">imm_gen.circ</code> file provides a skeleton circuit for the “Immediate Unit”. this unit should generate the “Immediate” constants associated with I-type instructions as well as the constant values encoded by the “shmt” field for shift instructions. See the figure below for how each immediate should be formatted in your processor:</p>

<p><img src="/l2ado/static_files/images/immediat_extensions.png" alt="addi format" height="75%" width="75%" class="aligncenter" /></p>

<div class="bs-callout bs-callout-warning">
  <h4>WARNING</h4>

  <p>To implement the "<i>Immediate Unit</i>", edit the <code>imm_gen.circ</code> file and <b>not</b> the <code>imm_gen</code> virtual circuit included in <code>cpu_*.circ</code>. Note that each time you edit the <code>imm_gen.circ</code> circuit, you must close and open the <code>cpu_*.circ</code> file to apply the changes to your CPU.</p>
</div>

<p>Here is again a summary of the unit’s inputs and outputs:</p>

<table class="styled-table">
<colgroup>
<col width="10%" />
<col width="10%" />
<col width="20%" />
<col width="60%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align:center">Name</th>
<th style="text-align:center">Direction</th>
<th style="text-align:center">Width (in bits)</th>
<th style="text-align:center">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">inst</td>
<td style="text-align:center">Input</td>
<td style="text-align:center">32</td>
<td>The instruction currently being executed</td>
</tr>
<tr>
<td style="text-align:center">ImmSel</td>
<td style="text-align:center">Input</td>
<td style="text-align:center">2</td>
<td>A Selector to choose between different immediate generators</td>
</tr>
<tr>
<td style="text-align:center">Imm</td>
<td style="text-align:center">Output</td>
<td style="text-align:center">32</td>
<td>Generated Immediate</td>
</tr>
</tbody>
</table>

<h4 id="the-control-unit-control_logiccirc-1"><strong>The Control Unit (<code class="language-plaintext highlighter-rouge">control_logic.circ</code>)</strong></h4>

<p>The <code class="language-plaintext highlighter-rouge">control_logic.circ</code> file provides a skeleton circuit for the “Control Unit”. In order to properly execute each MIPS instruction, control signals play a very important role in a processor (and this project!).</p>

<p>Review the lecture slides in <a href="https://adminunivalger-my.sharepoint.com/:p:/g/personal/a_benhadid_univ-alger_dz/EVNM4EM0WgVFpYx1qH4Ng3sB8F7fBjJpNq45UjJkQTgyUA?e=uF8TJR">Datapath</a> and try traversing the data path with different types of instructions; when you encounter a MUX or other component, determine what selector or enable value you will need for that instruction.</p>

<div class="bs-callout bs-callout-danger">
  <h4>CAUTION</h4>

 <p>During the implementation of your "Control Unit", you can add extra input or output ports to <code>control_logic.circ</code>. You can also use the already provided ports (or a subset of them) depending on the needs of your implementation. That said, <b>do not modify or delete</b> any of the existing ports during this process.</p>
</div>

<p>There are two main approaches to implementing the “Control Unit” so that it can extract the “opcode/func” of an instruction and set the control signals appropriately. The first method is hardwired control. This is generally the preferred approach for RISC architectures such as MIPS and RISC-V. Here, to implement truth and <a href="https://fr.wikipedia.org/wiki/Table_de_Karnaugh">Karnaugh</a> tables corresponding to the identified functions, we will use the logic gates “AND”, “OR” and “NOT” with the various components that can be built from these gates (such as MUXes and DEMUXes).</p>

<p>The other way is to use a ROM (read-only memory). Each instruction implemented by a processor is mapped to an address in this memory where the command and control word for that instruction is stored. An address decoder therefore takes an instruction as input (i.e. the “opcode/func”) and identifies the address of the word containing the control signals for that instruction. This approach is common in CISC architectures such as Intel/AMD x86-64 processors and offers some flexibility since it can be easily reprogrammed by changing the ROM’s content.</p>

<div class="bs-callout bs-callout-warning">
  <h4>WARNING</h4>

  <p>To implement the "<i>Control Unit</i>", edit the <code>control_logic.circ</code> file and <b>not</b> the <code>control_logic</code> virtual circuit included in <code>cpu_*.circ</code>. Note that each time you edit the <code>control_logic.circ</code> circuit, you must close and open the <code>cpu_*.circ</code> file to apply the changes to your CPU.</p>
</div>

<h4 id="the-processor-cpucirc-1"><strong>The Processor (<code class="language-plaintext highlighter-rouge">cpu*.circ</code>)</strong></h4>

<p>The circuit in <code class="language-plaintext highlighter-rouge">cpu_*.circ</code> should implement the main data path and connect all the subcircuits together (ALU, Branching Unit, Control Unit, Immediate Unit, RAM and “Registers File”).</p>

<p>In Part A, you implemented a simple two-stage pipeline for your processor. You should realise that “data hazards” do NOT occur here because all data accesses happen in a single stage of the pipeline (i.e. the second stage).</p>

<p>However, since Part B of this project requires support for branch and jump instructions, there are some “control hazards” to deal with. In particular, the instruction immediately after a branch or jump statement is not necessarily executed if the branch is taken. This makes your task a bit more complex because by the time you realize that a branch or jump is being executed, you have already accessed the Instructions Memory and fetched the (possibly wrong) next instruction. So you must “roll back” the fetched instruction if the currently executing instruction will take the jump or branch.</p>

<p>You should only roll back the fetched instruction if a branch is taken (do not roll back otherwise). Instruction rollback MUST be accomplished by inserting a <code class="language-plaintext highlighter-rouge">nop</code> into the execution stage of the pipeline instead of the fetched instruction. Note that the instruction <code class="language-plaintext highlighter-rouge">sll $0, $0, 0</code> or the associated machine code <code class="language-plaintext highlighter-rouge">0x00000000</code> is a <code class="language-plaintext highlighter-rouge">nop</code> instruction for our processor.</p>

<p>Some things to consider for your implementation:</p>
<ul>
  <li>Will the PIF and PEX stages have the same or different PC values?</li>
  <li>Do you need to store the PC between different pipeline stages?</li>
  <li>Where to insert a possible <code class="language-plaintext highlighter-rouge">nop</code> in the instruction stream?</li>
  <li>What address should be requested next while the PEX stage is executing a <code class="language-plaintext highlighter-rouge">nop</code>? Is this different than normal?</li>
</ul>

<h3 id="testing-your-processor"><strong>Testing your Processor</strong></h3>

<p>Some consistency tests are provided for your processor in <code class="language-plaintext highlighter-rouge">tests/part_b/pipelined</code>. To run the tests, type:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>python3 test_runner.py part_b pipelined
</code></pre></div></div>
<p>You can view the <code class="language-plaintext highlighter-rouge">.s</code> (MIPS) and <code class="language-plaintext highlighter-rouge">.hex</code> (machine code) files used for testing in <code class="language-plaintext highlighter-rouge">tests/part_b/pipelined/inputs</code>.</p>

<p>You can also use the Python script <code class="language-plaintext highlighter-rouge">binary_to_hex_cpu.py</code>, as in task #3 of this project, to visualise and better interpret your results.</p>

<h2 id="submit-part-b-of-the-assignment">Submit part B of the assignment</h2>

<p>If you finished task #4, you have completed part B of the project… Congratulations on your new processor 🎉!</p>

<p>Make sure again that you have not moved/modified your I/O ports and that your circuits fit into the provided test harnesses without any problems.</p>

<p>For the evaluation of this part of the project, submit a <strong>zipped</strong> file containing all the circuits that you need to implement</p>

<p>(i.e. the <strong>alu.circ</strong>, <strong>regfile.circ</strong>, <strong>branch_comp.circ</strong>, <strong>imm_gen.circ</strong>, <strong>control_logic.circ</strong>, <strong>cpu_single.circ</strong> and <strong>cpu_pipelined.circ</strong>.circuits).</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>your_zipped_file.zip
 ├── alu.circ
 ├── regfile.circ
 ├── imm_gen.circ
 ├── branch_comp.circ
 ├── control_logic.circ
 ├── cpu_single.circ
 └── cpu_pipelined.circ
</code></pre></div></div>

<p>If you’re using the VM provided for this course to do this project, you can zip two files (or more) <strong>file1.circ</strong> and <strong>file2.circ</strong> into a file named <strong>your_zipped_file.zip</strong> with the following steps:</p>
<ol>
  <li>Open a terminal then, with the <code class="language-plaintext highlighter-rouge">cd</code> bash command, go to the folder containing the files <strong>file1.circ</strong> and <strong>file2.circ</strong>.</li>
  <li>Type the command:
    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>zip your_zipped_file.zip file1.circ file2.circ
</code></pre></div>    </div>
  </li>
</ol>

<p>Then submit the file <strong>your_file.zip</strong> for evaluation. For this part of the project, the Autograder uses the same test files already provided in the starter kit and some additional hidden tests!</p>

  </article>

</div>
      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <!--     <h2 class="footer-heading"></h2> -->
    <div class="footer-col-wrapper">
      <div class="footer-col  footer-col-1">

        <p class="text">
          02 rue Didouche Mourad<br />
16000 Alger<br />
 
        </p>
      </div>

      <div class="footer-col  footer-col-2">
        <ul class="social-media-list">


          

          

          

          

          
          




        </ul>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
