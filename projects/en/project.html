<!DOCTYPE html>
<html>

  <head>
  
    <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-5KMKZK4Z38"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-5KMKZK4Z38');
  </script>
  

  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title> MIPS mini-Processor - Computer Design / Fall 2024 </title>
  <meta name="description" content="IntroductionIn this project, you will implement a basic version of a MIPS processor. The assignment is organized into two parts: A and B.In part A (tasks 1 t...">
  
  <!--for gitlab pages -->
  

  <!-- automatic favicons -->
  

    <!--for github pages -->
  <link rel="shortcut icon" href="https://benhadid.github.io/l2ado/favicon.ico?"> 
  <!--for github-->

  <link rel="stylesheet" href="/l2ado/_css/main.css">
  <link rel="canonical" href="https://benhadid.github.io/l2ado/projects/en/project">
  <link rel="alternate" type="application/rss+xml" title="Computer Design / Fall 2024 - " href="https://benhadid.github.io/l2ado/feed.xml" />

  <link rel='stylesheet' id='open-sans-css'  href='//fonts.googleapis.com/css?family=Open+Sans%3A300italic%2C400italic%2C600italic%2C300%2C400%2C600&#038;subset=latin%2Clatin-ext&#038;ver=4.2.4' type='text/css' media='all' />
  <link href='https://fonts.googleapis.com/css?family=Titillium+Web:600italic,600,400,400italic' rel='stylesheet' type='text/css'>

  

  

  <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.2.0/css/all.css" integrity="sha384-hWVjflwFxL6sNzntih27bfxkr27PmbbK/iSvJ+a4+0owXq79v+lsFkW54bOGbiDQ" crossorigin="anonymous">

  <!-- MathJax -->
  <script type="text/javascript" async
    src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML">
  </script>
</head>


  <body>

    <header class="site-header">

  <div class="wrapper" style="z-index: 100;">
      <table><tr>
          <td><img width="75" src="/l2ado/_images/logo.png" valign="middle"></td>
          <td style="padding-left:10px;"><a class="schoolname" style="font-size: 15px;" class="site-title" href=""></a>
          <br/>      
          <span style="margin-top: -2px;margin-bottom: -10px;" class="site-title"><a href="/l2ado/" title="Computer Design / Fall 2024 - "><b>Computer Design</a></b></span>
          <br/>
          <span class="coursesemeter" style="font-size: 12px;font-weight: bold;margin-top: 10px;display: block;">Fall 2024</span>
          </td>
        </tr></table>

    <nav class="site-nav">

      <a href="#" class="menu-icon menu.open">
        <svg viewBox="0 0 18 15">
          <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
          <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
          <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
        </svg>
      </a>  

    <div class="trigger"><h1>Main Navigation</h1> <ul class="menu">
    
    <li>

      
      

      <a class="page-link" href="/l2ado/">
        <i class="fa fa-home fa-lg"></i> Home
      </a>

    </li>
    
    <li>

      
      

      <a class="page-link" href="/l2ado/schedule/">
        <i class="fas fa-calendar-alt"></i> Schedule
      </a>

    </li>
    
    <li>

      
      

      <a class="page-link" href="/l2ado/lectures/">
        <i class="fas fa-book-reader"></i> Lectures
      </a>

    </li>
    
    <li>

      
      

      <a class="page-link" href="/l2ado/discussions/">
        <i class="fas fa-user-graduate"></i> Seminars
      </a>

    </li>
    
    <li>

      
      

      <a class="page-link" href="/l2ado/labs/">
        <i class="fas fa-laptop-code"></i> Labs
      </a>

    </li>
    
    <li>

      
      

      <a class="page-link" href="/l2ado/quizzes/">
        <i class="fas fa-question-circle"></i> Quizzes
      </a>

    </li>
    
    <li>

      
      

      <a class="page-link" href="/l2ado/projects/">
        <i class="fas fa-user-graduate"></i> Projects
      </a>

    </li>
    
    <li>

      
      

      <a class="page-link" href="/l2ado/materials/">
        <i class="fas fa-book"></i> Resources
      </a>

    </li>
    
</ul>
 </div>  
    
    </nav>
  </div>

  <div></div>

  <div class="header-texture" style="height:100%; z-index: 0; position: absolute; top:0; right: 0; left: 0; background-image: url( /l2ado/_images/pattern.png );" >
  </div>

</header>


    <div class="page-content">
      <div class="wrapper">
        <div class="post">

  <header class="post-header">
    <h1 class="post-title">MIPS mini-Processor</h1>
    <p class="post-meta">Publié le 
      <!--
      Sunday 
      17/11/2024
      -->
      
      Sunday
      17
      
      November
      2024
    </p>
  </header>

  <div>
    
    <span style="font-weight: bold">Échéance : 
      <!-- 16/12/2024 -->

      
      Monday
      16
      
      December
      2024
  
    </span>
    

    
    <p style="font-weight: bold">Télécharger

      

      
      [<a href="/l2ado/static_files/projects/mipscpu.zip">démarrage</a>]
      

      

    </p>
    

  </div>

  <br />
  <article class="post-content">
    <h1 id="introduction">Introduction</h1>

<p>In this project, you will implement a basic version of a MIPS processor. The assignment is organized into two parts: A and B.</p>

<p>In part A (tasks 1 to 3), you are required to build an “Arithmetic Logic Unit (ALU)” and a “Register File” for a basic MIPS processor, as well as an implementation of a single-cycle datapath for executing <code class="language-plaintext highlighter-rouge">addi</code> instructions. In Part B (Task 4), you need to add other circuit components to your basic processor to produce an advanced version that will execute real MIPS instructions!</p>

<p>Start by downloading the startup file and unzipping its contents to the directory of your choice. Here is the list of files you must have:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>proj_starter
  ├── cpu
  │   ├── alu.circ
  │   ├── branch_comp.circ
  │   ├── control_logic.circ
  │   ├── cpu_pipelined.circ
  │   ├── cpu_single.circ
  │   ├── imm_gen.circ
  │   ├── mem.circ
  │   └── regfile.circ
  ├── harnesses
  │   ├── alu_harness.circ
  │   ├── regfile_harness.circ
  │   ├── run_pipelined.circ
  │   ├── run_single.circ
  │   ├── test_pipelined_harness.circ
  │   └── test_single_harness.circ
  ├── logisim-evolution.jar
  ├── tests
  │   ├── part_a
  │   │   ├── ...
  ╎   ╎   ╎
  │   │   └── ...
  │   └── part_b
  │       ├── ...
  ╎       ╎
  │       └── ...
  └── test_runner.py
</code></pre></div></div>

<div class="bs-callout bs-callout-danger">
 <b>NOTE</b>: Only files: <b>alu.circ</b>,  <b>branch_comp.circ</b>, <b>control_logic.circ</b>, <b>cpu_single.circ</b>, <b>cpu_pipelined.circ</b>, <b>imm_gen.circ</b> and <b>regfile.circ</b> should be modified and submitted for evaluation. The <b>mem.circ</b> circuit is already implemented for you.
</div>

<h1 id="part-a-initial-cpu-draft">Part A: Initial CPU draft</h1>

<h2 id="task-1-arithmetic-and-logic-unit-alu">Task 1: Arithmetic and Logic Unit (ALU)</h2>

<p>Your first task is to create an “Arithmetic and Logic Unit (ALU)” that supports all the operations required by our ISA instructions (see next section).</p>

<p>The provided skeleton file <code class="language-plaintext highlighter-rouge">alu.circ</code> shows that your ALU should have three inputs:</p>

<table class="styled-table">
<colgroup>
<col width="10%" />
<col width="10%" />
<col width="80%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align:center">Input name</th>
<th style="text-align:center">Width in bits</th>
<th style="text-align:center">Description</th>
</tr>
</thead>
<tbody>

<tr>
<td style="text-align:center"><strong>A</strong></td>
<td style="text-align:center">32</td>
<td>Data on input A for ALU operation</td>
</tr>

<tr>
<td style="text-align:center"><strong>B</strong></td>
<td style="text-align:center">32</td>
<td>Data on input B for ALU operation</td>
</tr>

<tr>
<td style="text-align:center"><strong>ALUSel</strong></td>
<td style="text-align:center">4</td>
<td>Selects which operation the ALU should perform (see below for list of operations with corresponding switch values).</td>
</tr>
</tbody>
</table>

<p>… and two outputs</p>

<table class="styled-table">
<colgroup>
<col width="10%" />
<col width="10%" />
<col width="80%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align:center">Output name</th>
<th style="text-align:center">Width in bits</th>
<th style="text-align:center">Description</th>
</tr>
</thead>
<tbody>

<tr>
<td style="text-align:center"><strong>Zero</strong></td>
<td style="text-align:center">1</td>
<td>This output is set when the difference between inputs <strong>A</strong> and <strong>B</strong> is zero</td>
</tr>

<tr>
<td style="text-align:center"><strong>Result</strong></td>
<td style="text-align:center">32</td>
<td>ALU operation result</td>
</tr>
</tbody>
</table>

<p><strong>NOTES</strong>: In the « <a href="https://adminunivalger-my.sharepoint.com/:p:/g/personal/a_benhadid_univ-alger_dz/Ec9qgFqCw19Cklw28Wz2IUwBNHpbcR6KWH64mnbx533juQ?e=nQI2Mr">RAM and CPU</a> » lecture slides, it is shown that and in order to build a multi-bit ALU (8 bits is given as an example), one needs to duplicate a 1-bit circuit and “link” these copies together to get an <em>n-bit</em> ALU. Good news! you don’t have to do that in this assignment… Logisim already does that for you! Simply choose the right bit width for your components’ inputs/outputs and your are done (see figure below).</p>

<p><img src="/l2ado/static_files/images/data_width.png" alt="data width" height="55%" width="55%" class="wp-caption aligncenter" /></p>

<p>The list below shows the operations (and the associated <strong>ALUSel</strong> values) that your ALU must be able to perform. You can use any Logisim block or integrated function to implement your circuits (<strong>There is no need to reimplement the adder, shifter or multiplier circuits! Use the circuit blocks provided by Logisim for this purpose</strong>).</p>

<table class="styled-table">
<colgroup>
<col width="10%" />
<col width="15%" />
<col width="30%" />
<col width="45%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align:center">ALUSel</th>
<th style="text-align:center">Instruction</th>
<th style="text-align:center">Description</th>
<th style="text-align:center">Note</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:left">  add</td>
<td> <code class="language-plaintext highlighter-rouge">Result = A + B</code></td>
<td></td>
</tr>

<tr>
<td style="text-align:center">1</td>
<td style="text-align:left">  and</td>
<td> <code class="language-plaintext highlighter-rouge">Result = A &amp; B</code></td>
<td></td>
</tr>

<tr>
<td style="text-align:center">2</td>
<td style="text-align:left">  or</td>
<td> <code class="language-plaintext highlighter-rouge">Result = A | B</code></td>
<td></td>
</tr>

<tr>
<td style="text-align:center">3</td>
<td style="text-align:left">  xor</td>
<td> <code class="language-plaintext highlighter-rouge">Result = A ^ B</code></td>
<td></td>
</tr>

<tr>
<td style="text-align:center">4</td>
<td style="text-align:left">  srl</td>
<td> <code class="language-plaintext highlighter-rouge">Result = A &gt;&gt; B</code></td>
<td>Unsigned right shift</td>
</tr>

<tr>
<td style="text-align:center">5</td>
<td style="text-align:left">  sra</td>
<td> <code class="language-plaintext highlighter-rouge">Result = A &gt;&gt; B</code></td>
<td>Signed right shift</td>
</tr>

<tr>
<td style="text-align:center">6</td>
<td style="text-align:left">  sll</td>
<td> <code class="language-plaintext highlighter-rouge">Result = A &lt;&lt; B</code></td>
<td></td>
</tr>

<tr>
<td style="text-align:center">7</td>
<td style="text-align:left">  —</td>
<td>    —</td>
<td>Not used</td>
</tr>

<tr>
<td style="text-align:center">8</td>
<td style="text-align:left">  slt</td>
<td> <code class="language-plaintext highlighter-rouge">Result = A &lt; B ? 1 : 0</code></td>
<td>Signed comparison</td>
</tr>

<tr>
<td style="text-align:center">9</td>
<td style="text-align:left">  sltu</td>
<td> <code class="language-plaintext highlighter-rouge">Result = A &lt; B ? 1 : 0</code></td>
<td>Unsigned comparison</td>
</tr>

<tr>
<td style="text-align:center">10</td>
<td style="text-align:left">  mul</td>
<td> <code class="language-plaintext highlighter-rouge">Result = (A * B)[31:0]</code></td>
<td>Signed mult (31..0)</td>
</tr>

<tr>
<td style="text-align:center">11</td>
<td style="text-align:left">  mulhu</td>
<td> <code class="language-plaintext highlighter-rouge">Result = (A * B)[63:32]</code></td>
<td>Unsigned mult</td>
</tr>

<tr>
<td style="text-align:center">12</td>
<td style="text-align:left">  sub</td>
<td> <code class="language-plaintext highlighter-rouge">Result = A - B</code></td>
<td></td>
</tr>

<tr>
<td style="text-align:center">13</td>
<td style="text-align:left">  —</td>
<td>    —</td>
<td>Not used</td>
</tr>

<tr>
<td style="text-align:center">14</td>
<td style="text-align:left">  mulh</td>
<td> <code class="language-plaintext highlighter-rouge">Result = (A * B)[63:32]</code></td>
<td>Signed mult (63..32)</td>
</tr>
</tbody>
</table>

<p><strong>Hints</strong> :</p>

<ul>
  <li>
    <p>The MIPS <code class="language-plaintext highlighter-rouge">add</code> operation is already implemented for you; feel free to use a similar structure to build the other functions.</p>
  </li>
  <li>
    <p>When implementing <code class="language-plaintext highlighter-rouge">mul</code> and <code class="language-plaintext highlighter-rouge">mulh</code>, note that the multiplication circuit block in Logisim has a “Carry Out” output that might be useful (the adder block also has this output, but you won’t needed it for this project).</p>
  </li>
  <li>
    <p>“Splitters” and “Bit extenders” could be very useful when implementing shift operations.</p>
  </li>
  <li>
    <p>Use tunnels extensively for the wirings! This will help you avoid crossing wires inadvertently (and causing unexpected errors).</p>
  </li>
  <li>
    <p>A multiplexer (MUX) can be useful in deciding which output of which component you want to transmit. I.e. process the inputs in all components simultaneously, then, depending on the chosen operation, select the correct output to transmit.</p>
  </li>
</ul>

<div class="bs-callout bs-callout-danger">
  <h4>CAUTION</h4>

  <p>You can make any changes you see fit to <b>alu.circ</b>, but the circuit's inputs and outputs must obey the behavior specified above. Additionally, your <b>alu.circ</b> must fit into the provided harness circuit <b>alu_harness.circ</b>. This means you should <b>AVOID</b> moving the inputs or outputs of the <b>alu.circ</b> circuit. If you need more space, use tunnels!</p>

  <p>If you create additional subcircuits, they must also be in <b>alu.circ</b> (i.e. you should not create new ".circ" files).</p>

  <p>To check that your modifications to <b>alu.circ</b> have not broken the input/output correspondences between your circuit and the harness, open the <b>alu_harness.circ</b> file in Logisim and make sure that there are no errors (i.e. no red or orange wires).</p>
</div>

<h3 id="testing-your-alu"><strong>Testing your ALU</strong></h3>

<p>A set of consistency tests for your ALU is provided in the <code class="language-plaintext highlighter-rouge">tests/part_a/alu</code> folder. Running the <code class="language-plaintext highlighter-rouge">test_runner.py</code> script (see below) will run the ALU tests and output the results to the <code class="language-plaintext highlighter-rouge">tests/part_a/alu/student_output</code> folder.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>python3 test_runner.py part_a alu
</code></pre></div></div>

<p>Also provided is a <code class="language-plaintext highlighter-rouge">binary_to_hex_alu.py</code> script that helps to convert the outputs of the ALU into a readable format. To use the script, type the following in the console:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">cd </span>tests/part_a/alu
<span class="nv">$ </span>python3 binary_to_hex_alu.py PATH_TO_OUTPUT_FILE
</code></pre></div></div>

<p>For example, to view the content of the reference output file <code class="language-plaintext highlighter-rouge">reference_output/alu-add-ref.out</code>, do the following:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">cd </span>tests/part_a/alu
<span class="nv">$ </span>python3 binary_to_hex_alu.py reference_output/alu-add-ref.out
</code></pre></div></div>

<p>To see the difference between your circuit output and the reference solution, put the readable outputs into new <code class="language-plaintext highlighter-rouge">.out</code> files and compare them with the <code class="language-plaintext highlighter-rouge">diff</code> command (cf. <code class="language-plaintext highlighter-rouge">man diff</code> in a console). For example, for the <code class="language-plaintext highlighter-rouge">alu-add</code> test, you can do:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">cd </span>tests/part_a/alu
<span class="nv">$ </span>python3 binary_to_hex_alu.py reference_output/alu-add-ref.out <span class="o">&gt;</span> reference.out
<span class="nv">$ </span>python3 binary_to_hex_alu.py student_output/alu-add-student.out <span class="o">&gt;</span> student.out
<span class="nv">$ </span>diff reference.out student.out
</code></pre></div></div>

<h2 id="task-2-registers-file">Task 2: <strong>Registers File</strong></h2>

<p>In this task, you will implement the <strong>$0 – $31</strong>  registers specified in the MIPS architecture. To ease the implementation, eight registers will be ‘exposed’ for testing and debugging purposes (see the list below). Please ensure that the values ​​of these registers are attached to the appropriate outputs in <code class="language-plaintext highlighter-rouge">regfile.circ</code>.</p>

<p>Your “<strong>Registers File</strong>” should be able to read from or write to the registers specified in a MIPS instruction without affecting other registers. There is one notable exception: your “<strong>Registers File</strong>” should <strong>NOT</strong> write to the <code class="language-plaintext highlighter-rouge">$0</code> register even if an instruction attempts to do so. As a reminder, register <code class="language-plaintext highlighter-rouge">$zero</code> should <strong>ALWAYS</strong> be set to <code class="language-plaintext highlighter-rouge">0</code>.</p>

<p>The ‘exposed’ registers and their corresponding numbers are indicated below.</p>

<table class="styled-table">
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align:center">Register's number</th>
<th style="text-align:center">Register's name</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:center">$a0</td>
</tr>
<tr>
<td style="text-align:center">8</td>
<td style="text-align:center">$t0</td>
</tr>
<tr>
<td style="text-align:center">9</td>
<td style="text-align:center">$t1</td>
</tr>
<tr>
<td style="text-align:center">10</td>
<td style="text-align:center">$t2</td>
</tr>
<tr>
<td style="text-align:center">16</td>
<td style="text-align:center">$s0</td>
</tr>
<tr>
<td style="text-align:center">17</td>
<td style="text-align:center">$s1</td>
</tr>
<tr>
<td style="text-align:center">29</td>
<td style="text-align:center">$sp</td>
</tr>
<tr>
<td style="text-align:center">31</td>
<td style="text-align:center">$ra</td>
</tr>
</tbody>
</table>

<p><br />
A skeleton circuit of the “<strong>Registers File</strong>” is provided in <code class="language-plaintext highlighter-rouge">regfile.circ</code>. The circuit has six inputs:</p>

<table class="styled-table">
<colgroup>
<col width="20%" />
<col width="15%" />
<col width="65%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align:center">Input's name</th>
<th style="text-align:center">Width (in bits)</th>
<th style="text-align:center">Description</th>
</tr>
</thead>

<tbody>

<tr>
<td style="text-align:left"> <strong>Clock</strong></td>
<td style="text-align:center">1</td>
<td>Input providing the clock. This signal can be routed to other subcircuits or directly connected to the clock inputs of the memory units in Logisim, but must not be connected to logic gates in any way (i.e. do not invert it, do not AND it, etc.)
</td>
</tr>

<tr>
<td style="text-align:left"> <strong>RegWEn</strong></td>
<td style="text-align:center">1</td>
<td>Enables data writing on the next rising edge of the clock</td>
</tr>

<tr>
<td style="text-align:left"> <strong>rs</strong></td>
<td style="text-align:center">5</td>
<td>Selects which register value is sent to output <strong>Read_Data_1</strong> (see below)</td>
</tr>

<tr>
<td style="text-align:left"> <strong>rt</strong></td>
<td style="text-align:center">5</td>
<td>Selects which register value is sent to output <strong>Read_Data_2</strong> (see below)</td>
</tr>

<tr>
<td style="text-align:left"> <strong>rd</strong></td>
<td style="text-align:center">5</td>
<td>Selects which register will be updated with the content from <strong>Write_Data</strong> on the next rising edge of the clock (provided that <strong>RegWEn</strong> is <strong>1</strong>)</td>
</tr>

<tr>
<td style="text-align:left"> <strong>Write_Data</strong></td>
<td style="text-align:center">32</td>
<td>Data to be written to the register selected by <strong>rd</strong> on the next rising edge of the clock (provided that <strong>RegWEn</strong> is <strong>1</strong>)</td>
</tr>
</tbody>
</table>

<p><br />
The “<strong>Registers File</strong>” in <code class="language-plaintext highlighter-rouge">regfile.circ</code> also has the following outputs:</p>

<table class="styled-table">
<colgroup>
<col width="20%" />
<col width="15%" />
<col width="65%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align:center">Output's name</th>
<th style="text-align:center">Width (in bits)</th>
<th style="text-align:center">Description</th>
</tr>
</thead>

<tbody>

<tr>
<td style="text-align:left"> <strong>Read_Data_1</strong></td>
<td style="text-align:center">32</td>
<td>Returns the content of register <strong>rs</strong></td>
</tr>

<tr>
<td style="text-align:left"> <strong>Read_Data_2</strong></td>
<td style="text-align:center">32</td>
<td>Returns the content of register <strong>rt</strong></td>
</tr>

<tr>
<td style="text-align:left"> Value <strong>ra</strong></td>
<td style="text-align:center">32</td>
<td>Returns the content of register <strong>ra</strong> (output used for debugging and testing)</td>
</tr>

<tr>
<td style="text-align:left"> Value <strong>sp</strong></td>
<td style="text-align:center">32</td>
<td>Returns the content of register <strong>$sp</strong> (output used for debugging and testing)</td>
</tr>

<tr>
<td style="text-align:left"> Value <strong>t0</strong></td>
<td style="text-align:center">32</td>
<td>Returns the content of register <strong>$t0</strong> (output used for debugging and testing)</td>
</tr>

<tr>
<td style="text-align:left"> Value <strong>t1</strong></td>
<td style="text-align:center">32</td>
<td>Returns the content of register <strong>$t1</strong> (output used for debugging and testing)</td>
</tr>

<tr>
<td style="text-align:left"> Value <strong>t2</strong></td>
<td style="text-align:center">32</td>
<td>Returns the content of register <strong>$t2</strong> (output used for debugging and testing)</td>
</tr>

<tr>
<td style="text-align:left"> Value <strong>s0</strong></td>
<td style="text-align:center">32</td>
<td>Returns the content of register <strong>$s0</strong> (output used for debugging and testing)</td>
</tr>

<tr>
<td style="text-align:left"> Value <strong>s1</strong></td>
<td style="text-align:center">32</td>
<td>Returns the content of register <strong>$s1</strong> (output used for debugging and testing)</td>
</tr>

<tr>
<td style="text-align:left"> Value <strong>a0</strong></td>
<td style="text-align:center">32</td>
<td>Returns the content of register <strong>$a0</strong> (output used for debugging and testing)</td>
</tr>
</tbody>
</table>

<p>The test outputs at the top of the circuit in <code class="language-plaintext highlighter-rouge">regfile.circ</code> are there for testing and debugging purposes. A real “Registers file” does not have these outputs! Make sure they are properly connected to the indicated registers because if they are not, the autograder will not be able to evaluate your assignment correctly.</p>

<p><strong>Hints</strong> :</p>

<ul>
  <li>
    <p>To avoid repetitive (and boring) work, start by creating a fully functional register and then use it as a template to build the others.</p>
  </li>
  <li>
    <p>It is recommended not to use the “<code class="language-plaintext highlighter-rouge">enable</code>” input on your MUXes. In fact, you can even disable this feature from the Logisim panel. It is also recommended to set the “three-state?” property to “<code class="language-plaintext highlighter-rouge">off</code>”.</p>
  </li>
  <li>
    <p>See step 2 of the <a href="/l2ado/labs/en/07_lab">Circuit Design with Logisim</a> lab to see what each input/output of a Logisim register corresponds to.</p>
  </li>
  <li>
    <p>As with the ALU task, multiplexers will be very useful (demultiplexers, too).</p>
  </li>
  <li>
    <p>What happens in the “<strong>Registers File</strong>” after a machine instruction is executed. Which values change? Which values stay the same? Registers are triggered by a clock - what does this mean?</p>
  </li>
  <li>
    <p>As a reminder, registers have an “<code class="language-plaintext highlighter-rouge">enable</code>” input as well as a “<code class="language-plaintext highlighter-rouge">clock</code>” input.</p>
  </li>
  <li>
    <p>What is the value of register <code class="language-plaintext highlighter-rouge">$0</code>?</p>
  </li>
</ul>

<div class="bs-callout bs-callout-danger">
  <h4>CAUTION</h4>

  <p>You can make any changes you want to <b>regfile.circ</b>, but the inputs and outputs of the circuit must follow the specifications given above. In addition, your <b>regfile.circ</b> must fit into the provided harness circuit <b>regfile_harness.circ</b>. This means that you must be careful <b>NOT</b> to move the inputs or outputs of the <b>regfile.circ</b> circuit. If you need more space, use tunnels!</p>
  
  <p>If you create additional subcircuits, they must also be in <b>regfile.circ</b> (i.e. do not create new .circ files).</p>

  <p>To verify that your changes have not broken the input/output mappings between your circuit and the harness, open the <b>regfile_harness.circ</b> file and make sure there are no wiring errors.</p>

</div>

<h3 id="testing-your-registers-file"><strong>Testing your “</strong>Registers File<strong>“</strong></h3>

<p>A set of validity tests are provided in the <code class="language-plaintext highlighter-rouge">tests/part_a/regfile</code> folder. Running the tester (see below) will also run the ALU tests and output the results to the <code class="language-plaintext highlighter-rouge">tests/part_a/regfile/student_output</code> folder.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>python3 test_runner.py part_a regfile
</code></pre></div></div>

<p>Also provided is a <code class="language-plaintext highlighter-rouge">binary_to_hex_regfile.py</code> script which works in a similar way to the <code class="language-plaintext highlighter-rouge">binary_to_hex_alu.py</code> script introduced in task #1.</p>

<h2 id="task-3-the-addi-instruction">Task 3: The <code class="language-plaintext highlighter-rouge">addi</code> instruction</h2>

<p>In this third and final task for Part A, you need to implement a Datapath that can execute <code class="language-plaintext highlighter-rouge">addi</code> instructions! You can implement other additional instructions if you wish, but you will only be graded if the <code class="language-plaintext highlighter-rouge">addi</code> instructions execute correctly for this part of the project.</p>

<h3 id="description-of-the-subtasks"><strong>Description of the subtasks</strong></h3>

<h4 id="the-memory-unit-memcirc"><strong>The Memory Unit (<code class="language-plaintext highlighter-rouge">mem.circ</code>)</strong></h4>

<p>The Memory Unit (found in <code class="language-plaintext highlighter-rouge">mem.circ</code>) is already implemented for you! However, the <code class="language-plaintext highlighter-rouge">addi</code> instruction does <strong>NOT</strong> use the Memory Unit, so you can ignore this component for part A.</p>

<h4 id="the-branching-unit-branch_compcirc"><strong>The Branching Unit (<code class="language-plaintext highlighter-rouge">branch_comp.circ</code>)</strong></h4>

<p>The <code class="language-plaintext highlighter-rouge">branch_comp.circ</code> file provides a skeleton circuit for the “Branching Unit”, but since the <code class="language-plaintext highlighter-rouge">addi</code> instruction does <strong>NOT</strong> use this unit, you can ignore it for part A.</p>

<h4 id="the-immediate-unit-imm_gencirc"><strong>The Immediate Unit (<code class="language-plaintext highlighter-rouge">imm_gen.circ</code>)</strong></h4>

<p>The <code class="language-plaintext highlighter-rouge">imm_gen.circ</code> file provides a skeleton circuit for the “Immediate Unit”. The <code class="language-plaintext highlighter-rouge">addi</code> instruction uses this unit. However, since this is the only instruction to be designed in this part of the project, you can simply lay out the wires necessary to generate the immediate associated with an <code class="language-plaintext highlighter-rouge">addi</code> instruction without worrying about other types of immediates. See the image below to see how the immediate of the <code class="language-plaintext highlighter-rouge">addi</code> instruction should be generated:</p>

<p><img src="/l2ado/static_files/images/immediat_addi.png" alt="addi format" height="75%" width="75%" class="aligncenter" /></p>

<div class="bs-callout bs-callout-warning">
  <h4>WARNING</h4>

  <p>To implement the "<i>Immediate Unit</i>", edit the <code>imm_gen.circ</code> file and <b>not</b> the <code>imm_gen</code> virtual circuit included in <code>cpu_*.circ</code>. Note that each time you edit the <code>imm_gen.circ</code> circuit, you must close and open the <code>cpu_*.circ</code> file to apply the changes to your CPU.</p>
</div>

<p>Here is a summary of the unit’s inputs and outputs:</p>

<table class="styled-table">
<colgroup>
<col width="10%" />
<col width="10%" />
<col width="20%" />
<col width="60%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align:center">Name</th>
<th style="text-align:center">Direction</th>
<th style="text-align:center">Width (in bits)</th>
<th style="text-align:center">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">inst</td>
<td style="text-align:center">Input</td>
<td style="text-align:center">32</td>
<td>The instruction currently being executed</td>
</tr>
<tr>
<td style="text-align:center">ImmSel</td>
<td style="text-align:center">Input</td>
<td style="text-align:center">2</td>
<td>A Selector to choose between different immediate generators</td>
</tr>
<tr>
<td style="text-align:center">Imm</td>
<td style="text-align:center">Output</td>
<td style="text-align:center">32</td>
<td>Generated Immediate</td>
</tr>
</tbody>
</table>

<h4 id="the-control-unit-control_logiccirc"><strong>The Control Unit (<code class="language-plaintext highlighter-rouge">control_logic.circ</code>)</strong></h4>

<p>The <code class="language-plaintext highlighter-rouge">control_logic.circ</code> file provides a skeleton circuit for the “Control Unit”. Designing your Control Unit will probably be your biggest challenge in Part B of this assignment. For Part A, since <code class="language-plaintext highlighter-rouge">addi</code> is the only instruction you will implement, you can simply assign a constant for each control signal. However, as you progress through your implementation of <code class="language-plaintext highlighter-rouge">addi</code>, think about where you should make future modifications/additions to support other instructions besides <code class="language-plaintext highlighter-rouge">addi</code>.</p>

<div class="bs-callout bs-callout-warning">
  <h4>WARNING</h4>

  <p>To implement the "<i>Control Unit</i>", edit the <code>control_logic.circ</code> file and <b>not</b> the <code>control_logic</code> virtual circuit included in <code>cpu_*.circ</code>. Note that each time you edit the <code>control_logic.circ</code> circuit, you must close and open the <code>cpu_*.circ</code> file to apply the changes to your CPU.</p>
</div>

<div class="bs-callout bs-callout-danger">
  <h4>CAUTION</h4>

 <p>During the implementation of your "Control Unit", you can add extra input or output ports to <code>control_logic.circ</code>. You can also use the already provided ports (or a subset of them) depending on the needs of your implementation. That said, <b>do not modify or delete</b> any of the existing ports during this process.</p>
</div>

<h4 id="the-processor-cpucirc"><strong>The Processor (<code class="language-plaintext highlighter-rouge">cpu*.circ</code>)</strong></h4>

<p>The starter kit also provides skeletons for your processor in <code class="language-plaintext highlighter-rouge">cpu*.circ</code>. For Part A of the project, your processor must be able to execute the <code class="language-plaintext highlighter-rouge">addi</code> instruction using a two-stage pipeline, with “Instruction Fetch (IF)” in the first stage and ( ID – EX – MEM – WB ) in the second stage. First, using your own implementations of the ALU and “<strong>Registers File</strong>” from task 1 &amp; 2, implement a single-cycle datapath (use the skeleton file <code class="language-plaintext highlighter-rouge">cpu_single.circ</code> for this mode of execution). Once your non-pipelined processor is working properly, you can make a copy of it into <code class="language-plaintext highlighter-rouge">cpu_pipelined.circ</code> and then modify your processor to produce a pipelined version.</p>

<p>Your processor will be inserted into the <code class="language-plaintext highlighter-rouge">test_single_harness.circ</code> harness (or <code class="language-plaintext highlighter-rouge">test_pipelined_harness.circ</code>, as appropriate) that contains the memory unit. This harness is in turn inserted into the <code class="language-plaintext highlighter-rouge">run_single.circ</code> (resp. <code class="language-plaintext highlighter-rouge">run_pipelined.circ</code>) test socket which provides the instructions (i.e. machine code) to the processor.</p>

<p>As an output, your processor will emit the address of an instruction to be read (i.e. fetched) from the instruction memory (IMEM). The fetched instruction is then transmitted to the processor in the appropriate input.</p>

<p>Also as an output, the processor will emit the address of a data to read from DMEM memory and a WRITE_ENABLE signal set to 1 if a store is requested instead. If data is read from DMEM, it is transmitted to the processor in the appropriate input (i.e. READ_DATA).</p>

<p>Essentially, the <code class="language-plaintext highlighter-rouge">test_*_harness.circ</code> and <code class="language-plaintext highlighter-rouge">run_*.circ</code> harnesses simulate a data (DMEM) and instruction (IMEM) memories respectively. Take the time to familiarise yourself with how they work to get an overall idea of the simulator.</p>

<div class="bs-callout bs-callout-danger">
  <h4>CAUTION</h4>

 <p>The <code>test_*_harness.circ</code> harnesses will be used by the consistency tests provided in the starter kit, so make sure that your <code>cpu_*.circ</code> processor fits properly into these sockets before testing your circuits, and especially when submitting your work for grading</p>

 <p>As with the ALU and the "**Registers File**" tasks, make sure <b>NOT</b> to move the input or output ports!</p>
</div>

<p>The processor has three inputs that come from the harness:</p>

<table class="styled-table">
<colgroup>
<col width="20%" />
<col width="15%" />
<col width="65%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align:center">Input's name</th>
<th style="text-align:center">Width (in bits)</th>
<th style="text-align:center">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">READ_DATA</td>
<td style="text-align:center">32</td>
<td>Data retrieved from DMEM memory at the address given in DMEM_ADDRESS (see below).</td>
</tr>
<tr>
<td style="text-align:center">INSTRUCTION</td>
<td style="text-align:center">32</td>
<td>The instruction fetched from IMEM memory at the address indicated by IMEM_ADDRESS (see below).</td>
</tr>
<tr>
<td style="text-align:center">CLOCK</td>
<td style="text-align:center">1</td>
<td>Input providing the clock. As already mentioned in the “<strong>Registers File</strong>” task, this signal can be routed to other subcircuits or directly connected to the clock inputs of the memory units in Logisim, but must not be connected to logic gates in any way (i.e. do not invert it, do not apply the “AND” gate on it, etc.).</td>
</tr>
</tbody>
</table>

<p><br /></p>

<p>…and provides the following outputs for the harness:</p>

<table class="styled-table">
<colgroup>
<col width="20%" />
<col width="15%" />
<col width="65%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align:center">Output's name</th>
<th style="text-align:center">Width (in bits)</th>
<th style="text-align:center">Description</th>
</tr>
</thead>
<tbody>

<tr>
<td style="text-align:center">ra</td>
<td style="text-align:center">32</td>      
<td>Returns the content of register <strong>ra</strong> (output used for debugging and testing)</td>
</tr>

<tr>
<td style="text-align:center">sp</td>
<td style="text-align:center">32</td>      
<td>Returns the content of register <strong>$sp</strong> (output used for debugging and testing)</td>
</tr>

<tr>
<td style="text-align:center">t0</td>
<td style="text-align:center">32</td>      
<td>Returns the content of register <strong>$t0</strong> (output used for debugging and testing)</td>
</tr>

<tr>
<td style="text-align:center">t1</td>
<td style="text-align:center">32</td>      
<td>Returns the content of register <strong>$t1</strong> (output used for debugging and testing)</td>
</tr>

<tr>
<td style="text-align:center">t2</td>
<td style="text-align:center">32</td>      
<td>Returns the content of register <strong>$t2</strong> (output used for debugging and testing)</td>
</tr>

<tr>
<td style="text-align:center">s0</td>
<td style="text-align:center">32</td>    
<td>Returns the content of register <strong>$s0</strong> (output used for debugging and testing)</td>
</tr>

<tr>
<td style="text-align:center">s1</td>
<td style="text-align:center">32</td>      
<td>Returns the content of register <strong>$s1</strong> (output used for debugging and testing)</td>
</tr>

<tr>
<td style="text-align:center">a0</td>
<td style="text-align:center">32</td>      
<td>Returns the content of register <strong>$a0</strong> (output used for debugging and testing)</td>
</tr>

<tr>
<td style="text-align:center">DMEM_ADDRESS</td>
<td style="text-align:center">32</td>      
<td>Data Memory (DMEM) address</td>
</tr>

<tr>
<td style="text-align:center">WRITE_DATA</td>
<td style="text-align:center">32</td>      
<td>Data to store into DMEM</td>      

</tr>

<tr>
<td style="text-align:center">WRITE_ENABLE</td>
<td style="text-align:center">4</td>      
<td>Enables or disables writting into DMEM</td>      
</tr>

<tr>
<td style="text-align:center">IMEM_ADDRESS</td>
<td style="text-align:center">32</td>      
<td>
This output holds the address of the instruction to retrieve from IMEM (in <code>run_*_harness.circ</code>). The fetched instruction is fed to the INSTRUCTION input port of the CPU</td>      
</tr>  
</tbody>
</table>

<h3 id="implementation-guidelines-single-cycle-processor">Implementation Guidelines: Single-Cycle Processor</h3>

<p>These guidelines will help you implement the <code class="language-plaintext highlighter-rouge">addi</code> instruction in your <code class="language-plaintext highlighter-rouge">cpu_single.circ</code> processor. Each section below contains questions to think about and important hints. It is necessary to read and understand each question before moving on to the next one! You can even check the answers by clicking ▶ if you are unable to find the answers yourself.</p>

<p>Recall the five steps of executing an instruction in a MIPS processor:</p>

<ol>
  <li>Instruction Fetch (IF)</li>
  <li>Instruction Decode (ID)</li>
  <li>Instruction Execution (EX)</li>
  <li>Read from (resp. Write to) Data Memory (MEM)</li>
  <li><em>Eventually</em> Write Back to the “<strong>Registers File</strong>” (WB)</li>
</ol>

<h4 id="step-1-instruction-fetch-if"><strong>Step 1: Instruction Fetch (IF)</strong></h4>

<p>The main question that arises at this stage is “How to get the current instruction?”. We have seen in lecture <a href="https://adminunivalger-my.sharepoint.com/:p:/g/personal/a_benhadid_univ-alger_dz/EVNM4EM0WgVFpYx1qH4Ng3sB8F7fBjJpNq45UjJkQTgyUA?e=uF8TJR">Datapath</a> that instructions are stored in the Instructions Memory (IMEM), and each of these instructions is accessible via an address.</p>

<fieldset class="tips">
<legend style="color: DarkSlateGrey">Hints</legend>

<details close="">
<summary>
1. Which file in the starter kit implements the Instructions Memory? How is it connected to the processor?
</summary>
<p style="color: DarkSlateGrey">
The instructions Memory (IMEM) is the ROM module in the <code class="language-plaintext highlighter-rouge">run_*.circ</code> files. These files provide an input to your CPU named <code class="language-plaintext highlighter-rouge">INSTRUCTION</code> and recieve an output from your CPU. This output is called <code class="language-plaintext highlighter-rouge">IMEM_ADDRESS</code> in <code class="language-plaintext highlighter-rouge">cpu_*.circ</code> files and it is called <code class="language-plaintext highlighter-rouge">FETCH_ADDR</code> in <code class="language-plaintext highlighter-rouge">run_*.circ</code>.
</p>
</details>
 
<details close="">
<summary>
2. In <code class="language-plaintext highlighter-rouge">cpu*.circ</code> circuits, how would changing the address passed through <code class="language-plaintext highlighter-rouge">IMEM_ADDRESS</code> affect the <code class="language-plaintext highlighter-rouge">INSTRUCTION</code> input?
</summary>
<p style="color: DarkSlateGrey">
The instruction that <code class="language-plaintext highlighter-rouge">run_*.circ</code> passes to the processor must be the instruction fetched from the <code class="language-plaintext highlighter-rouge">IMEM_ADDRESS</code> (or <code class="language-plaintext highlighter-rouge">FETCH_ADDR</code>) address in Instructions memory (IMEM).
</p>
</details>

<details close="">
<summary>
3. How to check if <code class="language-plaintext highlighter-rouge">IMEM_ADDRESS</code> is correct?
</summary>
<p style="color: DarkSlateGrey">
<code class="language-plaintext highlighter-rouge">IMEM_ADDRESS</code> is the address of the currently executing instruction. This address is stored in the <code class="language-plaintext highlighter-rouge">PC</code> register. For this project, the <code class="language-plaintext highlighter-rouge">PC</code> register will start at the value <code class="language-plaintext highlighter-rouge">0</code> because this is the default value in a Logisim register.
</p>
</details>

<details close="">
<summary>
4. How does the <code class="language-plaintext highlighter-rouge">PC</code> register change for codes that do not have jump or branch instructions?
</summary>
<p style="color: DarkSlateGrey">
Since the <code class="language-plaintext highlighter-rouge">PC</code> register contains the address of the currently executing instruction, one must increment this register by the size of one instruction to advance to the next instruction. This means that the <code class="language-plaintext highlighter-rouge">PC</code> will typically increase by 4 (assuming the current instruction is not a jump or a branch).
</p>
</details>
</fieldset>

<p><br /></p>

<p>A simple implementation of the <code class="language-plaintext highlighter-rouge">PC</code> register is provided in <code class="language-plaintext highlighter-rouge">cpu_*.circ</code>. This implementation does not take into account the jump and branch instructions that you will need to implement in Part B of this project. But for now, only <code class="language-plaintext highlighter-rouge">addi</code> instructions need to be handled by the processor.</p>

<p>Recall however that you will eventually implement a 2-stage pipelined processor, so that the IF stage is separated from the remaining stages. What circuit separates the different stages in a pipeline? More precisely, what circuit separates IF from the next stage? Is there anything you need to add here?</p>

<p><br /></p>

<h4 id="step-2-instruction-decoder-id"><strong>Step 2: Instruction Decoder (ID)</strong></h4>

<p>Once the “IF” stage is implemented, the fetched instruction should be available at the <code class="language-plaintext highlighter-rouge">INSTRUCTION</code> input port of the processor. The second step is therefore to decompose this instruction in order to determine what to do with it in the subsequent execution steps.</p>

<fieldset class="tips">
<legend style="color: DarkSlateGrey">Hints</legend>

<details close="">
<summary>
1. What type of instruction is <code class="language-plaintext highlighter-rouge">addi</code>? What are the different bit fields associated with this type of instruction? What are their bit ranges?
</summary>
<p style="color: DarkSlateGrey">
<code class="language-plaintext highlighter-rouge">addi</code> is a “<strong>type I</strong>” instruction. The bit fields (and ranges) are: - <code class="language-plaintext highlighter-rouge">opcode [31-26]</code> - <code class="language-plaintext highlighter-rouge">rs [25-21]</code> - <code class="language-plaintext highlighter-rouge">rt [20-16]</code> - <code class="language-plaintext highlighter-rouge">imm [15-0]</code>.</p>
</details>

<details close="">
<summary>
2. In Logisim, what tool would do you use to separate different groups of bits?
</summary>
<p style="color: DarkSlateGrey">
Splitters!
</p>
</details>
<p>
<br />
    3. Implement the “Instruction decoding” step of the <code class="language-plaintext highlighter-rouge">INSTRUCTION</code> input. You should use tunnels to label and group the bits.
</p>
<details close="">
<summary>
4. In an <code class="language-plaintext highlighter-rouge">addi</code> instruction, we need to read the content of a register in the “<strong>Registers File</strong>” and then add it to a constant. Which field of the Instruction code should be connected to the “<strong>Registers File</strong>”? To which input of the “<strong>Registers File</strong>” should it be connected?
</summary>
<p style="color: DarkSlateGrey">
The <code class="language-plaintext highlighter-rouge">rs</code> field must be connected to the “read register 1” input of the “<strong>Registers File</strong>”.
</p>
</details>
<!-- Le résultat de l'opération sera plus tard réinscrit dans le registre destination spécifié dans l'instruction.-->
<p>
<br />
    5. Implement the reading step from the “<strong>Registers File</strong>”. Don’t forget to integrate your “<strong>Registers File</strong>” from task #2. Don’t forget to connect the clock!
</p>
<details close="">
<summary>
6. How could the “Immediate Unit” (<code class="language-plaintext highlighter-rouge">imm_gen.circ</code>) be useful here?
</summary>
<p style="color: DarkSlateGrey">
For the <code class="language-plaintext highlighter-rouge">addi</code> instruction, the “Immediate Unit” takes 16 bits of the instruction as input and produces a 32-bit signed immediate. You need to implement this logic in the “Immediate Unit”!
</p>
</details>
</fieldset>
<p><br /></p>

<h4 id="step-3-executing-the-instruction-ex"><strong>Step 3: Executing the instruction (EX)</strong></h4>

<p>The execution stage is where the computation is done.</p>

<fieldset class="tips">
<legend style="color: DarkSlateGrey">Hints</legend>
<details close="">
<summary>
1. For the <code class="language-plaintext highlighter-rouge">addi</code> instruction, what would be the input data to your ALU?
</summary>
<p style="color: DarkSlateGrey">
Read Data 1 (rs) from the “<strong>Registers File</strong>” and the constant produced by the “Immediate Unit”.
</p>
</details>

<details close="">
<summary>
2. What is the purpose of <code class="language-plaintext highlighter-rouge">ALUSel</code>?
</summary>
<p style="color: DarkSlateGrey">
It selects what operation the ALU should perform.
</p>
</details>

<details close="">
<summary>
3. Since we are implementing the <code class="language-plaintext highlighter-rouge">addi</code>instruction only for now, it is possible for to just paste a constant for <code class="language-plaintext highlighter-rouge">ALUSel</code>. Why would this be discouraged if you take into consideration that other instructions will be implemented in the future?
</summary>
<p style="color: DarkSlateGrey">
When implementing more instructions, <code class="language-plaintext highlighter-rouge">ALUSel</code> might change depending on the requested operation. So, we need some kind of circuit that changes the value of <code class="language-plaintext highlighter-rouge">ALUSel</code> depending on the instruction being executed.
</p>
</details>
<p>
<br />
   4. Integrate the ALU developed in task #1 into your processor and connect the inputs correctly. Do you need to connect a clock? Why or why not?
</p>
</fieldset>
<p><br /></p>

<h4 id="step-4-read-fromwrite-to-data-memory-mem"><strong>Step 4: Read from/write to Data Memory (MEM)</strong></h4>

<p>The <strong>MEM</strong> step is where the Data Memory (DMEM) can be modified using data store instructions or read using data load instructions. Since the <code class="language-plaintext highlighter-rouge">addi</code> instruction does not need accesss to DMEM, we can ignore this part of the circuit for now and continue with the next step of execution.</p>

<h4 id="step-5-writing-back-to-the-registers-file-wb"><strong>Step 5: Writing back to the “</strong>Registers File<strong>” (WB)</strong></h4>

<p>The WriteBack step is required when the results of an operation are to be saved to a register in the “<strong>Registers File</strong>”.</p>

<fieldset class="tips">
<legend style="color: DarkSlateGrey">Hints</legend>
<details close="">
<summary>
1. Does the <code class="language-plaintext highlighter-rouge">addi</code> instruction require a save to a register?
</summary>
<p style="color: DarkSlateGrey">
YES! The <code class="language-plaintext highlighter-rouge">addi</code> instruction takes the output of an addition computation from the ALU and writes the result to a register in the “<strong>Registers File</strong>”.
</p>
</details>
<p>
<br />
    2. We have seen in the “<a href="https://adminunivalger-my.sharepoint.com/:p:/g/personal/a_benhadid_univ-alger_dz/EVNM4EM0WgVFpYx1qH4Ng3sB8F7fBjJpNq45UjJkQTgyUA?e=uF8TJR">Datapath</a>” lecture that the <strong>WB</strong> step is used for writing 
 the output of the <strong>ALU</strong> or <strong>DMEM</strong> to a register in the “<strong>Registers File</strong>”. So let’s create the writing phase in this perspective even if we are only interested in the <code class="language-plaintext highlighter-rouge">addi</code> instruction for now. Since only one data at a time can be written to the “<strong>Registers File</strong>”, we must use a MUX to choose which of the outputs of the ALU or <strong>DMEM</strong> (<code class="language-plaintext highlighter-rouge">READ_DATA</code>) to transmit. Later, when you implement other instructions in part B of the project, you should review the implementation of this multiplexer to handle more cases.
</p>
<details close="">
<summary>
3. What should the MUX selection input be? What does the input depend on?
</summary>
<p style="color: DarkSlateGrey">
There should be three inputs for the MUX to choose from: (1) ALU, (2) DMEM (<code class="language-plaintext highlighter-rouge">READ_DATA</code>), and (3) PC + 4 (when will we need this one?). The control signal that determines which of these inputs is transmitted to the “<strong>Registers File</strong>” is called <code class="language-plaintext highlighter-rouge">WBSel</code>. For now, <code class="language-plaintext highlighter-rouge">WBSel</code> should have only one value (i.e. a constant) - whatever you chose for <code class="language-plaintext highlighter-rouge">addi</code>.
</p>
</details>
<details close="">
<summary>
4. Now that the MUX inputs are fixed, we need to plug its output somewhere! Where should it be connected to?
</summary>
<p style="color: DarkSlateGrey">
The output of the MUX carries the data you want to write to the “<strong>Registers File</strong>”, so it must be connected to the <code class="language-plaintext highlighter-rouge">Write Data</code> input of the “<strong>Registers File</strong>”.
</p>
</details>
<p>
<br />
    5. There are two more inputs on the “<strong>Registers File</strong>” that are important for writing data: <code class="language-plaintext highlighter-rouge">RegWEn</code> and <code class="language-plaintext highlighter-rouge">Write Register</code>. One of them will need to be retrieved during the instruction decode (ID) stage and the other one is a control signal. Finish implementing the <strong>WB</strong> stage for the <code class="language-plaintext highlighter-rouge">addi</code> instruction by setting these inputs correctly.
</p>
</fieldset>

<p>If you did all the steps correctly, you should have a single-cycle processor (<code class="language-plaintext highlighter-rouge">cpu_single.circ</code>) that works for <code class="language-plaintext highlighter-rouge">addi</code> instructions 🎉. Run <code class="language-plaintext highlighter-rouge">python3 test_runner.py part_a addi_single</code> from the terminal and check if your implementation works correctly!</p>

<h3 id="guidelines-for-a-two-stage-pipelined-processor">Guidelines for a two-stage pipelined processor</h3>

<p>Now it’s time to turn your single-cycle processor into a “pipelined” version! For this project, you need to implement a two-stage pipeline, which is still conceptually similar to the five-stage pipeline introduced in the “<a href="https://adminunivalger-my.sharepoint.com/:p:/g/personal/a_benhadid_univ-alger_dz/EU2Y9AtLhfJEkVic7ZqP7XkBwH4IwsEtxaVP-rn6ipp6aw?e=mpLjak">Pipelining</a>” lecture. The two stages to implement are:</p>

<ol>
  <li>Instruction Fetch (PIF): An instruction is fetched from Instructions Memory (IMEM).</li>
  <li>Instruction Execution (PEX): The instruction is decoded, executed, and validated (i.e. result saved). This is a combination of the last four stages (ID, EX, MEM, and WB) in a single-cycle processor.</li>
</ol>

<p>Since the instruction decoding and execution steps are handled in the PEX stage, <strong>your pipelined <code class="language-plaintext highlighter-rouge">addi</code> processor will be more or less identical to its « single-cycle » version, except for the one clock cycle startup latency</strong>. We will, however, apply the pipeline design rules seen in class in order to prepare our processor for Part B of this project.</p>

<p>Some points to consider for a two-stage pipeline design:</p>

<ul>
  <li>
    <p>Will the PIF and PEX stages have the same or different <code class="language-plaintext highlighter-rouge">PC</code> values?</p>
  </li>
  <li>
    <p>Do you need to store the <code class="language-plaintext highlighter-rouge">PC</code> between pipeline stages?</p>
  </li>
</ul>

<p>On the other hand, we will get a bootstrapping problem here: during the first execution cycle, the registers introduced between the different pipeline stages are initially (empty), but the void does not exist in hardware. How will we handle this first dummy instruction? What would the void correspond to in our processor? I.e. to what value should we initialise the newly introduced registers in order to “do nothing” during the first execution cycle?</p>

<p>Sometimes Logisim automatically resets the registers to zero at startup (or on reset); which, for our bootstrapping problem, will simulate a <code class="language-plaintext highlighter-rouge">nop</code> instruction! Thanks Logisim! Don’t forget to go to « <strong>Simulate | Reset Simulation</strong> » to reset your processor.</p>

<p>After you have « pipelined » your processor, you should be able to pass the <code class="language-plaintext highlighter-rouge">python3 test_runner.py part_a addi_pipelined</code> tests. Note that the previous <code class="language-plaintext highlighter-rouge">python3 test_runner.py part_a addi_single</code> test should fail now (why? Check the benchmark outputs for each test and think about the effects of the pipeline registers on the different execution stages).</p>

<!--{:start="7"}-->

<h2 id="understanding-the-tests">Understanding the tests</h2>

<p>The cpu tests included in the startup circuits are copies of the <code class="language-plaintext highlighter-rouge">run_*.circ</code> files and contain instructions that have been previously loaded into the Instructions Memory (IMEM). When Logisim is run from the <a href="https://www.baillifard.com/logisim/en/html/guide/verify/index.html">command line</a>, your circuit is automatically started. Execution is clocked, your processor’s <code class="language-plaintext highlighter-rouge">PC</code> is updated, the fetched instruction is processed, and the values ​​of each of the test circuit’s outputs are printed to the console.</p>

<p>Consider the <code class="language-plaintext highlighter-rouge">addi-pipelined</code> test folder as an example. <code class="language-plaintext highlighter-rouge">Instruction Memory</code> in the <code class="language-plaintext highlighter-rouge">cpu-addi.circ</code> circuit contains three <code class="language-plaintext highlighter-rouge">addi</code> instructions (<code class="language-plaintext highlighter-rouge">addi $t0, $0, 5</code>, <code class="language-plaintext highlighter-rouge">addi $t1, $t0, 7</code> and <code class="language-plaintext highlighter-rouge">addi $s0, $t0, 9</code>). Open the <code class="language-plaintext highlighter-rouge">tests/part_a/addi_pipelined/cpu-addi.circ</code> file in Logisim and take a closer look at the different parts of the test circuit. At the top, you will see where the <code class="language-plaintext highlighter-rouge">test_harness</code> is connected to for the debug outputs. Initially, these outputs are all <code class="language-plaintext highlighter-rouge">UUUUU</code>, but this should not be the case once your <code class="language-plaintext highlighter-rouge">cpu_pipelined.circ</code> circuit is implemented.</p>

<p>The <code class="language-plaintext highlighter-rouge">test_harness</code> socket takes as input the clock signal <code class="language-plaintext highlighter-rouge">clk</code> and the <code class="language-plaintext highlighter-rouge">Instruction</code> provided by the <code class="language-plaintext highlighter-rouge">Instruction Memory</code> module. As output, the socket transmits (for display) the values ​​of the debug registers from your processor circuit <code class="language-plaintext highlighter-rouge">cpu_pipelined.circ</code>. The additional output <code class="language-plaintext highlighter-rouge">fetch_addr</code> holds the address of the next instruction to fetch from <code class="language-plaintext highlighter-rouge">Instruction Memory</code>.</p>

<div class="bs-callout bs-callout-danger">
  <h4>CAUTION</h4>
  <p>
  Do <b>not move</b> any of your processor's I/O and <b> do not </b> add additional I/O. This will change the shape of the processor's subcircuit in and therefore the connections with the <code>test_harness</code> module may not work properly anymore.
  </p>
</div>

<p>Under the <code class="language-plaintext highlighter-rouge">test_harness</code> module, you will see the <code class="language-plaintext highlighter-rouge">Instruction Memory</code> containing the hex machine code of the three <code class="language-plaintext highlighter-rouge">addi</code> instructions under test (0x20080005, 0x21090007, 0x21100009). The <code class="language-plaintext highlighter-rouge">Instruction Memory</code> takes an address (i.e. <code class="language-plaintext highlighter-rouge">fetch_addr</code>) and outputs the instruction stored at that address. In MIPS, <code class="language-plaintext highlighter-rouge">fetch_addr</code> is a 32-bit value, but since Logisim limits the size of ROM units to \(2^{24}\), we use a splitter to retrieve 24 bits of <code class="language-plaintext highlighter-rouge">fetch_addr</code> (i.e. the bit range <code class="language-plaintext highlighter-rouge">2..25</code>, ignoring the lowest two bits).</p>

<fieldset class="tips">
<legend style="color: DarkSlateGrey">Hint</legend>
<details close="">
<summary>
Why are the two LSB bits of the <code class="language-plaintext highlighter-rouge">fetch_addr</code> address ignored?
</summary>
<p style="color: DarkSlateGrey">
In MIPS, an instruction is 32-bit in width and occupy thus four bytes in memory stored at an address that is multiple of 4 (i.e. the 2 LSBs of <code class="language-plaintext highlighter-rouge">fetch_addr</code> are always zeros). Besides, instructions are fetched word-by-word from <code class="language-plaintext highlighter-rouge">Instruction Memory</code>. So, we need to convert <code class="language-plaintext highlighter-rouge">fetch_addr</code> which is a byte address, to a word address by removing the two lowest bits.
</p>
</details>
</fieldset>

<p>So, when the test circuit is powered on, each tick of the clock drives the execution of the <code class="language-plaintext highlighter-rouge">test_harness</code> module and increments the counter called <code class="language-plaintext highlighter-rouge">Time_Step</code> (this counter is located to the right of the <code class="language-plaintext highlighter-rouge">Instruction Memory</code>, zoom out in Logisim if it is not visible on your screen).</p>

<p>At each tick of the clock, a <a href="https://www.baillifard.com/logisim/en/html/guide/verify/index.html">command line</a> execution of Logisim will print the values ​​of each of your debug outputs to the terminal. The clock will continue to run until <code class="language-plaintext highlighter-rouge">Time_Step</code> equals the stopping constant for this test circuit (for this particular test file, the stopping constant is 4).</p>

<p>Finally, we compare the output of your circuit to the reference  (i.e. expected) output; if your circuit output is different, the test will fail.</p>

<h3 id="the-addi-tests">The <code class="language-plaintext highlighter-rouge">addi</code> tests</h3>

<p>The “test runner” provided in the starter kit can be used to run two set of tests for the <code class="language-plaintext highlighter-rouge">addi</code> instruction: a set of tests for the single-cycle processor and a set of tests for the pipelined processor. You can run the test script for the “pipelined” version with the following command (replace <code class="language-plaintext highlighter-rouge">pipelined</code> with <code class="language-plaintext highlighter-rouge">single</code> to test the “single-cycle” version):</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>python3 test_runner.py part_a addi_pipelined <span class="c"># For a pipelined CPU</span>
</code></pre></div></div>
<p>You can see the <code class="language-plaintext highlighter-rouge">.s</code> (MIPS) and <code class="language-plaintext highlighter-rouge">.hex</code> (machine code) files used for the test in <code class="language-plaintext highlighter-rouge">tests/part_a/addi_pipelined/inputs</code>.</p>

<p>To make it easier to interpret your output, a Python script (<code class="language-plaintext highlighter-rouge">binary_to_hex_cpu.py</code>) is also included. This script works like the <code class="language-plaintext highlighter-rouge">binary_to_hex_alu.py</code> and <code class="language-plaintext highlighter-rouge">binary_to_hex_regfile.py</code> scripts used in the ALU and in the “Registers File” design tasks (i.e. Tasks #1 and #2). To use the script, run:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">cd </span>tests/part_a/addi_pipelined
<span class="nv">$ </span>python3 binary_to_hex_cpu.py student_output/CPU-addi-pipelined-student.out
</code></pre></div></div>

<p>or, to view the reference output (i.e. what your circuit should print), run:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">cd </span>tests/part_a/addi_pipelined
<span class="nv">$ </span>python3 binary_to_hex_cpu.py reference_output/CPU-addi-pipelined-ref.out
</code></pre></div></div>

<h2 id="submit-part-a-of-the-assignment">Submit Part A of the assignment</h2>

<p>Make sure again that you have not moved/modified your I/O ports and that your circuits fit into the provided test harnesses without any problems.</p>

<p>For the evaluation of this part of the project, you must submit a <strong>zipped</strong> file containing all the circuits that you need to implement (i.e. the <strong>alu.circ</strong>, <strong>regfile.circ</strong>, <strong>imm_gen.circ</strong>, <strong>control_logic.circ</strong> and <strong>cpu_*.circ</strong> circuits).</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>your_zipped_file.zip
 ├── alu.circ
 ├── regfile.circ
 ├── imm_gen.circ
 ├── control_logic.circ
 ├── cpu_single.circ
 └── cpu_pipelined.circ
</code></pre></div></div>

<p>If you’re using the VM provided for this course to do this project, you can zip two files (or more) <strong>file1.circ</strong> and <strong>file2.circ</strong> into a file named <strong>your_zipped_file.zip</strong> with the following steps:</p>
<ol>
  <li>Open a terminal then, with the <code class="language-plaintext highlighter-rouge">cd</code> bash command, go to the folder containing the files <strong>file1.circ</strong> and <strong>file2.circ</strong>.</li>
  <li>Type the command:
    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>zip your_zipped_file.zip file1.circ file2.circ
</code></pre></div>    </div>
  </li>
</ol>

<p>Then submit the file <strong>your_file.zip</strong> for evaluation. For this part of the project, the Autograder uses the same test files already provided in the starter kit. I.e. there are no hidden tests !</p>

<p><br />
<br /></p>

<hr />

<p><br /></p>
<h1 id="partie-b--conception-de-version-avancée-du-processeur">Partie B : Conception de version avancée du processeur</h1>

<h2 id="tâche-4--plus-dinstructions">Tâche 4 : Plus d’instructions</h2>

<p>Dans la tâche n°3, vous avez implémenté un processeur basique en pipeline à deux étages capable d’exécuter les instructions <code class="language-plaintext highlighter-rouge">addi</code>. Maintenant, vous allez renforcer votre processeur en implémentant plus d’instructions !</p>

<h3 id="larchitecture-du-jeu-dinstructions-isa">L’architecture du jeu d’instructions (ISA)</h3>

<p>Votre implémentation du CPU sera évaluée uniquement sur les instructions énumérées ci-dessous. Votre processeur doit prendre en charge ces instructions, mais n’hésitez pas à implémenter des instructions supplémentaires si cela vous tente ! Assurez-vous, cependant, qu’aucune de vos instructions additionnelles n’affecte le fonctionnement des instructions spécifiées ici. L’implémentation d’instructions supplémentaires n’affectera pas votre score pour ce projet.</p>

<table class="styled-table">
<colgroup>
<col width="15%" />
<col width="30%" />
<col width="32%" />
<col width="8%" />
<col width="15%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align:center">Instruction</th>
<th style="text-align:center">Description</th>
<th style="text-align:center">Opération</th>
<th style="text-align:center">Type</th>
<th style="text-align:center">Opcode/Func</th>

</tr>
</thead>
<tbody>

<tr>
<td style="text-align:left"><strong>add</strong> rd, rs, rt</td>
<td style="text-align:left">Addition</td>
<td style="text-align:left">R[rd] ← R[rs] + R[rt]</td>
<td style="text-align:center">R</td>
<td style="text-align:left"> 0x0 / 0x20</td>
</tr>

<tr>
<td style="text-align:left"><strong>sub</strong> rd, rs, rt</td>
<td style="text-align:left">Soustraction</td>
<td style="text-align:left">R[rd] ← R[rs] - R[rt]</td>
<td style="text-align:center">R</td>
<td style="text-align:left"> 0x0 / 0x22</td>
</tr>

<tr>
<td style="text-align:left"><strong>addi</strong> rt, rs, imm</td>
<td style="text-align:left">Addition<br />(2<sup>ème</sup> param. : immédiat)</td>
<td style="text-align:left">R[rt] ← R[rs] + imm<sub>±</sub></td>
<td style="text-align:center">I</td>
<td style="text-align:left"> 0x8</td>
</tr>

<tr>
<td style="text-align:left"><strong>mul</strong> rd, rs, rt</td>
<td style="text-align:left">Multiplication</td>
<td style="text-align:left">R[rd] ← (R[rs] x R[rt])[31:0]</td>
<td style="text-align:center">R</td>
<td style="text-align:left"> 0x0 / 0x18</td>
</tr>

<tr>
<td style="text-align:left"><strong>mulh</strong> rd, rs, rt</td>
<td style="text-align:left">Multiplication</td>
<td style="text-align:left">R[rd] ← (R[rs] x R[rt])[63:32]</td>
<td style="text-align:center">R</td>
<td style="text-align:left"> 0x0 / 0x10</td>
</tr>

<tr>
<td style="text-align:left"><strong>mulhu</strong> rd, rs, rt</td>
<td style="text-align:left">Multiplication;<br />(params non signés)</td>
<td style="text-align:left">R[rd] ← (R[rs] x R[rt])[63:32]</td>
<td style="text-align:center">R</td>
<td style="text-align:left"> 0x0 / 0x19</td>
</tr>


<tr>
<td style="text-align:left"><strong>and</strong> rd, rs, rt</td>
<td style="text-align:left">ET logique</td>
<td style="text-align:left">R[rd] ← R[rs] &amp; R[rt]</td>
<td style="text-align:center">R</td>
<td style="text-align:left"> 0x0 / 0x24</td>
</tr>

<tr>
<td style="text-align:left"><strong>or</strong> rd, rs, rt</td>
<td style="text-align:left">OU logique</td>
<td style="text-align:left">R[rd] ← R[rs] | R[rt]</td>
<td style="text-align:center">R</td>
<td style="text-align:left"> 0x0 / 0x25</td>
</tr>

<tr>
<td style="text-align:left"><strong>xor</strong> rd, rs, rt</td>
<td style="text-align:left">OU exclusif</td>
<td style="text-align:left">R[rd] ← R[rs] ^ R[rt]</td>
<td style="text-align:center">R</td>
<td style="text-align:left"> 0x0 / 0x26</td>
</tr>

<tr>
<td style="text-align:left"><strong>andi</strong> rt, rs, imm</td>
<td style="text-align:left">ET logique<br />(2<sup>ème</sup> param. : immédiat)</td>
<td style="text-align:left">R[rd] ← R[rs] &amp; imm<sub>0</sub></td>
<td style="text-align:center">I</td>
<td style="text-align:left"> 0xC</td>
</tr>

<tr>
<td style="text-align:left"><strong>ori</strong> rt, rs, imm</td>
<td style="text-align:left">OU logique<br />(2<sup>ème</sup> param. : immédiat)</td>
<td style="text-align:left">R[rd] ← R[rs] | imm<sub>0</sub></td>
<td style="text-align:center">I</td>
<td style="text-align:left"> 0xD</td>
</tr>

<tr>
<td style="text-align:left"><strong>xori</strong> rt, rs, imm</td>
<td style="text-align:left">OU exclusif<br />(2<sup>ème</sup> param. : immédiat)</td>
<td style="text-align:left">R[rd] ← R[rs] ^ imm<sub>0</sub></td>
<td style="text-align:center">I</td>
<td style="text-align:left"> 0xE</td>
</tr>

<tr>
<td style="text-align:left"><strong>sll</strong> rd, rt, sh</td>
<td style="text-align:left">Décalage logique à gauche</td>
<td style="text-align:left">R[rd] ← R[rt] &lt;&lt; sh</td>
<td style="text-align:center">R</td>
<td style="text-align:left"> 0x0 / 0x0</td>
</tr>

<tr>
<td style="text-align:left"><strong>srl</strong> rd, rt, sh</td>
<td style="text-align:left">Décalage logique à droite</td>
<td style="text-align:left">R[rd] ← R[rt] &gt;&gt;&gt; sh</td>
<td style="text-align:center">R</td>
<td style="text-align:left"> 0x0 / 0x2</td>
</tr>

<tr>
<td style="text-align:left"><strong>sra</strong> rd, rt, sh</td>
<td style="text-align:left">Décalage arithmétique à droite</td>
<td style="text-align:left">R[rd] ← R[rt] &gt;&gt; sh</td>
<td style="text-align:center">R</td>
<td style="text-align:left"> 0x0 / 0x3</td>
</tr>

<tr>
<td style="text-align:left"><strong>sllv</strong> rd, rt, rs</td>
<td style="text-align:left">Décalage logique à gauche<br />avec registre</td>
<td style="text-align:left">R[rd] ← R[rt] &lt;&lt; rs</td>
<td style="text-align:center">R</td>
<td style="text-align:left"> 0x0 / 0x4</td>
</tr>

<tr>
<td style="text-align:left"><strong>srlv</strong> rd, rt, rs</td>
<td style="text-align:left">Décalage logique à droite<br />avec registre</td>
<td style="text-align:left">R[rd] ← R[rt] &gt;&gt;&gt; rs</td>
<td style="text-align:center">R</td>
<td style="text-align:left"> 0x0 / 0x6</td>
</tr>

<tr>
<td style="text-align:left"><strong>srav</strong> rd, rt, rs</td>
<td style="text-align:left">Décalage arithmétique à droite<br />avec registre</td>
<td style="text-align:left">R[rd] ← R[rt] &gt;&gt; rs</td>
<td style="text-align:center">R</td>
<td style="text-align:left"> 0x0 / 0x7</td>
</tr>

<tr>
<td style="text-align:left"><strong>slt</strong> rd, rs, rt</td>
<td style="text-align:left">Positionné si inférieur</td>
<td style="text-align:left">R[rd] ← R[rs] &lt; R[rt] ? 1 : 0</td>
<td style="text-align:center">R</td>
<td style="text-align:left"> 0x0 / 0x2A</td>
</tr>

<tr>
<td style="text-align:left"><strong>sltu</strong> rd, rs, rt</td>
<td style="text-align:left">Positionné si inférieur (non signés)</td>
<td style="text-align:left">R[rd] ← R[rs] &lt; R[rt] ? 1 : 0</td>
<td style="text-align:center">R</td>
<td style="text-align:left"> 0x0 / 0x2B</td>
</tr>

<tr>
<td style="text-align:left"><strong>slti</strong> rt, rs, imm</td>
<td style="text-align:left">Positionné si inférieur<br />(2<sup>ème</sup> param. : immédiat)</td>
<td style="text-align:left">R[rt] ← R[rs] &lt; imm<sub>±</sub> ? 1 : 0</td>
<td style="text-align:center">I</td>
<td style="text-align:left"> 0xA</td>
</tr>

<tr>
<td style="text-align:left"><strong>sltiu</strong> rt, rs, imm</td>
<td style="text-align:left">Positionné si inférieur (non signée)<br />(2<sup>ème</sup> param. : immédiat)</td>
<td style="text-align:left">R[rt] ← R[rs] &lt; imm<sub>±</sub> ? 1 : 0</td>
<td style="text-align:center">I</td>
<td style="text-align:left"> 0xB</td>
</tr>

<tr>
<td style="text-align:left"><strong>j</strong> imm</td>
<td style="text-align:left">Saut étiquette</td>
<td style="text-align:left">PC ← PC &amp; 0xF0000000 | (imm &lt;&lt; 2)</td>
<td style="text-align:center">J</td>
<td style="text-align:left"> 0x2</td>
</tr>

<tr>
<td style="text-align:left"><strong>jal</strong> imm</td>
<td style="text-align:left">Saut et liaison</td>
<td style="text-align:left">$ra ← PC + 4;<br />PC ← PC &amp; 0xF0000000 | (imm &lt;&lt; 2)</td>
<td style="text-align:center">J</td>
<td style="text-align:left"> 0x3</td>
</tr>

<tr>
<td style="text-align:left"><strong>jalr</strong> rd, rs</td>
<td style="text-align:left">Saut et lien sur registre</td>
<td style="text-align:left">R[rd] ← PC + 4;<br />PC ← R[rs]</td>
<td style="text-align:center">R</td>
<td style="text-align:left"> 0x0 / 0x9</td>
</tr>

<tr>
<td style="text-align:left"><strong>beq</strong> rt, rs, imm</td>
<td style="text-align:left">Branchement si égalité</td>
<td style="text-align:left">if (R[rs] == R[rt])<br /> PC ← PC + 4 + (imm<sub>±</sub>&lt;&lt; 2)</td>
<td style="text-align:center">I</td>
<td style="text-align:left"> 0x4</td>
</tr>

<tr>
<td style="text-align:left"><strong>bne</strong> rt, rs, imm</td>
<td style="text-align:left">Branchement si différent</td>
<td style="text-align:left">if (R[rs] != R[rt])<br /> PC ← PC + 4 + (imm<sub>±</sub>&lt;&lt; 2)</td>
<td style="text-align:center">I</td>
<td style="text-align:left"> 0x5</td>
</tr>

<tr>
<td style="text-align:left"><strong>lui</strong> rt, imm</td>
<td style="text-align:left">Chargement immédiat</td>
<td style="text-align:left">R[rt] ← imm &lt;&lt; 16</td>
<td style="text-align:center">I</td>
<td style="text-align:left"> 0xF</td>
</tr>

<tr>
<td style="text-align:left"><strong>lb</strong> rt, imm(rs)</td>
<td style="text-align:left">Chargement octet</td>
<td style="text-align:left">R[rt] ← Mem( R[rs] + imm<sub>±</sub>, octet )<sub>±</sub></td>
<td style="text-align:center">I</td>
<td style="text-align:left"> 0x20</td>
</tr>

<tr>
<td style="text-align:left"><strong>lh</strong> rt, imm(rs)</td>
<td style="text-align:left">Chargement demi-mot</td>
<td style="text-align:left">R[rt] ← Mem( R[rs] + imm<sub>±</sub>, demi )<sub>±</sub></td>
<td style="text-align:center">I</td>
<td style="text-align:left"> 0x21</td>
</tr>

<tr>
<td style="text-align:left"><strong>lw</strong> rt, imm(rs)</td>
<td style="text-align:left">Chargement mot</td>
<td style="text-align:left">R[rt] ← Mem( R[rs] + imm<sub>±</sub>, mot )</td>
<td style="text-align:center">I</td>
<td style="text-align:left"> 0x23</td>
</tr>

<tr>
<td style="text-align:left"><strong>sb</strong> rt, imm(rs)</td>
<td style="text-align:left">Sauvegarde octet</td>
<td style="text-align:left">Mem( R[rs] + imm<sub>±</sub> ) ← R[rt][7:0]</td>
<td style="text-align:center">I</td>
<td style="text-align:left"> 0x28</td>
</tr>

<tr>
<td style="text-align:left"><strong>sh</strong> rt, imm(rs)</td>
<td style="text-align:left">Sauvegarde demi-mot</td>
<td style="text-align:left">Mem( R[rs] + imm<sub>±</sub> ) ← R[rt][15:0]</td>
<td style="text-align:center">I</td>
<td style="text-align:left"> 0x29</td>
</tr>

<tr>
<td style="text-align:left"><strong>sw</strong> rt, imm(rs)</td>
<td style="text-align:left">Sauvegarde mot</td>
<td style="text-align:left">Mem( R[rs] + imm<sub>±</sub> ) ← R[rt]</td>
<td style="text-align:center">I</td>
<td style="text-align:left"> 0x2b</td>
</tr>

</tbody>
</table>

<p><strong>Remarques</strong> :</p>

<ol>
  <li>La notation imm<sub>±</sub> dans le tableau ci-dessus signifie « Application d’une extension de signe à l’immédiat imm ». La même remarque s’applique à Mem(…)<sub>±</sub>. Dans ce cas l’extension de signe est appliquée à l’octet ou le demi-mot récupéré depuis la mémoire.</li>
  <li>La notation imm<sub>0</sub> signifie « Application d’une extension par des zéros à l’immédiat imm ».</li>
</ol>

<h3 id="info--mémoire-ram-circuit-memcirc">Info : Mémoire RAM (circuit <code class="language-plaintext highlighter-rouge">mem.circ</code>)</h3>

<p>L’unité de mémoire DMEM (fournie dans <code class="language-plaintext highlighter-rouge">mem.circ</code>) est déjà entièrement implémentée pour vous et raccordée aux sorties de votre processeur dans <code class="language-plaintext highlighter-rouge">test_harness.circ</code> ! C.-à-d. Il n’est pas nécessaire d’ajouter l’unité mémoire (<code class="language-plaintext highlighter-rouge">mem.circ</code>) à nouveau à votre implémentation. Au fait, cela entraînera un échec des scripts d’auto évaluation ce qui ne sera pas bon pour votre score :(.</p>

<p>Notez que l’implémentation fournie de l’unité DMEM permet les inscriptions au niveau <strong>octet</strong>. Cela signifie que le signal <code class="language-plaintext highlighter-rouge">Write_En</code> a une largeur de 4 bits et agit comme un masque d’écriture pour les données en entrée. Par exemple, si <code class="language-plaintext highlighter-rouge">Write_En</code> vaut <code class="language-plaintext highlighter-rouge">0b1000</code>, alors seul l’octet le plus significatif du mot adressé en mémoire sera écrasé (ex: <code class="language-plaintext highlighter-rouge">sb $a0, 3($s0)</code>).</p>

<p>D’autre part, le port <code class="language-plaintext highlighter-rouge">ReadData</code> renverra toujours, indépendamment de <code class="language-plaintext highlighter-rouge">Write_En</code>, la valeur en mémoire (un mot entier) à l’adresse fournie. L’unité de mémoire ignore les deux bits de poids faible dans l’adresse que vous lui fournissez et traite son entrée comme une adresse de mot plutôt qu’une adresse d’octet. Par exemple, si vous entrez l’adresse 32 bits <code class="language-plaintext highlighter-rouge">0x00001007</code> (ex: <code class="language-plaintext highlighter-rouge">lb $a0, 7($s0)</code>, avec <code class="language-plaintext highlighter-rouge">$s0=0x0001000</code>), elle sera traitée comme l’adresse de mot <code class="language-plaintext highlighter-rouge">0x00001004</code>, et vous obtiendrez en sortie les 4 octets aux adresses <code class="language-plaintext highlighter-rouge">0x00001004</code>, <code class="language-plaintext highlighter-rouge">0x00001005</code>, <code class="language-plaintext highlighter-rouge">0x00001006</code> et <code class="language-plaintext highlighter-rouge">0x00001007</code>. Vous devez donc implémenter la logique de masque nécessaire pour inscrire que les octets requis (octet n° 3 pour l’exemple <code class="language-plaintext highlighter-rouge">lb $a0, 7($s0)</code>) dans le « banc de registres ».</p>

<p>Finalement, rappelez-vous que les accès non alignés à la RAM entraîneront des exceptions dans MIPS. Et comme nous n’implémentons aucune gestion des exceptions dans ce projet, vous pouvez supposer que seuls les accès sur des adresses alignées sont utilisés pour les instructions <code class="language-plaintext highlighter-rouge">lw</code>, <code class="language-plaintext highlighter-rouge">lh</code>, <code class="language-plaintext highlighter-rouge">sh</code> et <code class="language-plaintext highlighter-rouge">sw</code>. Cela signifie que les adresses utilisées avec les instructions <code class="language-plaintext highlighter-rouge">lw</code> et <code class="language-plaintext highlighter-rouge">sw</code> (resp. <code class="language-plaintext highlighter-rouge">lh</code> et <code class="language-plaintext highlighter-rouge">sh</code>) sont des multiples de 4 (resp. multiples de 2). La valeur 4 (resp. 2) correspond à la taille en octets d’un mot (resp. demi-mot) en mémoire.</p>

<p>Voici un résumé des entrées et sorties de la mémoire :</p>

<table class="styled-table">
<colgroup>
<col width="10%" />
<col width="10%" />
<col width="20%" />
<col width="60%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align:center">Nom</th>
<th style="text-align:center">Direction</th>
<th style="text-align:center">Largeur en bits</th>
<th style="text-align:center">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">WriteAddr</td>
<td style="text-align:center">Entrée</td>
<td style="text-align:center">32</td>
<td>Adresse à lire / écrire en mémoire</td>
</tr>
<tr>
<td style="text-align:center">WriteData</td>
<td style="text-align:center">Entrée</td>
<td style="text-align:center">32</td>
<td>Valeur à écrire dans la mémoire</td>
</tr>
<tr>
<td style="text-align:center">Write_En</td>
<td style="text-align:center">Entrée</td>
<td style="text-align:center">4</td>
<td>Le masque d’écriture pour les instructions qui écrivent dans la mémoire et zéro sinon</td>
</tr>
<tr>
<td style="text-align:center">CLK</td>
<td style="text-align:center">Entrée</td>
<td style="text-align:center">1</td>
<td>Entrée fournissant l’horloge du CPU</td>
</tr>
<tr>
<td style="text-align:center">ReadData</td>
<td style="text-align:center">Sortie</td>
<td style="text-align:center">32</td>
<td>Valeur des données stockées à l’adresse indiquée</td>
</tr>
</tbody>
</table>

<h3 id="info--unité-de-branchement-circuit-branch_compcirc">Info : Unité de Branchement (circuit <code class="language-plaintext highlighter-rouge">branch_comp.circ</code>)</h3>

<p>L’« Unité de Branchement » (squelette fourni dans le fichier <code class="language-plaintext highlighter-rouge">branch_comp.circ</code>) devrait calculer la nouvelle valeur du compteur ordinal (c.-à-d. newPC) quand l’instruction en cours d’exécution est un branchement ou un saut par « immediat » dans le code.</p>

<p>Pour éditer ce circuit, modifiez le fichier <code class="language-plaintext highlighter-rouge">branch_comp.circ</code> et non le circuit virtuel <code class="language-plaintext highlighter-rouge">branch_comp</code> inclus dans <code class="language-plaintext highlighter-rouge">cpu_*.circ</code>. Notez qu’à chaque modification du circuit <code class="language-plaintext highlighter-rouge">branch_comp.circ</code>, vous devrez fermer et ouvrir <code class="language-plaintext highlighter-rouge">cpu_*.circ</code> pour appliquer les modifications dans votre CPU.</p>

<p>Voici un résumé des entrées et sorties de cette unité :</p>

<table class="styled-table">
<colgroup>
<col width="10%" />
<col width="10%" />
<col width="20%" />
<col width="60%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align:center">Nom</th>
<th style="text-align:center">Direction</th>
<th style="text-align:center">Largeur en bits</th>
<th style="text-align:center">Description</th>
</tr>
</thead>
<tbody>

<tr>
<td style="text-align:center">inst</td>
<td style="text-align:center">Entrée</td>
<td style="text-align:center">32</td>
<td>L’instruction en cours d’exécution</td>
</tr>

<tr>
<td style="text-align:center">ximm</td>
<td style="text-align:center">Entrée</td>
<td style="text-align:center">32</td>
<td>L’immédiat renvoyé par la sortie <strong>Imm</strong> du « Générateur d’Immédiat » </td>
</tr>

<tr>
<td style="text-align:center">PC</td>
<td style="text-align:center">Entrée</td>
<td style="text-align:center">32</td>
<td>La valeur du registre PC</td>
</tr>

<tr>
<td style="text-align:center">zero</td>
<td style="text-align:center">Entrée</td>
<td style="text-align:center">1</td>
<td>La valeur renvoyé par la sortie <strong>zero</strong> de l’UAL</td>
</tr>

<tr>
<td style="text-align:center">BrUn</td>
<td style="text-align:center">Entrée</td>
<td style="text-align:center">2</td>
<td>Valeur permettant d’identifier l’instruction de branchement/saut à traiter</td>
</tr>

<tr>
<td style="text-align:center">newPC</td>
<td style="text-align:center">Sortie</td>
<td style="text-align:center">32</td>
<td>Nouvelle valeur à transmettre au PC</td>
</tr>

<tr>
<td style="text-align:center">BrJmp</td>
<td style="text-align:center">Sortie</td>
<td style="text-align:center">1</td>
<td>Indique si l’instruction traitée est un branchement/saut dans le code</td>
</tr>
</tbody>
</table>

<h3 id="info--générateur-dimmédiat-circuit-imm_gencirc">Info : Générateur d’Immédiat (circuit <code class="language-plaintext highlighter-rouge">imm_gen.circ</code>)</h3>

<p>l’unité « Générateur d’Immédiat » (squelette fourni dans le fichier <code class="language-plaintext highlighter-rouge">imm_gen.circ</code>) devrait calculer les constantes « Imm » des instructions de type I et la valeur du champ « shmt » dans les instructions de décalage. Consultez la figure ci-dessous pour savoir comment chaque immédiat doit être formaté dans votre processeur :</p>

<p><img src="/l2ado/static_files/images/immediat_extensions.png" alt="addi format" height="75%" width="75%" class="aligncenter" /></p>

<p>Pour éditer le « Générateur d’Immédiat », modifiez le fichier <code class="language-plaintext highlighter-rouge">imm_gen.circ</code> et non le circuit virtuel <code class="language-plaintext highlighter-rouge">imm_gen</code> inclus dans <code class="language-plaintext highlighter-rouge">cpu_*.circ</code>. Notez qu’à chaque modification du circuit <code class="language-plaintext highlighter-rouge">imm_gen.circ</code>, vous devez fermer et ouvrir le fichier <code class="language-plaintext highlighter-rouge">cpu_*.circ</code> pour appliquer les modifications dans votre CPU.</p>

<p>Encore une fois, voici un résumé des entrées et sorties de l’unité :</p>

<table class="styled-table">
<colgroup>
<col width="10%" />
<col width="10%" />
<col width="20%" />
<col width="60%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align:center">Nom</th>
<th style="text-align:center">Direction</th>
<th style="text-align:center">Largeur en bits</th>
<th style="text-align:center">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">inst</td>
<td style="text-align:center">Entrée</td>
<td style="text-align:center">32</td>
<td>L’instruction en cours d’exécution</td>
</tr>
<tr>
<td style="text-align:center">ImmSel</td>
<td style="text-align:center">Entrée</td>
<td style="text-align:center">2</td>
<td>Valeur déterminant comment reconstruire l’immédiat</td>
</tr>
<tr>
<td style="text-align:center">Imm</td>
<td style="text-align:center">Sortie</td>
<td style="text-align:center">32</td>
<td>Valeur de l’immédiat associé à l’instruction</td>
</tr>
</tbody>
</table>

<h3 id="info--unité-de-contrôle-circuit-control_logiccirc">Info : Unité de contrôle (circuit <code class="language-plaintext highlighter-rouge">control_logic.circ</code>)</h3>

<p>Afin d’exécuter correctement chaque instruction MIPS, les signaux de contrôle jouent un rôle très important dans un processeur (et ce projet !). Le squelette fourni dans le fichier <code class="language-plaintext highlighter-rouge">control_logic.circ</code> est basé sur l’unité de contrôle vue en cour pour un processeur MIPS.</p>

<p>Veuillez jetez un œil sur les présentations Powerpoint du cours pour commencer. Essayez de parcourir le chemin de données avec différents types d’instructions; lorsque vous rencontrez un MUX ou un autre composant, déterminez la valeur du sélecteur ou d’activation dont vous aurez besoin pour cette instruction.</p>

<p>Vous pouvez, si vous le désirez, ajouter plus d’entrées ou de sorties au circuit de démarrage existant en fonction de votre implémentation du circuit de contrôle. Vous pouvez également choisir de n’utiliser qu’un sous ensemble des ports fournis. Cela dit, veuillez ne modifier ni supprimer aucun des ports existants au cours de ce processus.</p>

<p>Il existe deux approches principales pour implémenter le circuit logique de commande afin qu’il puisse extraire l’« opcode / func » d’une instruction et définir les signaux de commande de manière appropriée. La première méthode est le contrôle par circuit câblé. C’est généralement l’approche préférée pour les architectures RISC telles que MIPS et RISC-V. Ici, on utilisera les portes logiques « ET », « OU » et « NON » avec les divers composants qui peuvent être construits à partir de ces portes (comme les MUX et les DEMUX) pour implémenter des tables de vérité et de <a href="https://fr.wikipedia.org/wiki/Table_de_Karnaugh">Karnaugh</a> correspondant aux fonctions identifiées.</p>

<p>L’autre façon de faire est d’utiliser une mémoire ROM (mémoire en lecture seule). Chaque instruction implémentée par un processeur est mappée à une adresse dans cette mémoire où on y stocke le mot de commande et de contrôle pour cette instruction. Un décodeur d’adresse prend donc une instruction en entrée (c.-à-d. le « opcode / func ») et identifie l’adresse du mot contenant les signaux de contrôle pour cette instruction. Cette approche est courante dans les architectures CISC telles que les processeurs Intel x86-64 et offre une certaine flexibilité, car elle peut être reprogrammée en modifiant le contenu de la mémoire ROM.</p>

<p>Pour éditer l’unité de contrôle, modifiez le fichier <code class="language-plaintext highlighter-rouge">control_logic.circ</code> et non le circuit virtuel <code class="language-plaintext highlighter-rouge">control_logic</code> inclus dans <code class="language-plaintext highlighter-rouge">cpu_*.circ</code>. Notez qu’à chaque modification du circuit <code class="language-plaintext highlighter-rouge">control_logic.circ</code>, vous devrez fermer et ouvrir <code class="language-plaintext highlighter-rouge">cpu_*.circ</code> pour appliquer les modifications dans votre CPU.</p>

<h3 id="info-processeur-circuit-cpu_circ">Info: Processeur (circuit <code class="language-plaintext highlighter-rouge">cpu_*.circ</code>)</h3>

<p>Le circuit dans <code class="language-plaintext highlighter-rouge">cpu_*.circ</code> doit implémenter le chemin de données principal et connecter tous les sous-circuits ensemble (UAL, Unité de Branchement, unité de contrôle, Générateur d’Immédiat, mémoire RAM et Banc de Registres).</p>

<p>Dans la partie A, vous avez implémenté un simple pipeline en deux étages dans votre processeur. Vous devez réaliser que les « aléas de données » ne posent PAS de problème ici car tous les accès à toutes les sources de données se produisent dans une seule étape du pipeline (le deuxième étage).</p>

<p>Cependant, comme la partie B de ce projet nécessite la prise en charge des instructions de branchement et de saut, il y a bien des « aléas de contrôle » à gérer. En particulier, l’instruction immédiatement après un branchement ou un saut n’est pas nécessairement exécutée si la branche est prise. Cela rend votre tâche un peu plus complexe car au moment où vous réalisez qu’une branche ou un saut est en phase d’exécution, vous avez déjà accédé à la mémoire d’instructions et récupéré (éventuellement) la mauvaise prochaine instruction. Vous devez donc « annuler » l’instruction récupérée si l’instruction en cours d’exécution est un saut ou un branchement <strong>validé</strong>. Vous ne devez annuler l’instruction récupérée que si une branche est prise (n’annuler pas autrement). L’annulation d’instructions DOIT être accomplie en insérant un <code class="language-plaintext highlighter-rouge">nop</code> dans l’étape d’exécution du pipeline au lieu de l’instruction récupérée. Notez que l’instruction <code class="language-plaintext highlighter-rouge">sll $0, $0, 0</code> ou le code machine associé <code class="language-plaintext highlighter-rouge">0x00000000</code> est une instruction <code class="language-plaintext highlighter-rouge">nop</code> pour notre processeur.</p>

<p>Quelques points à considérer pour votre implémentation :</p>
<ul>
  <li>Les étapes PIF et PEX auront-elles des valeurs PC identiques ou différentes ?</li>
  <li>Avez-vous besoin de stocker le PC entre les différentes étapes du pipeline ?</li>
  <li>Où insérer un <code class="language-plaintext highlighter-rouge">nop</code> éventuel dans le flux d’instructions ?</li>
  <li>Quelle adresse doit être demandée ensuite pendant que l’étape PEX exécute un <code class="language-plaintext highlighter-rouge">nop</code> ? Est-ce différent de la normale ?</li>
</ul>

<h3 id="tester-votre-processeur"><strong>Tester votre Processeur</strong></h3>

<p>Des tests de cohérence sont fournis pour votre processeur dans <code class="language-plaintext highlighter-rouge">tests/part_b/pipelined</code>.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>python3 test_runner.py part_b pipelined
</code></pre></div></div>

<p>Vous pouvez consulter les fichiers <code class="language-plaintext highlighter-rouge">.s</code> (MIPS) et <code class="language-plaintext highlighter-rouge">.hex</code> (code machine) utilisés pour les tests dans <code class="language-plaintext highlighter-rouge">tests/part_b/pipelined/inputs</code>.</p>

<p>Vous pouvez également utiliser le script Python <code class="language-plaintext highlighter-rouge">binary_to_hex_cpu.py</code>, comme dans la tache n° 3 ce projet, afin visualiser et mieux interpréter vos résultats.</p>

<h2 id="soumettre-la-partie-b-du-devoir">Soumettre la partie B du devoir</h2>

<p>Si vous avez terminé la tâche n° 4, vous avez terminé la partie B du projet. Félicitations pour votre nouveau processeur !</p>

<p>Assurez-vous à nouveau que vous n’avez pas déplacé/modifié vos ports d’entrée/sortie et que vos circuits s’insèrent sans problème dans les socles de test fournis.</p>

<p>Pour soumettre votre travail, créez un fichier <strong>zippé</strong> contenant tous les circuits que vous deviez implémenter dans les deux parties de ce projets. C.-à-d. les circuits <strong>alu.circ</strong>, <strong>regfile.circ</strong>, <strong>branch_comp.circ</strong>, <strong>imm_gen.circ</strong>, <strong>control_logic.circ</strong>, <strong>cpu_single.circ</strong> et <strong>cpu_pipelined.circ</strong>.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>votre_fichier.zip
 ├── alu.circ
 ├── regfile.circ
 ├── imm_gen.circ
 ├── branch_comp.circ
 ├── control_logic.circ
 ├── cpu_single.circ
 └── cpu_pipelined.circ
</code></pre></div></div>

<p>Par exemple, pour mettre les fichiers <strong>file1.circ</strong> et <strong>file2.circ</strong> dans un fichier zip nommé  <strong>votre_fichier.zip</strong> :</p>
<ol>
  <li>Ouvrez une console (Ctrl-Alt-T sous Ubuntu), puis allez dans le répertoire contenant les fichiers <strong>file1.circ</strong> et <strong>file2.circ</strong>.</li>
  <li>Tapez la commande :
    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>zip votre_fichier.zip  file1.circ file2.circ
</code></pre></div>    </div>
  </li>
</ol>

<p>Soumettez ensuite le fichier résultat <strong>votre_fichier.zip</strong> à l’évaluateur automatique. Cette partie du projet utilisera les mêmes fichiers de test déjà fournis dans le kit de démarrage pour l’évaluation de votre travail ainsi que d’autres tests cachés.</p>

  </article>

</div>
      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <!--     <h2 class="footer-heading"></h2> -->
    <div class="footer-col-wrapper">
      <div class="footer-col  footer-col-1">

        <p class="text">
          02 rue Didouche Mourad<br />
16000 Alger<br />
 
        </p>
      </div>

      <div class="footer-col  footer-col-2">
        <ul class="social-media-list">


          

          

          

          

          
          




        </ul>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
