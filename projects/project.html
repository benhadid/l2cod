<!DOCTYPE html>
<html>

  <head>
  
    <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-5KMKZK4Z38"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-5KMKZK4Z38');
  </script>
  

  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title> Mini-Processeur MIPS - Architecture des ordinateurs / Automne 2023 </title>
  <meta name="description" content="ÉnoncéPour ce mini-projet, vous utiliserez Logisim afin d’implémenter une version basique d’un processeur MIPS. Ce devoir est organisé en deux parties : A et...">

  <link rel="shortcut icon" href="https://benhadid.github.io/l2ado/favicon.ico?" />
  <link rel="stylesheet" href="/l2ado/_css/main.css">
  <link rel="canonical" href="https://benhadid.github.io/l2ado/projects/project">
  <link rel="alternate" type="application/rss+xml" title="Architecture des ordinateurs / Automne 2023 - " href="https://benhadid.github.io/l2ado/feed.xml" />

  <link rel='stylesheet' id='open-sans-css'  href='//fonts.googleapis.com/css?family=Open+Sans%3A300italic%2C400italic%2C600italic%2C300%2C400%2C600&#038;subset=latin%2Clatin-ext&#038;ver=4.2.4' type='text/css' media='all' />
  <link href='https://fonts.googleapis.com/css?family=Titillium+Web:600italic,600,400,400italic' rel='stylesheet' type='text/css'>

  

  

  <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.2.0/css/all.css" integrity="sha384-hWVjflwFxL6sNzntih27bfxkr27PmbbK/iSvJ+a4+0owXq79v+lsFkW54bOGbiDQ" crossorigin="anonymous">

  <!-- MathJax -->
  <script type="text/javascript" async
    src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML">
  </script>
</head>


  <body>

    <header class="site-header">

  <div class="wrapper" style="z-index: 100;">
      <table><tr>
          <td><img width="75" src="/l2ado/_images/logo.png" valign="middle"></td>
          <td style="padding-left:10px;"><a class="schoolname" style="font-size: 15px;" class="site-title" href=""></a>
          <br/>
          <span style="margin-top: -2px;margin-bottom: -10px;" class="site-title"><a href="/l2ado/" title="Architecture des ordinateurs / Automne 2023 - "><b>Architecture des ordinateurs</a></b></span>
          <br/>
          <span class="coursesemeter" style="font-size: 12px;font-weight: bold;margin-top: 10px;display: block;">Automne 2023</span>
          </td>
        </tr></table>

    <nav class="site-nav">

      <a href="#" class="menu-icon menu.open">
        <svg viewBox="0 0 18 15">
          <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
          <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
          <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
        </svg>
      </a>  

    <div class="trigger"><h1>Main Navigation</h1>

 <ul class="menu">
    
    <li>

      
      

      <a class="page-link" href="/l2ado/">
        <i class="fa fa-home fa-lg"></i> Accueil
      </a>

    </li>
    
    <li>

      
      

      <a class="page-link" href="/l2ado/schedule/">
        <i class="fas fa-calendar-alt"></i> Calendrier
      </a>

    </li>
    
    <li>

      
      

      <a class="page-link" href="/l2ado/lectures/">
        <i class="fas fa-book-reader"></i> Cours
      </a>

    </li>
    
    <li>

      
      

      <a class="page-link" href="/l2ado/discussions/">
        <i class="fas fa-user-graduate"></i> T. Dirigés
      </a>

    </li>
    
    <li>

      
      

      <a class="page-link" href="/l2ado/labs/">
        <i class="fas fa-laptop-code"></i> T. Pratiques
      </a>

    </li>
    
    <li>

      
      

      <a class="page-link" href="/l2ado/quizzes/">
        <i class="fas fa-question-circle"></i> Quizzes
      </a>

    </li>
    
    <li>

      
      

      <a class="page-link" href="/l2ado/projects/">
        <i class="fas fa-user-graduate"></i> Projets
      </a>

    </li>
    
    <li>

      
      

      <a class="page-link" href="/l2ado/materials/">
        <i class="fas fa-book"></i> Ressources
      </a>

    </li>
    
</ul>


     </div>  
    </nav>

  </div>

  <div class="header-texture" style="height:100%; z-index: 0; position: absolute; top:0; right: 0; left: 0; 
  background-image: url('/l2ado/_images/pattern.png');" />

</header>


    <div class="page-content">
      <div class="wrapper">
        <div class="post">

  <header class="post-header">
    <h1 class="post-title">Mini-Processeur MIPS</h1>
    <p class="post-meta">Publié le 
      <!--
      Sunday 
      22/10/2023
      -->
      
      Dimanche
      22
      
      Octobre
      2023
    </p>
  </header>

  <div>
    
    <span style="font-weight: bold">Échéance : 
      <!-- 21/12/2023 -->

      
      Jeudi
      21
      
      Décembre
      2023
  
    </span>
    

    
    <p style="font-weight: bold">Télécharger

      

      
      [<a href="/l2ado/static_files/projects/mipscpu.zip">démarrage</a>]
      

      

    </p>
    

  </div>

  <br />
  <article class="post-content">
    <h1 id="énoncé">Énoncé</h1>

<p>Pour ce mini-projet, vous utiliserez <a href="https://fr.wikipedia.org/wiki/Logisim">Logisim</a> afin d’implémenter une version basique d’un processeur MIPS. Ce devoir est organisé en deux parties : A et B.</p>

<p>Dans la partie A (tâches 1 à 3), vous allez construire une « Unité Arithmétique et Logique (UAL) » et un « Banc de Registres » pour un processeur MIPS basique, ainsi qu’une implémentation du chemin de données nécessaire à l’exécution d’instructions <code class="language-plaintext highlighter-rouge">addi</code>. Dans la partie B (tâches 4), vous ajouterez d’autres composants à votre processeur basique pour produire une version avancée qui exécutera des instructions MIPS réelles !</p>

<p>Commencez par télécharger le fichier de démarrage et décompressez son contenu dans le répertoire de votre choix. Voici la liste des fichiers que vous devez avoir :</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>proj_starter
  ├── cpu
  │   ├── alu.circ
  │   ├── branch_comp.circ
  │   ├── control_logic.circ
  │   ├── cpu_pipelined.circ
  │   ├── cpu_single.circ
  │   ├── imm_gen.circ
  │   ├── mem.circ
  │   └── regfile.circ
  ├── harnesses
  │   ├── alu_harness.circ
  │   ├── regfile_harness.circ
  │   ├── run_pipelined.circ
  │   ├── run_single.circ
  │   ├── test_pipelined_harness.circ
  │   └── test_single_harness.circ
  ├── logisim-evolution.jar
  ├── tests
  │   ├── part_a
  │   │   ├── ...
  ╎   ╎   ╎
  │   │   └── ...
  │   └── part_b
  │       ├── ...
  ╎       ╎
  │       └── ...
  └── test_runner.py
</code></pre></div></div>

<div class="bs-callout bs-callout-danger">
 <b>REMARQUE</b> : Seul les fichiers : <b>alu.circ</b>,  <b>branch_comp.circ</b>, <b>control_logic.circ</b>, <b>cpu_single.circ</b>, <b>cpu_pipelined.circ</b>, <b>imm_gen.circ</b> et <b>regfile.circ</b> doivent être modifiés et soumis pour évaluation. Le circuit <b>mem.circ</b> est déjà implémenté pour vous.
</div>

<h1 id="partie-a--version-basique">Partie A : Version basique</h1>

<h2 id="tâche-1--unité-arithmétique-et-logique-ual">Tâche 1 : Unité Arithmétique et logique (UAL)</h2>

<p>Votre première tâche est de créer une UAL qui prend en charge toutes les opérations requises par les instructions de notre ISA (cf. section suivante).</p>

<p>Le fichier squelette fourni <code class="language-plaintext highlighter-rouge">alu.circ</code> indique que votre UAL doit avoir trois entrées :</p>

<table class="styled-table">
<colgroup>
<col width="10%" />
<col width="10%" />
<col width="80%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align:center">Nom de l'entrée</th>
<th style="text-align:center">Largeur en bits</th>
<th style="text-align:center">Description</th>
</tr>
</thead>
<tbody>

<tr>
<td style="text-align:center"><strong>A</strong></td>
<td style="text-align:center">32</td>
<td>Données sur l’entrée A pour l’opération UAL</td>
</tr>

<tr>
<td style="text-align:center"><strong>B</strong></td>
<td style="text-align:center">32</td>
<td>Données sur l’entrée B pour l’opération UAL</td>
</tr>

<tr>
<td style="text-align:center"><strong>ALUSel</strong></td>
<td style="text-align:center">4</td>
<td>Sélectionne quelle opération l’UAL doit effectuer (voir ci-dessous pour la liste des opérations avec les valeurs correspondantes du commutateur).</td>
</tr>
</tbody>
</table>

<p>… et deux sorties</p>

<table class="styled-table">
<colgroup>
<col width="10%" />
<col width="10%" />
<col width="80%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align:center">Nom de la sortie</th>
<th style="text-align:center">Largeur en bits</th>
<th style="text-align:center">Description</th>
</tr>
</thead>
<tbody>

<tr>
<td style="text-align:center"><strong>Zero</strong></td>
<td style="text-align:center">1</td>
<td>Indique si la différence entre les entrées <strong>A</strong> et <strong>B</strong> est nulle</td>
</tr>

<tr>
<td style="text-align:center"><strong>Result</strong></td>
<td style="text-align:center">32</td>
<td>Résultat de l’opération UAL</td>
</tr>
</tbody>
</table>

<p><strong>REMARQUES</strong> : Dans les slides du cours « <a href="https://1drv.ms/p/s!Agf0g-qZKM8_yAyyv1se7-WxjsN2?e=GO7udR">Architecture de Von Neumann</a> », et afin de construire une UAL de plusieurs bits (8 bits est donné comme exemple), il est indiqué de dupliquer votre circuit de 1 bit et faire les adaptations nécessaires pour obtenir une UAL de plusieurs bits. Bonne nouvelle ! vous n’avez pas à le faire dans ce mini-projet, Logisim fait déjà cela pour vous ! Il suffit simplement de choisir la bonne largeur de bits pour les entrées / sorties de vos composants et c’est tout (voir la figure ci-dessous) !</p>

<p><img src="/l2ado/static_files/images/data_width.png" alt="Largeur de bits" height="55%" width="55%" class="wp-caption aligncenter" /></p>

<p>Enfin, voici ci-dessous la liste des opérations (et les valeurs <strong>ALUSel</strong> associées) que votre UAL doit pouvoir effectuer. Vous pouvez utiliser tout bloc ou fonction intégrée de Logisim pour implémenter votre circuit. <strong>Il n’est pas nécessaire de réimplémenter le circuit additionneur, de décalage ou le circuit multiplicateur ! Utilisez les blocs de circuit fournis par Logisim à cet effet</strong>.</p>

<table class="styled-table">
<colgroup>
<col width="10%" />
<col width="15%" />
<col width="30%" />
<col width="45%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align:center">Valeur de ALUSel</th>
<th style="text-align:center">Instruction</th>
<th style="text-align:center">Description</th>
<th style="text-align:center">Remarque</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:left">  add</td>
<td> <code class="language-plaintext highlighter-rouge">Result = A + B</code></td>
<td></td>
</tr>

<tr>
<td style="text-align:center">1</td>
<td style="text-align:left">  and</td>
<td> <code class="language-plaintext highlighter-rouge">Result = A &amp; B</code></td>
<td></td>
</tr>

<tr>
<td style="text-align:center">2</td>
<td style="text-align:left">  or</td>
<td> <code class="language-plaintext highlighter-rouge">Result = A | B</code></td>
<td></td>
</tr>

<tr>
<td style="text-align:center">3</td>
<td style="text-align:left">  xor</td>
<td> <code class="language-plaintext highlighter-rouge">Result = A ^ B</code></td>
<td></td>
</tr>

<tr>
<td style="text-align:center">4</td>
<td style="text-align:left">  srl</td>
<td> <code class="language-plaintext highlighter-rouge">Result = A &gt;&gt; B</code></td>
<td>Opération non signée</td>
</tr>

<tr>
<td style="text-align:center">5</td>
<td style="text-align:left">  sra</td>
<td> <code class="language-plaintext highlighter-rouge">Result = A &gt;&gt; B</code></td>
<td>Opération signée</td>
</tr>

<tr>
<td style="text-align:center">6</td>
<td style="text-align:left">  sll</td>
<td> <code class="language-plaintext highlighter-rouge">Result = A &lt;&lt; B</code></td>
<td></td>
</tr>

<tr>
<td style="text-align:center">7</td>
<td style="text-align:left">  —</td>
<td>    —</td>
<td>Non utilisé</td>
</tr>

<tr>
<td style="text-align:center">8</td>
<td style="text-align:left">  slt</td>
<td> <code class="language-plaintext highlighter-rouge">Result = A &lt; B ? 1 : 0</code></td>
<td>Comparaison signée</td>
</tr>

<tr>
<td style="text-align:center">9</td>
<td style="text-align:left">  sltu</td>
<td> <code class="language-plaintext highlighter-rouge">Result = A &lt; B ? 1 : 0</code></td>
<td>Comparaison non signée</td>
</tr>

<tr>
<td style="text-align:center">10</td>
<td style="text-align:left">  mul</td>
<td> <code class="language-plaintext highlighter-rouge">Result = (A * B)[31:0]</code></td>
<td>Opération signée</td>
</tr>

<tr>
<td style="text-align:center">11</td>
<td style="text-align:left">  mulhu</td>
<td> <code class="language-plaintext highlighter-rouge">Result = (A * B)[63:32]</code></td>
<td>Opération non signée</td>
</tr>

<tr>
<td style="text-align:center">12</td>
<td style="text-align:left">  sub</td>
<td> <code class="language-plaintext highlighter-rouge">Result = A - B</code></td>
<td></td>
</tr>

<tr>
<td style="text-align:center">13</td>
<td style="text-align:left">  —</td>
<td>    —</td>
<td>Non utilisé</td>
</tr>

<tr>
<td style="text-align:center">14</td>
<td style="text-align:left">  mulh</td>
<td> <code class="language-plaintext highlighter-rouge">Result = (A * B)[63:32]</code></td>
<td>Opération signée</td>
</tr>
</tbody>
</table>

<p><strong>Indications</strong> :</p>

<ul>
  <li>
    <p>L’opération <code class="language-plaintext highlighter-rouge">add</code> est déjà implémentée pour vous; n’hésitez pas à utiliser une structure similaire pour réaliser les autres fonctions.</p>
  </li>
  <li>
    <p>Lors de l’implémentation de <code class="language-plaintext highlighter-rouge">mul</code> et <code class="language-plaintext highlighter-rouge">mulh</code>, veuillez noter que le bloc Logisim de multiplication possède une sortie « Carry Out » qui pourrait vous être utile (le bloc additionneur possède également cette sortie, mais vous n’en aurez pas besoin pour ce projet).</p>
  </li>
  <li>
    <p>Les séparateurs et les extenseurs de bits vous seront très utiles lors de l’implémentation des opérations de décalages.</p>
  </li>
  <li>
    <p>Utilisez les tunnels ! Cela vous évitera de croiser des fils involontairement ce qui causera des erreurs inattendues.</p>
  </li>
  <li>
    <p>Un multiplexeur (MUX) peut être utile pour décider quelle sortie de quel composant vous voulez transmettre. En d’autres termes, traiter les entrées dans tous les composants d’une manière simultanée, puis, en fonction de l’opération choisie, sélectionner la bonne sortie à transmettre.</p>
  </li>
</ul>

<div class="bs-callout bs-callout-danger">
  <h4>ATTENTION</h4>

  <p>Vous pouvez apporter toutes les modifications souhaitées à <b>alu.circ</b>, mais les entrées et sorties du circuit doivent obéir au comportement spécifié ci-dessus. En outre, votre fichier <b>alu.circ</b> doit correspondre au socle <b>alu_harness.circ</b> fourni. Cela signifie que vous devez veiller à <b>NE PAS</b> réorganiser les entrées ou les sorties du circuit. Si vous avez besoin de plus d'espace, utilisez des tunnels !</p>

  <p>Si vous créez des sous-circuits supplémentaires, ils doivent également être dans <b>alu.circ</b> (c.-à-d. vous ne devez pas créer de nouveaux fichiers .circ).</p>

  <p>Pour vérifier que vos modifications n’ont pas rompu les correspondances entrés / sorties entre les deux circuits, ouvrez le fichier <b>alu_harness.circ</b> dans Logisim et assurez-vous qu’il n’y a pas d’erreurs de branchement (c.-à-d. pas de fils rouges ou oranges).</p>
</div>

<h3 id="tester-votre-ual"><strong>Tester votre UAL</strong></h3>

<p>Un groupe de tests de cohérence de votre UAL est fourni dans le répertoire <code class="language-plaintext highlighter-rouge">tests/part_a/alu</code>. L’exécution du script <code class="language-plaintext highlighter-rouge">test_runner.py</code> (voir ci-dessous) exécutera les tests UAL et produira les résultats dans le répertoire <code class="language-plaintext highlighter-rouge">tests/part_a/alu/student_output</code>.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>python3 test_runner.py part_a alu
</code></pre></div></div>

<p>Également fourni un fichier <code class="language-plaintext highlighter-rouge">binary_to_hex_alu.py</code> qui permet d’interpréter la sortie de l’UAL dans un format lisible. Pour l’utiliser, procédez comme suit :</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">cd </span>tests/part_a/alu
<span class="nv">$ </span>python3 binary_to_hex_alu.py PATH_TO_OUTPUT_FILE
</code></pre></div></div>

<p>Par exemple, pour visualiser le fichier <code class="language-plaintext highlighter-rouge">reference_output/alu-add-ref.out</code>, procédez comme suit :</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">cd </span>tests/part_a/alu
<span class="nv">$ </span>python3 binary_to_hex_alu.py reference_output/alu-add-ref.out
</code></pre></div></div>

<p>Si vous voulez voir la différence entre la sortie de votre circuit et la solution de référence, placez les sorties lisibles dans de nouveaux fichiers <code class="language-plaintext highlighter-rouge">.out</code> et comparez-les avec la commande <code class="language-plaintext highlighter-rouge">diff</code> (cf. <code class="language-plaintext highlighter-rouge">man diff</code>). Par exemple, pour le test <code class="language-plaintext highlighter-rouge">alu-add</code>, procédez comme suit :</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">cd </span>tests/part_a/alu
<span class="nv">$ </span>python3 binary_to_hex_alu.py reference_output/alu-add-ref.out <span class="o">&gt;</span> reference.out
<span class="nv">$ </span>python3 binary_to_hex_alu.py student_output/alu-add-student.out <span class="o">&gt;</span> student.out
<span class="nv">$ </span>diff reference.out student.out
</code></pre></div></div>

<h2 id="tâche-2--banc-de-registres">Tâche 2 : Banc de Registres</h2>

<p>Dans cette tâche, vous implémenterez <strong>les 32 registres $0 – $31</strong> spécifiés dans l’architecture MIPS. Pour faciliter l’implémentation, huit registres seront exposés à des fins de test et de débogage (voir la liste ci-dessous). Veuillez vous assurer que les valeurs de ces registres sont attachées aux sorties appropriées dans le fichier <code class="language-plaintext highlighter-rouge">regfile.circ</code>.</p>

<p>Votre « Banc de Registres » devrait pouvoir lire ou écrire depuis/dans les registres spécifiés dans une instruction MIPS et cela sans affecter les autres registres. Il y a une exception notable : votre « Banc de Registres » ne doit <strong>PAS</strong> écrire dans le registre <code class="language-plaintext highlighter-rouge">$0</code> même si une instruction tente de le faire. Pour rappel, le registre zéro doit <strong>TOUJOURS</strong> avoir la valeur <code class="language-plaintext highlighter-rouge">0</code>.</p>

<p>Les registres exposés et leurs numéros correspondants sont indiqués ci-dessous.</p>

<table class="styled-table">
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align:center">Numéro de registre</th>
<th style="text-align:center">Nom du registre</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:center">$a0</td>
</tr>
<tr>
<td style="text-align:center">8</td>
<td style="text-align:center">$t0</td>
</tr>
<tr>
<td style="text-align:center">9</td>
<td style="text-align:center">$t1</td>
</tr>
<tr>
<td style="text-align:center">10</td>
<td style="text-align:center">$t2</td>
</tr>
<tr>
<td style="text-align:center">16</td>
<td style="text-align:center">$s0</td>
</tr>
<tr>
<td style="text-align:center">17</td>
<td style="text-align:center">$s1</td>
</tr>
<tr>
<td style="text-align:center">29</td>
<td style="text-align:center">$sp</td>
</tr>
<tr>
<td style="text-align:center">31</td>
<td style="text-align:center">$ra</td>
</tr>
</tbody>
</table>

<p><br />
Un squelette du « Banc de Registres » à implémenter est fourni dans le fichier <code class="language-plaintext highlighter-rouge">regfile.circ</code>. Le circuit possède six entrées :</p>

<table class="styled-table">
<colgroup>
<col width="20%" />
<col width="15%" />
<col width="65%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align:center">Nom de l'entrée</th>
<th style="text-align:center">Largeur en bits</th>
<th style="text-align:center">Description</th>
</tr>
</thead>

<tbody>

<tr>
<td style="text-align:left"> <strong>Clock</strong></td>
<td style="text-align:center">1</td>
<td>Entrée fournissant l’horloge. Ce signal peut être acheminé à d’autres sous-circuits ou directement raccordé aux entrées d’horloge des unités de mémoire dans Logisim, mais ne doit en aucune façon être raccordé à des portes logiques (c.-à-d. ne l’inversez pas, n’appliquez pas la porte “ET” dessus, etc.)</td>
</tr>

<tr>
<td style="text-align:left"> <strong>RegWEn</strong></td>
<td style="text-align:center">1</td>
<td>Active l’écriture des données au prochain front montant de l’horloge</td>
</tr>

<tr>
<td style="text-align:left"> <strong>rs</strong></td>
<td style="text-align:center">5</td>
<td>Détermine quelle valeur de registre est envoyée à la sortie <strong>Read_Data_1</strong> (voir ci-dessous)</td>
</tr>

<tr>
<td style="text-align:left"> <strong>rt</strong></td>
<td style="text-align:center">5</td>
<td>Détermine quelle valeur de registre est envoyée à la sortie <strong>Read_Data_2</strong> (voir ci-dessous)</td>
</tr>

<tr>
<td style="text-align:left"> <strong>rd</strong></td>
<td style="text-align:center">5</td>
<td>Sélectionne le registre qui recevra le contenu de <strong>Write_Data</strong> au prochain front montant de l’horloge, en supposant que <strong>RegWEn</strong> est à <strong>1</strong></td>
</tr>

<tr>
<td style="text-align:left"> <strong>Write_Data</strong></td>
<td style="text-align:center">32</td>
<td>Contient les données à écrire dans le registre identifié par l’entrée <strong>rd</strong> au prochain front montant de l’horloge, en supposant que <strong>RegWEn</strong> est à <strong>1</strong></td>
</tr>
</tbody>
</table>

<p><br />
Le « Banc de Registres » dans <code class="language-plaintext highlighter-rouge">regfile.circ</code> possède également les sorties suivantes :</p>

<table class="styled-table">
<colgroup>
<col width="20%" />
<col width="15%" />
<col width="65%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align:center">Nom de la sortie</th>
<th style="text-align:center">Largeur en bits</th>
<th style="text-align:center">Description</th>
</tr>
</thead>

<tbody>

<tr>
<td style="text-align:left"> <strong>Read_Data_1</strong></td>
<td style="text-align:center">32</td>
<td>Renvoie la valeur contenue dans le registre identifié par l’entrée <strong>rs</strong></td>
</tr>

<tr>
<td style="text-align:left"> <strong>Read_Data_2</strong></td>
<td style="text-align:center">32</td>
<td>Renvoie la valeur contenue dans le registre identifié par l’entrée <strong>rt</strong></td>
</tr>

<tr>
<td style="text-align:left"> Valeur <strong>ra</strong></td>
<td style="text-align:center">32</td>
<td>Renvoie la valeur contenue dans le registre <strong>$ra</strong> (sortie utilisée pour le débogage et les tests)</td>
</tr>

<tr>
<td style="text-align:left"> Valeur <strong>sp</strong></td>
<td style="text-align:center">32</td>
<td>Renvoie la valeur contenue dans le registre <strong>$sp</strong> (sortie utilisée pour le débogage et les tests)</td>
</tr>

<tr>
<td style="text-align:left"> Valeur <strong>t0</strong></td>
<td style="text-align:center">32</td>
<td>Renvoie la valeur contenue dans le registre <strong>$t0</strong> (sortie utilisée pour le débogage et les tests)</td>
</tr>

<tr>
<td style="text-align:left"> Valeur <strong>t1</strong></td>
<td style="text-align:center">32</td>
<td>Renvoie la valeur contenue dans le registre <strong>$t1</strong> (sortie utilisée pour le débogage et les tests)</td>
</tr>

<tr>
<td style="text-align:left"> Valeur <strong>t2</strong></td>
<td style="text-align:center">32</td>
<td>Renvoie la valeur contenue dans le registre <strong>$t2</strong> (sortie utilisée pour le débogage et les tests)</td>
</tr>

<tr>
<td style="text-align:left"> Valeur <strong>s0</strong></td>
<td style="text-align:center">32</td>
<td>Renvoie la valeur contenue dans le registre <strong>$s0</strong> (sortie utilisée pour le débogage et les tests)</td>
</tr>

<tr>
<td style="text-align:left"> Valeur <strong>s1</strong></td>
<td style="text-align:center">32</td>
<td>Renvoie la valeur contenue dans le registre <strong>$s1</strong> (sortie utilisée pour le débogage et les tests)</td>
</tr>

<tr>
<td style="text-align:left"> Valeur <strong>a0</strong></td>
<td style="text-align:center">32</td>
<td>Renvoie la valeur contenue dans le registre <strong>$a0</strong> (sortie utilisée pour le débogage et les tests)</td>
</tr>
</tbody>
</table>

<p>Les sorties de test en haut du fichier <code class="language-plaintext highlighter-rouge">regfile.circ</code> sont présentes à des fins de test et de débogage. Un « Banc de Registres » réel ne possède pas ces sorties ! Pour ce mini-projet, assurez-vous qu’ils sont correctement raccordés aux registres indiqués parce que s’ils ne le sont pas, l’évaluateur automatique ne pourra pas évaluer votre devoir correctement ( et vous obtiendrez un zéro. :( ).</p>

<p><strong>Indications</strong> :</p>

<ul>
  <li>
    <p>Utilisez le copier-coller à volonté ! Afin d’éviter un travail répétitif (et ennuyeux), commencez par créer un registre complètement fonctionnel et utiliser le ensuite comme modèle pour construire les autres.</p>
  </li>
  <li>
    <p>Il est recommandé de ne pas utiliser l’entrée « <code class="language-plaintext highlighter-rouge">enable</code> » sur vos MUX. En fait, vous pouvez même désactiver cette fonctionnalité depuis le panel Logisim. Il est également conseillé de mettre sur « <code class="language-plaintext highlighter-rouge">off</code> » la propriété “three-state?”.</p>
  </li>
  <li>
    <p>Consultez l’étape 2 du TP <a href="/l2ado/labs/07_lab.html">Travaux Pratiques #7 - Conception de circuits avec Logisim</a> pour voir à quoi correspond chaque entrée/sortie d’un registre Logisim.</p>
  </li>
  <li>
    <p>Comme pour la tâche de l’UAL, les multiplexeurs vous seront très utiles (les démultiplexeurs, également).</p>
  </li>
  <li>
    <p>Que se passe-t-il dans le « Banc de Registres » après l’exécution d’une instruction machine. Quelles valeurs changent ? Quelles valeurs restent les mêmes ? Les registres sont déclenchés par une horloge - qu’est-ce que cela signifie ?</p>
  </li>
  <li>
    <p>Pour rappel, les registres possèdent une entrée « <code class="language-plaintext highlighter-rouge">enable</code> » ainsi qu’une entrée d’horloge.</p>
  </li>
  <li>
    <p>Quelle est la valeur du registre <code class="language-plaintext highlighter-rouge">$0</code> ?</p>
  </li>
</ul>

<div class="bs-callout bs-callout-danger">
  <h4>ATTENTION</h4>

  <p>Vous pouvez apporter toutes les modifications souhaitées à <b>regfile.circ</b>, mais les entrées et sorties du circuit doivent obéir au comportement spécifié ci-dessus. De plus, votre fichier <b>regfile.circ</b> doit correspondre au socle <b>regfile_harness.circ</b> fourni. Cela signifie que vous devez veiller à <b>NE PAS</b> réorganiser les entrées ou les sorties du circuit. Si vous avez besoin de plus d'espace, utilisez des tunnels !</p>

  <p>Si vous créez des sous-circuits supplémentaires, ils doivent également être dans <b>regfile.circ</b> (c.-à-d. vous ne devez pas créer de nouveaux fichiers .circ).</p>

  <p>Pour vérifier que vos modifications n’ont pas rompu les correspondances entrés/sorties entre les deux circuits, ouvrez le fichier <b>regfile_harness.circ</b> et assurez-vous qu’il n’y a pas d’erreurs de branchement.</p>
</div>

<h3 id="tester-votre--banc-de-registres-"><strong>Tester votre « Banc de Registres »</strong></h3>

<p>Un groupe de tests de cohérence du « Banc de Registres » est fourni dans le répertoire <code class="language-plaintext highlighter-rouge">tests/part_a/regfile</code>. L’exécution du testeur (voir ci-dessous) pour ce groupe exécutera également les tests UAL et produira le résultat des tests dans le répertoire <code class="language-plaintext highlighter-rouge">tests/part_a/regfile/student_output</code>.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>python3 test_runner.py part_a regfile
</code></pre></div></div>

<p>Également fourni un fichier <code class="language-plaintext highlighter-rouge">binary_to_hex_regfile.py</code> qui fonctionne d’une manière similaire au fichier <code class="language-plaintext highlighter-rouge">binary_to_hex_alu.py</code> de la tâche n°1.</p>

<h2 id="tâche-3--linstruction-addi">Tâche 3 : L’instruction <code class="language-plaintext highlighter-rouge">addi</code></h2>

<p>Dans cette troisième et dernière tâche pour la partie A, vous allez implémenter un processeur capable d’exécuter une instruction : <code class="language-plaintext highlighter-rouge">addi</code> ! Vous pouvez choisir d’implémenter d’autres instructions supplémentaires, mais vous ne serez noté que si l’instruction <code class="language-plaintext highlighter-rouge">addi</code> s’exécute correctement pour la partie A.</p>

<h3 id="info--mémoire-circuit-memcirc">Info : Mémoire (circuit <code class="language-plaintext highlighter-rouge">mem.circ</code>)</h3>

<p>L’unité de mémoire (fournie dans <code class="language-plaintext highlighter-rouge">mem.circ</code>) est déjà entièrement implémentée pour vous ! Cependant, l’instruction <code class="language-plaintext highlighter-rouge">addi</code> n’utilise <strong>PAS</strong> l’unité de mémoire, vous pouvez donc ignorer ce module pour la partie A.</p>

<h3 id="info--comparateur-de-branchement-circuit-branch_compcirc">Info : Comparateur de Branchement (circuit <code class="language-plaintext highlighter-rouge">branch_comp.circ</code>)</h3>

<p>L’unité « Comparateur de Branchement » fournie dans le fichier <code class="language-plaintext highlighter-rouge">branch_comp.circ</code> n’est pas implémentée, mais comme l’instruction <code class="language-plaintext highlighter-rouge">addi</code> n’utilise <strong>PAS</strong> cette unité vous pouvez donc l’ignorer pour la partie A.</p>

<h3 id="info--générateur-dimmédiat-circuit-imm_gencirc">Info : Générateur d’Immédiat (circuit <code class="language-plaintext highlighter-rouge">imm_gen.circ</code>)</h3>

<p>l’unité « Générateur d’Immédiat » fournie dans le fichier <code class="language-plaintext highlighter-rouge">imm_gen.circ</code> n’est pas implémentée. L’instruction <code class="language-plaintext highlighter-rouge">addi</code> utilise cette unité. Toutefois, comme il s’agit de la seule instruction à implémenter dans cette partie du projet, vous pouvez donc vous limiter à coder que l’immédiat associé à cette instruction sans vous soucier des autres types d’immédiat. Consultez l’image ci-dessous pour savoir comment l’immédiat de l’instruction <code class="language-plaintext highlighter-rouge">addi</code> doit être généré :</p>

<p><img src="/l2ado/static_files/images/immediat_addi.png" alt="addi format" height="75%" width="75%" class="aligncenter" /></p>

<p>Pour éditer le « Générateur d’Immédiat », modifiez le fichier <code class="language-plaintext highlighter-rouge">imm_gen.circ</code> et non le circuit virtuel <code class="language-plaintext highlighter-rouge">imm_gen</code> inclus dans <code class="language-plaintext highlighter-rouge">cpu_*.circ</code>. Notez qu’à chaque modification du circuit <code class="language-plaintext highlighter-rouge">imm_gen.circ</code>, vous devez fermer et ouvrir le fichier <code class="language-plaintext highlighter-rouge">cpu_*.circ</code> pour appliquer les modifications dans votre CPU.</p>

<p>Voici un résumé des entrées et sorties de l’unité :</p>

<table class="styled-table">
<colgroup>
<col width="10%" />
<col width="10%" />
<col width="20%" />
<col width="60%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align:center">Nom</th>
<th style="text-align:center">Direction</th>
<th style="text-align:center">Largeur en bits</th>
<th style="text-align:center">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">inst</td>
<td style="text-align:center">Entrée</td>
<td style="text-align:center">32</td>
<td>L’instruction en cours d’exécution</td>
</tr>
<tr>
<td style="text-align:center">ImmSel</td>
<td style="text-align:center">Entrée</td>
<td style="text-align:center">2</td>
<td>Valeur déterminant comment reconstruire l’immédiat</td>
</tr>
<tr>
<td style="text-align:center">Imm</td>
<td style="text-align:center">Sortie</td>
<td style="text-align:center">32</td>
<td>Valeur de l’immédiat associé à l’instruction</td>
</tr>
</tbody>
</table>

<h3 id="info-processeur-circuits-cpucirc">Info: Processeur (circuits <code class="language-plaintext highlighter-rouge">cpu*.circ</code>)</h3>

<p>Le kit de démarrage fournit également des squelettes pour votre processeur dans <code class="language-plaintext highlighter-rouge">cpu*.circ</code>. Vous utiliserez vos propres implémentations de l’UAL et du « Banc de Registres » lorsque vous construisez votre chemin de données. Pour la partie A, votre processeur doit pouvoir exécuter l’instruction <code class="language-plaintext highlighter-rouge">addi</code> en utilisant un « pipeline » à deux étages, avec IF dans la première étape et ( ID – EX – MEM – WB ) dans la deuxième étape. Commencez d’abord par implementer un processeur sans « pipeline » (utilisez le fichier squelette <code class="language-plaintext highlighter-rouge">cpu_single.circ</code> pour ce mode de fonctionnement). Une fois votre processeur à cycle unique fonctionne correctement, vous pouvez copier puis modifier votre processeur dans <code class="language-plaintext highlighter-rouge">cpu_pipelined.circ</code> pour produire une version « pipeline ».</p>

<p>Votre processeur sera inséré dans le socle <code class="language-plaintext highlighter-rouge">test_single_harness.circ</code> (ou <code class="language-plaintext highlighter-rouge">test_pipelined_harness.circ</code>, selon le cas) qui contient l’unité de mémoire. Ce socle de processeur est inséré à son tour dans le socle de test <code class="language-plaintext highlighter-rouge">run_single.circ</code> (resp. <code class="language-plaintext highlighter-rouge">run_pipelined.circ</code>) qui fournit les instructions (c.-à-d. code machine) au processeur.</p>

<p>En sortie, votre processeur émettra l’adresse d’une instruction à lire (fetch) depuis la mémoire d’instructions (IMEM). L’instruction récupérée est transmise ensuite au processeur dans l’entrée appropriée.</p>

<p>En sortie également, le processeur émettra l’adresse d’une donnée en mémoire (DMEM) et éventuellement un signal d’activation de l’écriture de données en mémoire (WRITE_ENABLE). Pour la lecture, les données récupérées depuis l’adresse transmise seront communiquées au processeur dans l’entrée appropriée (READ_DATA).</p>

<p>Essentiellement, les socles <code class="language-plaintext highlighter-rouge">test_*_harness.circ</code> et <code class="language-plaintext highlighter-rouge">run_*.circ</code> simulent respectivement vos mémoires de données (DMEM) et d’instructions (IMEM). Prenez le temps de vous familiariser avec leur fonctionnement pour vous faire une idée globale sur le simulateur.</p>

<div class="bs-callout bs-callout-danger">
  <h4>ATTENTION</h4>

<p>les socles <b>test_*_harness.circ</b> seront utilisés dans les tests de cohérence qui vous sont fournis, assurez-vous donc que votre processeur <b>cpu_*.circ</b> s'insère correctement dans le socle associé avant de tester votre implémentation, et particulièrement lorsque vous soumettez votre travail pour évaluation</p>

<p>Tout comme avec l'UAL et le « Banc de Registres », veillez à <b>NE PAS</b> déplacer les ports d'entrée ou de sortie !</p>
</div>

<p>Le processeur dispose de trois entrées qui proviennent du socle :</p>

<table class="styled-table">
<colgroup>
<col width="20%" />
<col width="15%" />
<col width="65%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align:center">Nom de l'entrée</th>
<th style="text-align:center">Largeur en bits</th>
<th style="text-align:center">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">READ_DATA</td>
<td style="text-align:center">32</td>
<td>Données récupérées depuis la mémoire de données à l’adresse indiquée dans DMEM_ADDRESS (voir ci-dessous).</td>
</tr>
<tr>
<td style="text-align:center">INSTRUCTION</td>
<td style="text-align:center">32</td>
<td>L’instruction récupérée depuis la mémoire d’instructions à l’adresse indiquée par IMEM_ADDRESS (voir ci-dessous).</td>
</tr>
<tr>
<td style="text-align:center">CLOCK</td>
<td style="text-align:center">1</td>
<td>Entrée fournissant l’horloge. Comme déjà indiquée dans la tâche « Banc de Registres », ce signal peut être acheminé à d’autres sous-circuits ou directement raccordé aux entrées d’horloge des unités de mémoire dans Logisim, mais ne doit en aucune façon être raccordé à des portes logiques (c’est-à-dire, ne l’inversez pas, n’appliquez pas la porte “ET” dessus, etc.).</td>
</tr>
</tbody>
</table>

<p><br />
… et fournit les sorties suivantes pour le socle :</p>

<table class="styled-table">
<colgroup>
<col width="20%" />
<col width="15%" />
<col width="65%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align:center">Nom de la sortie</th>
<th style="text-align:center">Largeur en bits</th>
<th style="text-align:center">Description</th>
</tr>
</thead>
<tbody>

<tr>
<td style="text-align:center">ra</td>
<td style="text-align:center">32</td>      
<td>Renvoie la valeur contenue dans le registre $ra (sortie utilisée pour le débogage et les tests)</td>      
</tr>

<tr>
<td style="text-align:center">sp</td>
<td style="text-align:center">32</td>      
<td>Renvoie la valeur contenue dans le registre $sp (sortie utilisée pour le débogage et les tests)</td>      
</tr>

<tr>
<td style="text-align:center">t0</td>
<td style="text-align:center">32</td>      
<td>Renvoie la valeur contenue dans le registre $t0 (sortie utilisée pour le débogage et les tests)</td>      
</tr>

<tr>
<td style="text-align:center">t1</td>
<td style="text-align:center">32</td>      
<td>Renvoie la valeur contenue dans le registre $t1 (sortie utilisée pour le débogage et les tests)</td>      
</tr>

<tr>
<td style="text-align:center">t2</td>
<td style="text-align:center">32</td>      
<td>Renvoie la valeur contenue dans le registre $t2 (sortie utilisée pour le débogage et les tests)</td>      
</tr>

<tr>
<td style="text-align:center">s0</td>
<td style="text-align:center">32</td>      
<td>Renvoie la valeur contenue dans le registre $s0 (sortie utilisée pour le débogage et les tests)</td>      
</tr>

<tr>
<td style="text-align:center">s1</td>
<td style="text-align:center">32</td>      
<td>Renvoie la valeur contenue dans le registre $s1 (sortie utilisée pour le débogage et les tests)</td>      
</tr>

<tr>
<td style="text-align:center">a0</td>
<td style="text-align:center">32</td>      
<td>Renvoie la valeur contenue dans le registre $a0 (sortie utilisée pour le débogage et les tests)</td>      
</tr>

<tr>
<td style="text-align:center">DMEM_ADDRESS</td>
<td style="text-align:center">32</td>      
<td>L’adresse à partir de laquelle une lecture/écriture depuis/dans la mémoire de données est requise</td>      
</tr>

<tr>
<td style="text-align:center">WRITE_DATA</td>
<td style="text-align:center">32</td>      
<td>Données à transmettre à la mémoire de données</td>      
</tr>

<tr>
<td style="text-align:center">WRITE_ENABLE</td>
<td style="text-align:center">4</td>      
<td>Fournit le masque de validation d’écriture à la mémoire de données</td>      
</tr>

<tr>
<td style="text-align:center">IMEM_ADDRESS</td>
<td style="text-align:center">32</td>      
<td>Cette sortie est utilisée pour sélectionner depuis la mémoire ROM dans <b>run_*_harness.circ</b> l’instruction à présenter à l’entrée INSTRUCTION (voir ci-dessus) du processeur</td>      
</tr>  
</tbody>
</table>

<h3 id="info--unité-de-contrôle">Info : Unité de Contrôle</h3>

<p>L’unité de contrôle fournie dans le fichier <code class="language-plaintext highlighter-rouge">control_logic.circ</code> n’est pas implémentée. La conception de votre unité de contrôle sera probablement votre plus grand défi dans la partie B de ce devoir. Pour la partie A, comme <code class="language-plaintext highlighter-rouge">addi</code> est la seule instruction que vous implémenterez, vous pouvez mettre une constante pour chaque signal de contrôle. Toutefois, au fur et à mesure que vous avancez dans votre implémentation de <code class="language-plaintext highlighter-rouge">addi</code>, réfléchissez aux endroits où vous devriez effectuer des modifications/additions futures afin de prendre en charge d’autres instructions en plus de <code class="language-plaintext highlighter-rouge">addi</code>.</p>

<p>Pour éditer l’unité de contrôle, modifiez le fichier <code class="language-plaintext highlighter-rouge">control_logic.circ</code> et non le circuit virtuel <code class="language-plaintext highlighter-rouge">control_logic</code> inclus dans <code class="language-plaintext highlighter-rouge">cpu_*.circ</code>. Notez qu’à chaque modification du circuit <code class="language-plaintext highlighter-rouge">control_logic.circ</code>, vous devez fermer et ouvrir <code class="language-plaintext highlighter-rouge">cpu_*.circ</code> pour appliquer les modifications dans votre CPU.</p>

<div class="bs-callout bs-callout-danger">
  <h4>ATTENTION</h4>

<p>Pendant l'implémentation de votre unité de contrôle, vous pouvez <b>ajouter</b> des ports d'entrées ou de sorties supplémentaires au circuit de démarrage dans <b>control_logic.circ</b>. Vous pouvez également utiliser les ports déjà fournis (ou un sous ensemble de ces ports) en fonction des besoins de votre implémentation. Cela dit, veuillez <b>ne modifier ni supprimer aucun des ports</b> existants au cours de ce processus.
</p>
</div>

<h3 id="guide--processeur-à-cycle-unique">Guide : Processeur à cycle unique</h3>

<p>Ce guide vous aidera à implémenter l’instruction <code class="language-plaintext highlighter-rouge">addi</code> de votre processeur. Chaque section ci-dessous contient des questions auxquelles vous devez réfléchir et des indications importantes. Il est nécessaire de lire et comprendre chaque question avant de passer à la suivante ! Vous pouvez même consulter les réponses en cliquant sur  ▶ si vous n’êtes pas capables de trouver les réponses vous-mêmes. Rappelons les cinq étapes d’exécution d’une instruction dans un processeur MIPS :</p>

<ol>
  <li>Récupération d’instruction (IF)</li>
  <li>Décodage d’instruction (ID)</li>
  <li>Exécution de l’instruction (EX)</li>
  <li>Lecture/écriture depuis/vers la mémoire de données (MEM)</li>
  <li>Écriture <em>éventuelle</em> dans le « Banc de Registres » (WB)</li>
</ol>

<h4 id="étape-1--récupération-dinstruction-if"><strong>Étape 1 : Récupération d’instruction (IF)</strong></h4>

<p>A ce stade de l’exécution, la question principale qui se pose est : Comment obtenir l’instruction actuelle ? Nous avons vu dans le cours que les instructions sont stockées dans la mémoire d’instructions, et chacune de ces instructions est accessible via une adresse.</p>

<fieldset class="tips">
<legend style="color: DarkSlateGrey">Indications</legend>

<details close="">
<summary>
1. Quel fichier du projet implémente la mémoire d’instructions ? Comment est-elle connectée au processeur ?
</summary>
<p style="color: DarkSlateGrey">
La mémoire d’instructions est le module ROM dans le fichier <code class="language-plaintext highlighter-rouge">run_*.circ</code>. Ce fichier fournit une entrée pour votre CPU nommée <code class="language-plaintext highlighter-rouge">INSTRUCTION</code> et prend une sortie de votre CPU. Cette sortie est appelée <code class="language-plaintext highlighter-rouge">IMEM_ADDRESS</code> dans votre fichier <code class="language-plaintext highlighter-rouge">cpu_*.circ</code> et elle s’appelle <code class="language-plaintext highlighter-rouge">FETCH_ADDR</code> dans <code class="language-plaintext highlighter-rouge">run_*.circ</code>.
</p>
</details>

<details close="">
<summary>
2. Dans vos circuits <code class="language-plaintext highlighter-rouge">cpu*.circ</code>, comment le changement de l’adresse transmise à travers <code class="language-plaintext highlighter-rouge">IMEM_ADDRESS</code> affecterait-il l’entrée <code class="language-plaintext highlighter-rouge">INSTRUCTION</code> ?
</summary>
<p style="color: DarkSlateGrey">
L’instruction que <code class="language-plaintext highlighter-rouge">run_*.circ</code> transmet à votre processeur doit être l’instruction récupérée depuis l’adresse <code class="language-plaintext highlighter-rouge">IMEM_ADDRESS</code> (ou <code class="language-plaintext highlighter-rouge">FETCH_ADDR</code>) dans la mémoire d’instructions.
</p>
</details>

<details close="">
<summary>
3. Comment vérifier si <code class="language-plaintext highlighter-rouge">IMEM_ADDRESS</code> est correct ?
</summary>
<p style="color: DarkSlateGrey">
<code class="language-plaintext highlighter-rouge">IMEM_ADDRESS</code> est l’adresse de l’instruction en cours d’exécution. Cette adresse est donc sauvegardée dans le registre <code class="language-plaintext highlighter-rouge">PC</code>. Pour ce mini-projet, votre registre <code class="language-plaintext highlighter-rouge">PC</code> démarrera à la valeur <code class="language-plaintext highlighter-rouge">0</code> car c’est la valeur par défaut dans un registre Logisim.
</p>
</details>

<details close="">
<summary>
4. Comment le registre <code class="language-plaintext highlighter-rouge">PC</code> change-t-il pour les codes qui ne possèdent pas d’instructions de sauts ou de branchement ?
</summary>
<p style="color: DarkSlateGrey">
Comme le registre <code class="language-plaintext highlighter-rouge">PC</code> contient l’adresse de l’instruction en cours d’exécution, il faut incrémenter ce registre de la taille d’une instruction pour passer à l’instruction suivante. Cela signifie que votre <code class="language-plaintext highlighter-rouge">PC</code> augmentera généralement de 4 (en supposant que l’instruction en cours n’est pas un saut ou un branchement).
</p>
</details>
</fieldset>

<p><br />
Une implémentation simple du registre <code class="language-plaintext highlighter-rouge">PC</code> est fournie dans <code class="language-plaintext highlighter-rouge">cpu_*.circ</code>. Cette implémentation ne prend pas en compte les instructions de saut et de branchement que vous implémenterez dans la partie B du projet. Mais pour l’instant, seulement des instructions <code class="language-plaintext highlighter-rouge">addi</code> seront exécutées dans notre processeur.</p>

<p>Rappelons que nous allons éventuellement implémenter un processeur en pipeline à 2 étages, de sorte que l’étape IF est séparée des étapes restantes. Quel circuit sépare les différentes étapes dans un pipeline ? Plus précisément, quel circuit sépare IF de l’étage suivant ? Auriez-vous besoin d’ajouter quelque chose ici ?
<br /></p>

<h4 id="étape-2--décodeur-dinstruction-id"><strong>Étape 2 : Décodeur d’instruction (ID)</strong></h4>

<p>Une fois l’étape « IF » implémentée, l’instruction à traiter proviendra à l’entrée <code class="language-plaintext highlighter-rouge">INSTRUCTION</code> du processeur. La seconde étape consiste donc à décomposer cette instruction selon les formats d’instruction MIPS vus en cours, et cela afin de déterminer quoi en faire dans les étapes ultérieures d’exécution.</p>

<fieldset class="tips">
<legend style="color: DarkSlateGrey">Indications</legend>

<details close="">
<summary>
1. Quel type d’instruction est <code class="language-plaintext highlighter-rouge">addi</code> ? Quels sont les différents champs de bits associés à ce type d’instruction ? Quelles sont leurs plages de bits ?
</summary>
<p style="color: DarkSlateGrey">
<code class="language-plaintext highlighter-rouge">addi</code> est une instruction de « <strong>type I</strong> ». Les champs de bits sont : - <code class="language-plaintext highlighter-rouge">opcode [31-26]</code> - <code class="language-plaintext highlighter-rouge">rs [25-21]</code> - <code class="language-plaintext highlighter-rouge">rt [20-16]</code> - <code class="language-plaintext highlighter-rouge">imm [15-0]</code>.</p>
</details>

<details close="">
<summary>
2. Dans Logisim, quel outil utiliseriez-vous pour séparer différents groupes de bits ?
</summary>
<p style="color: DarkSlateGrey">
Le Séparateur de bits (Splitter) !
</p>
</details>
<p>
<br />
    3. Implémentez l’étape de « décodage d’instruction » en utilisant l’entrée <code class="language-plaintext highlighter-rouge">INSTRUCTION</code>. Vous devez utiliser des tunnels pour étiqueter et grouper les bits.
</p>
<details close="">
<summary>
4. Dans une instruction <code class="language-plaintext highlighter-rouge">addi</code>, nous avons besoin de lire le contenu d’un registre du « Banc de Registres » pour l’additionner à une constante. Quel champ de l’instruction doit être connecté au « Banc de Registres » ? À quelle entrée du « Banc de Registres » doit-il être branché ?
</summary>
<p style="color: DarkSlateGrey">
Le champ d’instruction <code class="language-plaintext highlighter-rouge">rs</code> doit être branché sur l’entrée « read register 1 » du « Banc de Registres ».
</p>
</details>
<!-- Le résultat de l'opération sera plus tard réinscrit dans le registre destination spécifié dans l'instruction.-->
<p>
<br />
   5. Implémentez l’étape de lecture à partir du « Banc de Registres ». N’oubliez pas d’intégrer votre « Banc de Registres »  développé dans la tâche n°2 de ce projet. N’oubliez pas de connecter l’horloge !
</p>
<details close="">
<summary>
6. En quoi le « Générateur d’Immédiat » (circuit <code class="language-plaintext highlighter-rouge">imm_gen.circ</code>) pourrait vous être utile ?
</summary>
<p style="color: DarkSlateGrey">
Pour l’instruction <code class="language-plaintext highlighter-rouge">addi</code>, le « Générateur d’Immédiat » prend 16 bits de l’instruction en entrée et produit un immédiat signé de 32 bits. Vous devez implémenter cette logique dans le sous-circuit du générateur d’immédiat !
</p>
</details>
</fieldset>
<p><br /></p>

<h4 id="étape-3--exécution-de-linstruction-ex"><strong>Étape 3 : Exécution de l’instruction (EX)</strong></h4>

<p>L’étape d’exécution est l’endroit où le calcul de la plupart des instructions est effectué. C’est également ici que l’idée d’utiliser un module de contrôle sera introduite.</p>

<fieldset class="tips">
<legend style="color: DarkSlateGrey">Indications</legend>
<details close="">
<summary>
1. Pour l’instruction <code class="language-plaintext highlighter-rouge">addi</code>, que serait les données en entrée de votre UAL ?
</summary>
<p style="color: DarkSlateGrey">
Read Data 1 (rs) du « Banc de Registres » et la constante produite par le « Générateur d’Immédiat ».
</p>
</details>

<details close="">
<summary>
2. A quoi sert <code class="language-plaintext highlighter-rouge">ALUSel</code> dans l’UAL ?
</summary>
<p style="color: DarkSlateGrey">
Il détermine quelle opération l’UAL doit effectuer.
</p>
</details>

<details close="">
<summary>
3. Bien qu’il soit possible pour l’instant de simplement coller une constante pour <code class="language-plaintext highlighter-rouge">ALUSel</code>, pourquoi cela serait déconseillé si vous preniez en considération que d’autres instructions seront implémentées dans le futur ?
</summary>
<p style="color: DarkSlateGrey">
Lors de l’implémentation de plus d’instructions, l’entrée <code class="language-plaintext highlighter-rouge">ALUSel</code> de l’UAL pourrait changer en fonction de l’opération demandée. Donc, on a besoin d’une sorte de circuit qui change la valeur de <code class="language-plaintext highlighter-rouge">ALUSel</code> en fonction de l’instruction en cours d’exécution.
</p>
</details>
<p>
<br />
   4. Intégrez dans votre processeur l’UAL développée dans la tâche n°1 de ce projet et connectez correctement les entrées. Avez-vous besoin de connecter une horloge ? Pourquoi ou pourquoi pas ?
</p>
</fieldset>
<p><br /></p>

<h4 id="étape-4--lectureécriture-depuisvers-la-mémoire-de-données-mem"><strong>Étape 4 : Lecture/écriture depuis/vers la mémoire de données (MEM)</strong></h4>

<p>L’étape <strong>MEM</strong> est l’endroit où la mémoire de données peut être modifiée à l’aide des instructions de stockage de données et lue à l’aide des instructions de lecture de données. Comme l’instruction <code class="language-plaintext highlighter-rouge">addi</code> n’utilise pas la mémoire de données, nous pouvons ignorer cette partie du circuit pour l’instant et continuer avec l’étape suivante d’exécution.</p>

<h4 id="étape-5--écriture-éventuelle-dans-le--banc-de-registres--wb"><strong>Étape 5 : Écriture <em>éventuelle</em> dans le « Banc de Registres » (WB)</strong></h4>

<p>L’étape d’écriture (WriteBack) est l’endroit où les résultats d’une opération doivent être sauvegardés dans un registre.</p>

<fieldset class="tips">
<legend style="color: DarkSlateGrey">Indications</legend>
<details close="">
<summary>
1. Est-ce que l’instruction <code class="language-plaintext highlighter-rouge">addi</code> requiert une écriture dans un registre ?
</summary>
<p style="color: DarkSlateGrey">
OUI ! l’instruction <code class="language-plaintext highlighter-rouge">addi</code> prend la sortie d’un calcul d’addition dans l’UAL et la réécrit dans le « Banc de Registres ».
</p>
</details>
<p>
<br />
    2. Nous avons vu dans le cours que l’étape <strong>WB</strong> permet d’écrire dans le « Banc de Registres » la sortie de l’<strong>UAL</strong> ou de la mémoire de données <strong>DMEM</strong>. Créons donc la phase d’écriture dans cette perspective même si nous nous intéressons seulement à l’instruction <code class="language-plaintext highlighter-rouge">addi</code> pour l’instant. Comme seule une donnée à la fois peut être écrite dans le « Banc de Registres » dans l’architecture MIPS, nous devons utiliser un MUX pour choisir laquelle des sorties de l’UAL ou de <strong>DMEM</strong> (<code class="language-plaintext highlighter-rouge">READ_DATA</code>) à transmettre. Plus tard, lorsque vous implémenterez d’autres instructions dans la partie B du projet, vous devriez revoir l’implémentation de ce multiplexeur pour gérer plus de cas.
</p>
<details close="">
<summary>
3. Que devons-nous utiliser comme entrée de sélection du MUX ? De quoi dépend l’entrée ?
</summary>
<p style="color: DarkSlateGrey">
On devrait pouvoir choisir entre trois entrées MUX : (1) UAL, (2) MEM [<code class="language-plaintext highlighter-rouge">READ_DATA</code>] et (3) PC + 4 (quand est-ce on aura besoin de celui-là ?). Le signal de commande qui détermine laquelle de ces entrées est transmise au « Banc de Registres » est appelé <code class="language-plaintext highlighter-rouge">WBSel</code>. Pour l’instant, WBSel devrait avoir une seule valeur - quelle qu’elle soit pour <code class="language-plaintext highlighter-rouge">addi</code>.
</p>
</details>

<details close="">
<summary>
4. Maintenant que les entrées du MUX sont fixées, nous devons brancher sa sortie ! Où doit-elle être raccordée ?
</summary>
<p style="color: DarkSlateGrey">
La sortie du MUX véhicule les données que vous souhaitez écrire dans le « Banc de Registres », elle doit donc être raccordée à l’entrée <code class="language-plaintext highlighter-rouge">Write Data</code> du « Banc de Registres ».
</p>
</details>
<p>
<br />
    5. Il y a deux autres entrées sur le « Banc de Registres » qui sont importantes pour l’écriture des données : <code class="language-plaintext highlighter-rouge">RegWEn</code> et <code class="language-plaintext highlighter-rouge">Write_Data</code>. L’une d’entre elles devra être récupérée de l’étape de décodage d’instructions (ID) et l’autre correspond à un nouveau signal de commande que vous devez concevoir dans la partie B du projet. Veuillez finaliser l’étape de l’écriture en implémentant correctement ces entrées pour l’instruction <code class="language-plaintext highlighter-rouge">addi</code>.
</p>
</fieldset>

<p>Si vous avez effectué toutes les étapes correctement, vous devriez avoir un processeur à cycle unique qui fonctionne pour les instructions <code class="language-plaintext highlighter-rouge">addi</code>. Exécutez <code class="language-plaintext highlighter-rouge">python3 test_runner.py part_a addi_single</code> depuis le terminal et vérifiez si votre implémentation fonctionne correctement !</p>

<h3 id="guide--parallélisation-pipelining-de-votre-processeur">Guide : Parallélisation (pipelining) de votre processeur</h3>

<p>Il est maintenant temps de transformer votre processeur à cycle unique en une version « pipeline » ! Pour ce projet, vous allez implémenter un pipeline à deux étages, qui est encore conceptuellement similaire au pipeline à cinq étages introduit dans le cours. Les deux étages que vous mettrez en oeuvre sont les suivantes :</p>

<ol>
  <li>Récupération d’instruction (PIF) : Une instruction est récupérée depuis la mémoire d’instructions.</li>
  <li>Exécution de l’instruction (PEX) : L’instruction est décodée, exécutée et validée (résultat sauvegardé). Il s’agit d’une combinaison des quatre dernières étapes (ID, EX, MEM et WB) dans un processeur à cycle unique.</li>
</ol>

<p>Comme le décodage et l’exécution de l’instruction sont gérés dans l’étape d’exécution, <strong>votre processeur <code class="language-plaintext highlighter-rouge">addi</code> en pipeline sera plus ou moins identique à sa version en « cycle unique », à l’exception de la latence de démarrage d’un cycle d’horloge</strong>. Nous allons, cependant, appliquer les règles de conception de pipeline vues en cours afin de préparer notre processeur pour la partie B de ce projet.</p>

<p>Quelques points à considérer pour une conception du pipeline en deux étages :</p>

<ul>
  <li>Les étages PIF et PEX auront-ils des valeurs <code class="language-plaintext highlighter-rouge">PC</code> identiques ou différentes ?</li>
  <li>Avez-vous besoin de stocker le <code class="language-plaintext highlighter-rouge">PC</code> entre les étages de pipeline ?</li>
</ul>

<p>D’autre part, on remarquera un problème d’amorçage ici : pendant le premier cycle d’exécution, les registres introduits entre les différentes étapes du pipeline sont initialement (vides), mais le vide n’existe pas en hardware. Comment allons-nous gérer cette première instruction fictive ? A quoi correspondrait le vide dans notre processeur ? C-à-d. à quelle valeur devons-nous initialer les registres nouvellement introduits pour ne « <strong>rien faire</strong> » pendant le premier cycle d’exécution ?</p>

<p>Il arrive que Logisim remet automatiquement les registres à zéro au démarrage (ou lors de la réinitialisation); ce qui, pour notre problème de cpu en pipeline, simulera une instruction <code class="language-plaintext highlighter-rouge">nop</code> ! Merci Logisim ! N’oubliez pas d’aller dans « <strong>Simulate | Reset Simulation</strong> » pour réinitialiser votre processeur.</p>

<p>Après avoir « pipeliné » votre processeur, vous devriez être en mesure de réussir le test <code class="language-plaintext highlighter-rouge">python3 test_runner.py part_a addi_pipelined</code>. Notez que le précédent test <code class="language-plaintext highlighter-rouge">python3 test_runner.py part_a addi_single</code> devrait échouer maintenant ( pourquoi ? Consultez les sorties de référence pour chaque test et réfléchissez aux effets du pipeline sur les différentes étapes ).</p>

<!--{:start="7"}-->

<h2 id="comprendre-les-tests-effectués">Comprendre les tests effectués</h2>

<p>Les tests cpu inclus dans le code de démarrage sont des copies des fichiers <code class="language-plaintext highlighter-rouge">run_*.circ</code> et contiennent des instructions préalablement chargées dans la mémoire d’instructions (<code class="language-plaintext highlighter-rouge">Instruction Memory</code>). Lorsque <strong>logisim-evolution</strong> est lancé à partir de la <a href="http://www.cburch.com/logisim/docs/2.6.0/en/guide/verify/index.html">ligne de commande</a>, votre circuit est automatiquement mis en marche. L’exécution est cadencée par l’horloge, le <code class="language-plaintext highlighter-rouge">PC</code> de votre processeur est mis à jour, l’instruction récupérée est traitée, et les valeurs de chacune des sorties du circuit de test sont imprimées sur le terminal.</p>

<p>Prenons l’exemple du test <code class="language-plaintext highlighter-rouge">addi-pipelined</code>. Le circuit <code class="language-plaintext highlighter-rouge">cpu-addi.circ</code> contient trois instructions <code class="language-plaintext highlighter-rouge">addi</code> (<code class="language-plaintext highlighter-rouge">addi $t0, $0, 5</code>, <code class="language-plaintext highlighter-rouge">addi $t1, $t0, 7</code> et <code class="language-plaintext highlighter-rouge">addi $s0, $t0, 9</code>). Ouvrez le fichier <code class="language-plaintext highlighter-rouge">tests/part_a/addi_pipelined/cpu-addi.circ</code> dans Logisim et examinez de plus près les différentes parties du circuit de test. En haut, vous verrez l’endroit où le socle testeur <code class="language-plaintext highlighter-rouge">test_harness</code> est connecté aux sorties de débogage. Initialement, ces sorties sont toutes des <code class="language-plaintext highlighter-rouge">UUUUU</code>, mais cela ne devrait pas être le cas une fois votre circuit <code class="language-plaintext highlighter-rouge">cpu_pipelined.circ</code> est implémenté.</p>

<p>Le socle <code class="language-plaintext highlighter-rouge">test_harness</code> prend en entrée le signal d’horloge <code class="language-plaintext highlighter-rouge">clk</code> et l’<code class="language-plaintext highlighter-rouge">Instruction</code> fournie par le module de mémoire <code class="language-plaintext highlighter-rouge">Instruction Memory</code>. En sortie, le socle transmet pour affichage les valeurs des registres de débogage provenant de votre circuit de processeur <code class="language-plaintext highlighter-rouge">cpu_pipelined.circ</code>. La sortie additionnelle <code class="language-plaintext highlighter-rouge">fetch_addr</code> transmet l’adresse de la prochaine instruction à lire à la mémoire d’instructions <code class="language-plaintext highlighter-rouge">Instruction Memory</code>.</p>

<div class="bs-callout bs-callout-danger">
  <p>Veillez à ne déplacer aucune des entrées/sorties de votre processeur, ni à ajouter des entrées/sorties supplémentaires. Cela modifiera la forme du sous-circuit du processeur et, par conséquent, les connexions dans les fichiers de test risquent de ne plus fonctionner correctement.</p>
</div>

<p>Sous le socle <code class="language-plaintext highlighter-rouge">test_harness</code>, vous verrez la mémoire d’instructions contenant le code machine en hexadécimal des trois instructions <code class="language-plaintext highlighter-rouge">addi</code> testés (0x20080005, 0x21090007, 0x21100009). La mémoire d’instructions prend une entrée (appelée <code class="language-plaintext highlighter-rouge">fetch_addr</code>) et délivre l’instruction stockée à cette adresse. Dans MIPS, <code class="language-plaintext highlighter-rouge">fetch_addr</code> est une valeur de 32 bits, mais comme Logisim limite la taille des unités ROM à \(2^{16}\), nous devons utiliser un séparateur pour récupérer seulement 14 bits de <code class="language-plaintext highlighter-rouge">fetch_addr</code> (en ignorant les deux bits les plus bas).</p>

<fieldset class="tips">
<legend style="color: DarkSlateGrey">Indication</legend>
<details close="">
<summary>
Pourquoi les deux bits LSB de l’adresse <code class="language-plaintext highlighter-rouge">fetch_addr</code> sont ignorés ?
</summary>
<p style="color: DarkSlateGrey">
Dans MIPS, les instructions sont récupérées mot-par-mot depuis la mémoire d’instructions. Donc, on a besoin de convertir <code class="language-plaintext highlighter-rouge">fetch_addr</code> qui est une adresse d’octets, en une adresse de mots en supprimant les deux bits les plus faibles.
</p>
</details>
</fieldset>

<p>Ainsi, quand le circuit de test est mis en marche, chaque tick de l’horloge pilote l’exécution du socle <code class="language-plaintext highlighter-rouge">test_harness</code> et  incrémente le compteur appelé <code class="language-plaintext highlighter-rouge">Time_Step</code> (ce compteur se trouve à droite de la mémoire d’instructions, faites un zoom-out dans Logisim s’il n’est pas visible sur votre écran).</p>

<p>A chaque tick de l’horloge, l’exécution en <a href="http://www.cburch.com/logisim/docs/2.6.0/en/guide/verify/index.html">ligne de commande</a> de logisim-evolution imprimera les valeurs de chacune de vos sorties de débogage vers le terminal. L’horloge continuera à tourner jusqu’à ce que <code class="language-plaintext highlighter-rouge">Time_Step</code> soit égal à la constante d’arrêt pour ce circuit de test (pour ce fichier de test en particulier, la constante d’arrêt est 5).</p>

<p>Enfin, nous comparons la sortie de votre circuit au résultat attendu; si la sortie de votre circuit est différente, vous échouerez au test.</p>

<h3 id="les-tests-addi">Les tests <code class="language-plaintext highlighter-rouge">addi</code></h3>

<p>Deux tests pour l’instruction <code class="language-plaintext highlighter-rouge">addi</code> sont fournis dans le kit de démarrage : un test pour le processeur à cycle unique et un test pour le processeur en pipeline. Vous pouvez exécuter le test pour la version « pipeline » avec la commande suivante (remplacez <code class="language-plaintext highlighter-rouge">pipelined</code> par <code class="language-plaintext highlighter-rouge">single</code> pour tester la version « cycle unique ») :</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>python3 test_runner.py part_a addi_pipelined <span class="c"># For a pipelined CPU</span>
</code></pre></div></div>

<p>Vous pouvez consulter les fichiers <code class="language-plaintext highlighter-rouge">.s</code> (MIPS) et <code class="language-plaintext highlighter-rouge">.hex</code> (code machine) utilisés pour le test dans <code class="language-plaintext highlighter-rouge">tests/part_a/addi_pipelined/inputs</code>.</p>

<p>Pour faciliter l’interprétation de votre sortie, un script Python (<code class="language-plaintext highlighter-rouge">binary_to_hex_cpu.py</code>) est également inclus. Ce script fonctionne comme les scripts <code class="language-plaintext highlighter-rouge">binary_to_hex_alu.py</code> et <code class="language-plaintext highlighter-rouge">binary_to_hex_regfile.py</code> utilisés dans les tâches de conception de l’UAL et du « Banc de Registres » (Tâches n° 1 et 2). Pour utiliser le script, exécutez :</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">cd </span>tests/part_a/addi_pipelined
<span class="nv">$ </span>python3 binary_to_hex_cpu.py student_output/CPU-addi-pipelined-student.out
</code></pre></div></div>

<p>ou, pour visualiser la sortie de référence, exécutez:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">cd </span>tests/part_a/addi_pipelined
<span class="nv">$ </span>python3 binary_to_hex_cpu.py reference_output/CPU-addi-pipelined-ref.out
</code></pre></div></div>

<h2 id="soumettre-la-partie-a-du-devoir">Soumettre la partie A du devoir</h2>

<p>Assurez-vous à nouveau que vous n’avez pas déplacé/modifié vos ports d’entrée/sortie et que vos circuits s’insèrent sans problème dans les socles de test fournis.</p>

<p>Pour l’évaluation de cette partie du projet, vous devez soumettre un fichier <strong>zippé</strong> contenant tous les circuits que vous devez implémenter. C.-à-d. les circuits <strong>alu.circ</strong>, <strong>regfile.circ</strong>, <strong>imm_gen.circ</strong>, <strong>control_logic.circ</strong> et <strong>cpu_*.circ</strong>.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>votre_fichier.zip
 ├── alu.circ
 ├── regfile.circ
 ├── imm_gen.circ
 ├── control_logic.circ
 ├── cpu_single.circ
 └── cpu_pipelined.circ
</code></pre></div></div>

<p>Par exemple, pour mettre les fichiers <strong>file1.circ</strong> et <strong>file2.circ</strong> dans un fichier zip nommé  <strong>votre_fichier.zip</strong> :</p>
<ol>
  <li>Ouvrez une console (Ctrl-Alt-T sous Ubuntu), puis allez dans le répertoire contenant les fichiers <strong>file1.circ</strong> et <strong>file2.circ</strong>.</li>
  <li>Tapez la commande :
    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>zip votre_fichier.zip  file1.circ file2.circ
</code></pre></div>    </div>
  </li>
</ol>

<p>Soumettez ensuite le fichier résultat <strong>votre_fichier.zip</strong> à l’évaluateur automatique. Cette partie du projet utilisera les mêmes fichiers de test déjà fournis dans le kit de démarrage pour l’évaluation de votre travail. Il n’y a pas de test caché !</p>

<hr />

<h1 id="partie-b--version-avancée">Partie B : Version avancée</h1>

<h2 id="tâche-4--plus-dinstructions">Tâche 4 : Plus d’instructions</h2>

<p>Dans la tâche n°3, vous avez implémenté un processeur basique en pipeline à deux étages capable d’exécuter les instructions <code class="language-plaintext highlighter-rouge">addi</code>. Maintenant, vous allez renforcer votre processeur en implémentant plus d’instructions !</p>

<h3 id="larchitecture-du-jeu-dinstructions-isa">L’architecture du jeu d’instructions (ISA)</h3>

<p>Votre implémentation du CPU sera évaluée uniquement sur les instructions énumérées ci-dessous. Votre processeur doit prendre en charge ces instructions, mais n’hésitez pas à implémenter des instructions supplémentaires si cela vous tente ! Assurez-vous, cependant, qu’aucune de vos instructions additionnelles n’affecte le fonctionnement des instructions spécifiées ici. L’implémentation d’instructions supplémentaires n’affectera pas votre score pour ce projet.</p>

<table class="styled-table">
<colgroup>
<col width="15%" />
<col width="30%" />
<col width="32%" />
<col width="8%" />
<col width="15%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align:center">Instruction</th>
<th style="text-align:center">Description</th>
<th style="text-align:center">Opération</th>
<th style="text-align:center">Type</th>
<th style="text-align:center">Opcode/Func</th>

</tr>
</thead>
<tbody>

<tr>
<td style="text-align:left"><strong>add</strong> rd, rs, rt</td>
<td style="text-align:left">Addition</td>
<td style="text-align:left">R[rd] ← R[rs] + R[rt]</td>
<td style="text-align:center">R</td>
<td style="text-align:left"> 0x0 / 0x20</td>
</tr>

<tr>
<td style="text-align:left"><strong>sub</strong> rd, rs, rt</td>
<td style="text-align:left">Soustraction</td>
<td style="text-align:left">R[rd] ← R[rs] - R[rt]</td>
<td style="text-align:center">R</td>
<td style="text-align:left"> 0x0 / 0x22</td>
</tr>

<tr>
<td style="text-align:left"><strong>addi</strong> rt, rs, imm</td>
<td style="text-align:left">Addition<br />(2<sup>ème</sup> param. : immédiat)</td>
<td style="text-align:left">R[rt] ← R[rs] + imm<sub>±</sub></td>
<td style="text-align:center">I</td>
<td style="text-align:left"> 0x8</td>
</tr>

<tr>
<td style="text-align:left"><strong>mul</strong> rd, rs, rt</td>
<td style="text-align:left">Multiplication</td>
<td style="text-align:left">R[rd] ← (R[rs] x R[rt])[31:0]</td>
<td style="text-align:center">R</td>
<td style="text-align:left"> 0x0 / 0x18</td>
</tr>

<tr>
<td style="text-align:left"><strong>mulh</strong> rd, rs, rt</td>
<td style="text-align:left">Multiplication</td>
<td style="text-align:left">R[rd] ← (R[rs] x R[rt])[63:32]</td>
<td style="text-align:center">R</td>
<td style="text-align:left"> 0x0 / 0x10</td>
</tr>

<tr>
<td style="text-align:left"><strong>mulhu</strong> rd, rs, rt</td>
<td style="text-align:left">Multiplication;<br />(params non signés)</td>
<td style="text-align:left">R[rd] ← (R[rs] x R[rt])[63:32]</td>
<td style="text-align:center">R</td>
<td style="text-align:left"> 0x0 / 0x19</td>
</tr>


<tr>
<td style="text-align:left"><strong>and</strong> rd, rs, rt</td>
<td style="text-align:left">ET logique</td>
<td style="text-align:left">R[rd] ← R[rs] &amp; R[rt]</td>
<td style="text-align:center">R</td>
<td style="text-align:left"> 0x0 / 0x24</td>
</tr>

<tr>
<td style="text-align:left"><strong>or</strong> rd, rs, rt</td>
<td style="text-align:left">OU logique</td>
<td style="text-align:left">R[rd] ← R[rs] | R[rt]</td>
<td style="text-align:center">R</td>
<td style="text-align:left"> 0x0 / 0x25</td>
</tr>

<tr>
<td style="text-align:left"><strong>xor</strong> rd, rs, rt</td>
<td style="text-align:left">OU exclusif</td>
<td style="text-align:left">R[rd] ← R[rs] ^ R[rt]</td>
<td style="text-align:center">R</td>
<td style="text-align:left"> 0x0 / 0x26</td>
</tr>

<tr>
<td style="text-align:left"><strong>andi</strong> rt, rs, imm</td>
<td style="text-align:left">ET logique<br />(2<sup>ème</sup> param. : immédiat)</td>
<td style="text-align:left">R[rd] ← R[rs] &amp; imm<sub>0</sub></td>
<td style="text-align:center">I</td>
<td style="text-align:left"> 0xC</td>
</tr>

<tr>
<td style="text-align:left"><strong>ori</strong> rt, rs, imm</td>
<td style="text-align:left">OU logique<br />(2<sup>ème</sup> param. : immédiat)</td>
<td style="text-align:left">R[rd] ← R[rs] | imm<sub>0</sub></td>
<td style="text-align:center">I</td>
<td style="text-align:left"> 0xD</td>
</tr>

<tr>
<td style="text-align:left"><strong>xori</strong> rt, rs, imm</td>
<td style="text-align:left">OU exclusif<br />(2<sup>ème</sup> param. : immédiat)</td>
<td style="text-align:left">R[rd] ← R[rs] ^ imm<sub>0</sub></td>
<td style="text-align:center">I</td>
<td style="text-align:left"> 0xE</td>
</tr>

<tr>
<td style="text-align:left"><strong>sll</strong> rd, rt, sh</td>
<td style="text-align:left">Décalage logique à gauche</td>
<td style="text-align:left">R[rd] ← R[rt] &lt;&lt; sh</td>
<td style="text-align:center">R</td>
<td style="text-align:left"> 0x0 / 0x0</td>
</tr>

<tr>
<td style="text-align:left"><strong>srl</strong> rd, rt, sh</td>
<td style="text-align:left">Décalage logique à droite</td>
<td style="text-align:left">R[rd] ← R[rt] &gt;&gt;&gt; sh</td>
<td style="text-align:center">R</td>
<td style="text-align:left"> 0x0 / 0x2</td>
</tr>

<tr>
<td style="text-align:left"><strong>sra</strong> rd, rt, sh</td>
<td style="text-align:left">Décalage arithmétique à droite</td>
<td style="text-align:left">R[rd] ← R[rt] &gt;&gt; sh</td>
<td style="text-align:center">R</td>
<td style="text-align:left"> 0x0 / 0x3</td>
</tr>

<tr>
<td style="text-align:left"><strong>sllv</strong> rd, rt, rs</td>
<td style="text-align:left">Décalage logique à gauche<br />avec registre</td>
<td style="text-align:left">R[rd] ← R[rt] &lt;&lt; rs</td>
<td style="text-align:center">R</td>
<td style="text-align:left"> 0x0 / 0x4</td>
</tr>

<tr>
<td style="text-align:left"><strong>srlv</strong> rd, rt, rs</td>
<td style="text-align:left">Décalage logique à droite<br />avec registre</td>
<td style="text-align:left">R[rd] ← R[rt] &gt;&gt;&gt; rs</td>
<td style="text-align:center">R</td>
<td style="text-align:left"> 0x0 / 0x6</td>
</tr>

<tr>
<td style="text-align:left"><strong>srav</strong> rd, rt, rs</td>
<td style="text-align:left">Décalage arithmétique à droite<br />avec registre</td>
<td style="text-align:left">R[rd] ← R[rt] &gt;&gt; rs</td>
<td style="text-align:center">R</td>
<td style="text-align:left"> 0x0 / 0x7</td>
</tr>

<tr>
<td style="text-align:left"><strong>slt</strong> rd, rs, rt</td>
<td style="text-align:left">Positionné si inférieur</td>
<td style="text-align:left">R[rd] ← R[rs] &lt; R[rt] ? 1 : 0</td>
<td style="text-align:center">R</td>
<td style="text-align:left"> 0x0 / 0x2A</td>
</tr>

<tr>
<td style="text-align:left"><strong>sltu</strong> rd, rs, rt</td>
<td style="text-align:left">Positionné si inférieur (non signés)</td>
<td style="text-align:left">R[rd] ← R[rs] &lt; R[rt] ? 1 : 0</td>
<td style="text-align:center">R</td>
<td style="text-align:left"> 0x0 / 0x2B</td>
</tr>

<tr>
<td style="text-align:left"><strong>slti</strong> rt, rs, imm</td>
<td style="text-align:left">Positionné si inférieur<br />(2<sup>ème</sup> param. : immédiat)</td>
<td style="text-align:left">R[rt] ← R[rs] &lt; imm<sub>±</sub> ? 1 : 0</td>
<td style="text-align:center">I</td>
<td style="text-align:left"> 0xA</td>
</tr>

<tr>
<td style="text-align:left"><strong>sltiu</strong> rt, rs, imm</td>
<td style="text-align:left">Positionné si inférieur (non signée)<br />(2<sup>ème</sup> param. : immédiat)</td>
<td style="text-align:left">R[rt] ← R[rs] &lt; imm<sub>±</sub> ? 1 : 0</td>
<td style="text-align:center">I</td>
<td style="text-align:left"> 0xB</td>
</tr>

<tr>
<td style="text-align:left"><strong>j</strong> imm</td>
<td style="text-align:left">Saut étiquette</td>
<td style="text-align:left">PC ← PC &amp; 0xF0000000 | (imm &lt;&lt; 2)</td>
<td style="text-align:center">J</td>
<td style="text-align:left"> 0x2</td>
</tr>

<tr>
<td style="text-align:left"><strong>jal</strong> imm</td>
<td style="text-align:left">Saut et liaison</td>
<td style="text-align:left">$ra ← PC + 4;<br />PC ← PC &amp; 0xF0000000 | (imm &lt;&lt; 2)</td>
<td style="text-align:center">J</td>
<td style="text-align:left"> 0x3</td>
</tr>

<tr>
<td style="text-align:left"><strong>jalr</strong> rd, rs</td>
<td style="text-align:left">Saut et lien sur registre</td>
<td style="text-align:left">R[rd] ← PC + 4;<br />PC ← R[rs]</td>
<td style="text-align:center">R</td>
<td style="text-align:left"> 0x0 / 0x9</td>
</tr>

<tr>
<td style="text-align:left"><strong>beq</strong> rt, rs, imm</td>
<td style="text-align:left">Branchement si égalité</td>
<td style="text-align:left">if (R[rs] == R[rt])<br /> PC ← PC + 4 + (imm<sub>±</sub>&lt;&lt; 2)</td>
<td style="text-align:center">I</td>
<td style="text-align:left"> 0x4</td>
</tr>

<tr>
<td style="text-align:left"><strong>bne</strong> rt, rs, imm</td>
<td style="text-align:left">Branchement si différent</td>
<td style="text-align:left">if (R[rs] != R[rt])<br /> PC ← PC + 4 + (imm<sub>±</sub>&lt;&lt; 2)</td>
<td style="text-align:center">I</td>
<td style="text-align:left"> 0x5</td>
</tr>

<tr>
<td style="text-align:left"><strong>lui</strong> rt, imm</td>
<td style="text-align:left">Chargement immédiat</td>
<td style="text-align:left">R[rt] ← imm &lt;&lt; 16</td>
<td style="text-align:center">I</td>
<td style="text-align:left"> 0xF</td>
</tr>

<tr>
<td style="text-align:left"><strong>lb</strong> rt, imm(rs)</td>
<td style="text-align:left">Chargement octet</td>
<td style="text-align:left">R[rt] ← Mem( R[rs] + imm<sub>±</sub>, octet )<sub>±</sub></td>
<td style="text-align:center">I</td>
<td style="text-align:left"> 0x20</td>
</tr>

<tr>
<td style="text-align:left"><strong>lh</strong> rt, imm(rs)</td>
<td style="text-align:left">Chargement demi-mot</td>
<td style="text-align:left">R[rt] ← Mem( R[rs] + imm<sub>±</sub>, demi )<sub>±</sub></td>
<td style="text-align:center">I</td>
<td style="text-align:left"> 0x21</td>
</tr>

<tr>
<td style="text-align:left"><strong>lw</strong> rt, imm(rs)</td>
<td style="text-align:left">Chargement mot</td>
<td style="text-align:left">R[rt] ← Mem( R[rs] + imm<sub>±</sub>, mot )</td>
<td style="text-align:center">I</td>
<td style="text-align:left"> 0x23</td>
</tr>

<tr>
<td style="text-align:left"><strong>sb</strong> rt, imm(rs)</td>
<td style="text-align:left">Sauvegarde octet</td>
<td style="text-align:left">Mem( R[rs] + imm<sub>±</sub> ) ← R[rt][7:0]</td>
<td style="text-align:center">I</td>
<td style="text-align:left"> 0x28</td>
</tr>

<tr>
<td style="text-align:left"><strong>sh</strong> rt, imm(rs)</td>
<td style="text-align:left">Sauvegarde demi-mot</td>
<td style="text-align:left">Mem( R[rs] + imm<sub>±</sub> ) ← R[rt][15:0]</td>
<td style="text-align:center">I</td>
<td style="text-align:left"> 0x29</td>
</tr>

<tr>
<td style="text-align:left"><strong>sw</strong> rt, imm(rs)</td>
<td style="text-align:left">Sauvegarde mot</td>
<td style="text-align:left">Mem( R[rs] + imm<sub>±</sub> ) ← R[rt]</td>
<td style="text-align:center">I</td>
<td style="text-align:left"> 0x2b</td>
</tr>

</tbody>
</table>

<p><strong>Remarques</strong> :</p>

<ol>
  <li>La notation imm<sub>±</sub> dans le tableau ci-dessus signifie « Application d’une extension de signe à l’immédiat imm ». La même remarque s’applique à Mem(…)<sub>±</sub>. Dans ce cas l’extension de signe est appliquée à l’octet ou le demi-mot récupéré depuis la mémoire.</li>
  <li>La notation imm<sub>0</sub> signifie « Application d’une extension par des zéros à l’immédiat imm ».</li>
</ol>

<h3 id="info--mémoire-ram-circuit-memcirc">Info : Mémoire RAM (circuit <code class="language-plaintext highlighter-rouge">mem.circ</code>)</h3>

<p>L’unité de mémoire DMEM (fournie dans <code class="language-plaintext highlighter-rouge">mem.circ</code>) est déjà entièrement implémentée pour vous et raccordée aux sorties de votre processeur dans <code class="language-plaintext highlighter-rouge">test_harness.circ</code> ! C.-à-d. Il n’est pas nécessaire d’ajouter l’unité mémoire (<code class="language-plaintext highlighter-rouge">mem.circ</code>) à nouveau à votre implémentation. Au fait, cela entraînera un échec des scripts d’auto évaluation ce qui ne sera pas bon pour votre score :(.</p>

<p>Notez que l’implémentation fournie de l’unité DMEM permet les inscriptions au niveau <strong>octet</strong>. Cela signifie que le signal <code class="language-plaintext highlighter-rouge">Write_En</code> a une largeur de 4 bits et agit comme un masque d’écriture pour les données en entrée. Par exemple, si <code class="language-plaintext highlighter-rouge">Write_En</code> vaut <code class="language-plaintext highlighter-rouge">0b1000</code>, alors seul l’octet le plus significatif du mot adressé en mémoire sera écrasé (ex: <code class="language-plaintext highlighter-rouge">sb $a0, 3($s0)</code>).</p>

<p>D’autre part, le port <code class="language-plaintext highlighter-rouge">ReadData</code> renverra toujours, indépendamment de <code class="language-plaintext highlighter-rouge">Write_En</code>, la valeur en mémoire (un mot entier) à l’adresse fournie. L’unité de mémoire ignore les deux bits de poids faible dans l’adresse que vous lui fournissez et traite son entrée comme une adresse de mot plutôt qu’une adresse d’octet. Par exemple, si vous entrez l’adresse 32 bits <code class="language-plaintext highlighter-rouge">0x00001007</code> (ex: <code class="language-plaintext highlighter-rouge">lb $a0, 7($s0)</code>, avec <code class="language-plaintext highlighter-rouge">$s0=0x0001000</code>), elle sera traitée comme l’adresse de mot <code class="language-plaintext highlighter-rouge">0x00001004</code>, et vous obtiendrez en sortie les 4 octets aux adresses <code class="language-plaintext highlighter-rouge">0x00001004</code>, <code class="language-plaintext highlighter-rouge">0x00001005</code>, <code class="language-plaintext highlighter-rouge">0x00001006</code> et <code class="language-plaintext highlighter-rouge">0x00001007</code>. Vous devez donc implémenter la logique de masque nécessaire pour inscrire que les octets requis (octet n° 3 pour l’exemple <code class="language-plaintext highlighter-rouge">lb $a0, 7($s0)</code>) dans le « banc de registres ».</p>

<p>Finalement, rappelez-vous que les accès non alignés à la RAM entraîneront des exceptions dans MIPS. Et comme nous n’implémentons aucune gestion des exceptions dans ce projet, vous pouvez supposer que seuls les accès sur des adresses alignées sont utilisés pour les instructions <code class="language-plaintext highlighter-rouge">lw</code>, <code class="language-plaintext highlighter-rouge">lh</code>, <code class="language-plaintext highlighter-rouge">sh</code> et <code class="language-plaintext highlighter-rouge">sw</code>. Cela signifie que les adresses utilisées avec les instructions <code class="language-plaintext highlighter-rouge">lw</code> et <code class="language-plaintext highlighter-rouge">sw</code> (resp. <code class="language-plaintext highlighter-rouge">lh</code> et <code class="language-plaintext highlighter-rouge">sh</code>) sont des multiples de 4 (resp. multiples de 2). La valeur 4 (resp. 2) correspond à la taille en octets d’un mot (resp. demi-mot) en mémoire.</p>

<p>Voici un résumé des entrées et sorties de la mémoire :</p>

<table class="styled-table">
<colgroup>
<col width="10%" />
<col width="10%" />
<col width="20%" />
<col width="60%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align:center">Nom</th>
<th style="text-align:center">Direction</th>
<th style="text-align:center">Largeur en bits</th>
<th style="text-align:center">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">WriteAddr</td>
<td style="text-align:center">Entrée</td>
<td style="text-align:center">32</td>
<td>Adresse à lire / écrire en mémoire</td>
</tr>
<tr>
<td style="text-align:center">WriteData</td>
<td style="text-align:center">Entrée</td>
<td style="text-align:center">32</td>
<td>Valeur à écrire dans la mémoire</td>
</tr>
<tr>
<td style="text-align:center">Write_En</td>
<td style="text-align:center">Entrée</td>
<td style="text-align:center">4</td>
<td>Le masque d’écriture pour les instructions qui écrivent dans la mémoire et zéro sinon</td>
</tr>
<tr>
<td style="text-align:center">CLK</td>
<td style="text-align:center">Entrée</td>
<td style="text-align:center">1</td>
<td>Entrée fournissant l’horloge du CPU</td>
</tr>
<tr>
<td style="text-align:center">ReadData</td>
<td style="text-align:center">Sortie</td>
<td style="text-align:center">32</td>
<td>Valeur des données stockées à l’adresse indiquée</td>
</tr>
</tbody>
</table>

<h3 id="info--unité-de-branchement-circuit-branch_compcirc">Info : Unité de Branchement (circuit <code class="language-plaintext highlighter-rouge">branch_comp.circ</code>)</h3>

<p>L’« Unité de Branchement » (squelette fourni dans le fichier <code class="language-plaintext highlighter-rouge">branch_comp.circ</code>) devrait calculer la nouvelle valeur du compteur ordinal (c.-à-d. newPC) quand l’instruction en cours d’exécution est un branchement ou un saut par « immediat » dans le code.</p>

<p>Pour éditer ce circuit, modifiez le fichier <code class="language-plaintext highlighter-rouge">branch_comp.circ</code> et non le circuit virtuel <code class="language-plaintext highlighter-rouge">branch_comp</code> inclus dans <code class="language-plaintext highlighter-rouge">cpu_*.circ</code>. Notez qu’à chaque modification du circuit <code class="language-plaintext highlighter-rouge">branch_comp.circ</code>, vous devrez fermer et ouvrir <code class="language-plaintext highlighter-rouge">cpu_*.circ</code> pour appliquer les modifications dans votre CPU.</p>

<p>Voici un résumé des entrées et sorties de cette unité :</p>

<table class="styled-table">
<colgroup>
<col width="10%" />
<col width="10%" />
<col width="20%" />
<col width="60%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align:center">Nom</th>
<th style="text-align:center">Direction</th>
<th style="text-align:center">Largeur en bits</th>
<th style="text-align:center">Description</th>
</tr>
</thead>
<tbody>

<tr>
<td style="text-align:center">inst</td>
<td style="text-align:center">Entrée</td>
<td style="text-align:center">32</td>
<td>L’instruction en cours d’exécution</td>
</tr>

<tr>
<td style="text-align:center">ximm</td>
<td style="text-align:center">Entrée</td>
<td style="text-align:center">32</td>
<td>L’immédiat renvoyé par la sortie <strong>Imm</strong> du « Générateur d’Immédiat » </td>
</tr>

<tr>
<td style="text-align:center">PC</td>
<td style="text-align:center">Entrée</td>
<td style="text-align:center">32</td>
<td>La valeur du registre PC</td>
</tr>

<tr>
<td style="text-align:center">zero</td>
<td style="text-align:center">Entrée</td>
<td style="text-align:center">1</td>
<td>La valeur renvoyé par la sortie <strong>zero</strong> de l’UAL</td>
</tr>

<tr>
<td style="text-align:center">BrUn</td>
<td style="text-align:center">Entrée</td>
<td style="text-align:center">2</td>
<td>Valeur permettant d’identifier l’instruction de branchement/saut à traiter</td>
</tr>

<tr>
<td style="text-align:center">newPC</td>
<td style="text-align:center">Sortie</td>
<td style="text-align:center">32</td>
<td>Nouvelle valeur à transmettre au PC</td>
</tr>

<tr>
<td style="text-align:center">BrJmp</td>
<td style="text-align:center">Sortie</td>
<td style="text-align:center">1</td>
<td>Indique si l’instruction traitée est un branchement/saut dans le code</td>
</tr>
</tbody>
</table>

<h3 id="info--générateur-dimmédiat-circuit-imm_gencirc-1">Info : Générateur d’Immédiat (circuit <code class="language-plaintext highlighter-rouge">imm_gen.circ</code>)</h3>

<p>l’unité « Générateur d’Immédiat » (squelette fourni dans le fichier <code class="language-plaintext highlighter-rouge">imm_gen.circ</code>) devrait calculer les constantes « Imm » des instructions de type I et la valeur du champ « shmt » dans les instructions de décalage. Consultez la figure ci-dessous pour savoir comment chaque immédiat doit être formaté dans votre processeur :</p>

<p><img src="/l2ado/static_files/images/immediat_extensions.png" alt="addi format" height="75%" width="75%" class="aligncenter" /></p>

<p>Pour éditer le « Générateur d’Immédiat », modifiez le fichier <code class="language-plaintext highlighter-rouge">imm_gen.circ</code> et non le circuit virtuel <code class="language-plaintext highlighter-rouge">imm_gen</code> inclus dans <code class="language-plaintext highlighter-rouge">cpu_*.circ</code>. Notez qu’à chaque modification du circuit <code class="language-plaintext highlighter-rouge">imm_gen.circ</code>, vous devez fermer et ouvrir le fichier <code class="language-plaintext highlighter-rouge">cpu_*.circ</code> pour appliquer les modifications dans votre CPU.</p>

<p>Encore une fois, voici un résumé des entrées et sorties de l’unité :</p>

<table class="styled-table">
<colgroup>
<col width="10%" />
<col width="10%" />
<col width="20%" />
<col width="60%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align:center">Nom</th>
<th style="text-align:center">Direction</th>
<th style="text-align:center">Largeur en bits</th>
<th style="text-align:center">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">inst</td>
<td style="text-align:center">Entrée</td>
<td style="text-align:center">32</td>
<td>L’instruction en cours d’exécution</td>
</tr>
<tr>
<td style="text-align:center">ImmSel</td>
<td style="text-align:center">Entrée</td>
<td style="text-align:center">2</td>
<td>Valeur déterminant comment reconstruire l’immédiat</td>
</tr>
<tr>
<td style="text-align:center">Imm</td>
<td style="text-align:center">Sortie</td>
<td style="text-align:center">32</td>
<td>Valeur de l’immédiat associé à l’instruction</td>
</tr>
</tbody>
</table>

<h3 id="info--unité-de-contrôle-circuit-control_logiccirc">Info : Unité de contrôle (circuit <code class="language-plaintext highlighter-rouge">control_logic.circ</code>)</h3>

<p>Afin d’exécuter correctement chaque instruction MIPS, les signaux de contrôle jouent un rôle très important dans un processeur (et ce projet !). Le squelette fourni dans le fichier <code class="language-plaintext highlighter-rouge">control_logic.circ</code> est basé sur l’unité de contrôle vue en cour pour un processeur MIPS.</p>

<p>Veuillez jetez un œil sur les présentations Powerpoint du cours pour commencer. Essayez de parcourir le chemin de données avec différents types d’instructions; lorsque vous rencontrez un MUX ou un autre composant, déterminez la valeur du sélecteur ou d’activation dont vous aurez besoin pour cette instruction.</p>

<p>Vous pouvez, si vous le désirez, ajouter plus d’entrées ou de sorties au circuit de démarrage existant en fonction de votre implémentation du circuit de contrôle. Vous pouvez également choisir de n’utiliser qu’un sous ensemble des ports fournis. Cela dit, veuillez ne modifier ni supprimer aucun des ports existants au cours de ce processus.</p>

<p>Il existe deux approches principales pour implémenter le circuit logique de commande afin qu’il puisse extraire l’« opcode / func » d’une instruction et définir les signaux de commande de manière appropriée. La première méthode est le contrôle par circuit câblé. C’est généralement l’approche préférée pour les architectures RISC telles que MIPS et RISC-V. Ici, on utilisera les portes logiques « ET », « OU » et « NON » avec les divers composants qui peuvent être construits à partir de ces portes (comme les MUX et les DEMUX) pour implémenter des tables de vérité et de <a href="https://fr.wikipedia.org/wiki/Table_de_Karnaugh">Karnaugh</a> correspondant aux fonctions identifiées.</p>

<p>L’autre façon de faire est d’utiliser une mémoire ROM (mémoire en lecture seule). Chaque instruction implémentée par un processeur est mappée à une adresse dans cette mémoire où on y stocke le mot de commande et de contrôle pour cette instruction. Un décodeur d’adresse prend donc une instruction en entrée (c.-à-d. le « opcode / func ») et identifie l’adresse du mot contenant les signaux de contrôle pour cette instruction. Cette approche est courante dans les architectures CISC telles que les processeurs Intel x86-64 et offre une certaine flexibilité, car elle peut être reprogrammée en modifiant le contenu de la mémoire ROM.</p>

<p>Pour éditer l’unité de contrôle, modifiez le fichier <code class="language-plaintext highlighter-rouge">control_logic.circ</code> et non le circuit virtuel <code class="language-plaintext highlighter-rouge">control_logic</code> inclus dans <code class="language-plaintext highlighter-rouge">cpu_*.circ</code>. Notez qu’à chaque modification du circuit <code class="language-plaintext highlighter-rouge">control_logic.circ</code>, vous devrez fermer et ouvrir <code class="language-plaintext highlighter-rouge">cpu_*.circ</code> pour appliquer les modifications dans votre CPU.</p>

<h3 id="info-processeur-circuit-cpu_circ">Info: Processeur (circuit <code class="language-plaintext highlighter-rouge">cpu_*.circ</code>)</h3>

<p>Le circuit dans <code class="language-plaintext highlighter-rouge">cpu_*.circ</code> doit implémenter le chemin de données principal et connecter tous les sous-circuits ensemble (UAL, Unité de Branchement, unité de contrôle, Générateur d’Immédiat, mémoire RAM et Banc de Registres).</p>

<p>Dans la partie A, vous avez implémenté un simple pipeline en deux étages dans votre processeur. Vous devez réaliser que les « aléas de données » ne posent PAS de problème ici car tous les accès à toutes les sources de données se produisent dans une seule étape du pipeline (le deuxième étage).</p>

<p>Cependant, comme la partie B de ce projet nécessite la prise en charge des instructions de branchement et de saut, il y a bien des « aléas de contrôle » à gérer. En particulier, l’instruction immédiatement après un branchement ou un saut n’est pas nécessairement exécutée si la branche est prise. Cela rend votre tâche un peu plus complexe car au moment où vous réalisez qu’une branche ou un saut est en phase d’exécution, vous avez déjà accédé à la mémoire d’instructions et récupéré (éventuellement) la mauvaise prochaine instruction. Vous devez donc « annuler » l’instruction récupérée si l’instruction en cours d’exécution est un saut ou un branchement <strong>validé</strong>. Vous ne devez annuler l’instruction récupérée que si une branche est prise (n’annuler pas autrement). L’annulation d’instructions DOIT être accomplie en insérant un <code class="language-plaintext highlighter-rouge">nop</code> dans l’étape d’exécution du pipeline au lieu de l’instruction récupérée. Notez que l’instruction <code class="language-plaintext highlighter-rouge">sll $0, $0, 0</code> ou le code machine associé <code class="language-plaintext highlighter-rouge">0x00000000</code> est une instruction <code class="language-plaintext highlighter-rouge">nop</code> pour notre processeur.</p>

<p>Quelques points à considérer pour votre implémentation :</p>
<ul>
  <li>Les étapes PIF et PEX auront-elles des valeurs PC identiques ou différentes ?</li>
  <li>Avez-vous besoin de stocker le PC entre les différentes étapes du pipeline ?</li>
  <li>Où insérer un <code class="language-plaintext highlighter-rouge">nop</code> éventuel dans le flux d’instructions ?</li>
  <li>Quelle adresse doit être demandée ensuite pendant que l’étape PEX exécute un <code class="language-plaintext highlighter-rouge">nop</code> ? Est-ce différent de la normale ?</li>
</ul>

<h3 id="tester-votre-processeur"><strong>Tester votre Processeur</strong></h3>

<p>Des tests de cohérence sont fournis pour votre processeur dans <code class="language-plaintext highlighter-rouge">tests/part_b/pipelined</code>.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>python3 test_runner.py part_b pipelined
</code></pre></div></div>

<p>Vous pouvez consulter les fichiers <code class="language-plaintext highlighter-rouge">.s</code> (MIPS) et <code class="language-plaintext highlighter-rouge">.hex</code> (code machine) utilisés pour les tests dans <code class="language-plaintext highlighter-rouge">tests/part_b/pipelined/inputs</code>.</p>

<p>Vous pouvez également utiliser le script Python <code class="language-plaintext highlighter-rouge">binary_to_hex_cpu.py</code>, comme dans la tache n° 3 ce projet, afin visualiser et mieux interpréter vos résultats.</p>

<h2 id="soumettre-la-partie-b-du-devoir">Soumettre la partie B du devoir</h2>

<p>Si vous avez terminé la tâche n° 4, vous avez terminé la partie B du projet. Félicitations pour votre nouveau processeur !</p>

<p>Assurez-vous à nouveau que vous n’avez pas déplacé/modifié vos ports d’entrée/sortie et que vos circuits s’insèrent sans problème dans les socles de test fournis.</p>

<p>Pour soumettre votre travail, créez un fichier <strong>zippé</strong> contenant tous les circuits que vous deviez implémenter dans les deux parties de ce projets. C.-à-d. les circuits <strong>alu.circ</strong>, <strong>regfile.circ</strong>, <strong>branch_comp.circ</strong>, <strong>imm_gen.circ</strong>, <strong>control_logic.circ</strong>, <strong>cpu_single.circ</strong> et <strong>cpu_pipelined.circ</strong>.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>votre_fichier.zip
 ├── alu.circ
 ├── regfile.circ
 ├── imm_gen.circ
 ├── branch_comp.circ
 ├── control_logic.circ
 ├── cpu_single.circ
 └── cpu_pipelined.circ
</code></pre></div></div>

<p>Par exemple, pour mettre les fichiers <strong>file1.circ</strong> et <strong>file2.circ</strong> dans un fichier zip nommé  <strong>votre_fichier.zip</strong> :</p>
<ol>
  <li>Ouvrez une console (Ctrl-Alt-T sous Ubuntu), puis allez dans le répertoire contenant les fichiers <strong>file1.circ</strong> et <strong>file2.circ</strong>.</li>
  <li>Tapez la commande :
    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>zip votre_fichier.zip  file1.circ file2.circ
</code></pre></div>    </div>
  </li>
</ol>

<p>Soumettez ensuite le fichier résultat <strong>votre_fichier.zip</strong> à l’évaluateur automatique. Cette partie du projet utilisera les mêmes fichiers de test déjà fournis dans le kit de démarrage pour l’évaluation de votre travail ainsi que d’autres tests cachés.</p>

  </article>

</div>
      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <!--     <h2 class="footer-heading"></h2> -->
    <div class="footer-col-wrapper">
      <div class="footer-col  footer-col-1">

        <p class="text">
          02 rue Didouche Mourad<br />
16000 Alger<br />

      </div>

      <div class="footer-col  footer-col-2">
        <ul class="social-media-list">


          

          

          

          

          




        </ul>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
